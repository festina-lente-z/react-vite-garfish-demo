var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  GarfishRouter: () => GarfishRouter
});
var import_utils4 = require("@garfish/utils");

// src/config.ts
var __GARFISH_ROUTER_UPDATE_FLAG__ = "__GARFISH_ROUTER_UPDATE_FLAG__";
var __GARFISH_ROUTER_FLAG__ = "__GARFISH_ROUTER_FLAG__";
var __GARFISH_BEFORE_ROUTER_EVENT__ = "garfish:before-routing-event";
var RouterConfig = {
  basename: "/",
  current: {
    fullPath: "/",
    path: "/",
    matched: [],
    query: {},
    state: {},
    href: ""
  },
  apps: [],
  beforeEach: (to, from, next) => next(),
  afterEach: (to, from, next) => next(),
  active: () => Promise.resolve(),
  deactive: () => Promise.resolve(),
  routerChange: () => {
  },
  autoRefreshApp: true,
  listening: true
};
function set(field, value) {
  RouterConfig[field] = value;
}
function setRouterConfig(options) {
  Object.assign(RouterConfig, options);
}

// src/utils/urlUt.ts
function parseQuery(query = "") {
  const res = {};
  if (query) {
    query.slice(1).split("&").map((item) => {
      const pairs = item.split("=");
      res[pairs[0]] = pairs;
    });
  }
  return res;
}
function getPath(basename = "/", pathname) {
  if (basename === "/" || basename === "") {
    return pathname || location.pathname;
  } else {
    return (pathname || location.pathname).replace(new RegExp(`^/?${basename}`), "");
  }
}
function getAppRootPath(appInfo) {
  const path = getPath(appInfo.basename, location.pathname);
  let appRootPath = appInfo.basename === "/" ? "" : appInfo.basename || "";
  if (typeof appInfo.activeWhen === "string") {
    appRootPath += appInfo.activeWhen;
  } else {
    appRootPath += path.split("").reduce((pre, next) => {
      if (typeof appInfo.activeWhen === "function" && !appInfo.activeWhen(pre))
        return pre + next;
      return pre;
    }, "");
  }
  return appRootPath;
}

// src/utils/index.ts
async function asyncForEach(arr, callback) {
  const length = arr.length;
  let k = 0;
  while (k < length) {
    const kValue = arr[k];
    await callback(kValue, k, arr);
    k++;
  }
}
function toMiddleWare(to, from, cb) {
  return new Promise((resolve, reject) => {
    try {
      cb(to, from, resolve);
    } catch (err) {
      reject(err);
    }
  });
}
function createEvent(type) {
  let e;
  if (navigator.userAgent.indexOf("MSIE") !== -1 || navigator.appVersion.indexOf("Trident/") > 0) {
    e = document.createEvent("UIEvents");
    e.initUIEvent(type.toLowerCase(), true, false, window, 0);
  } else {
    e = new Event(type.toLowerCase());
  }
  return e;
}

// src/utils/customEvent.ts
var NativeCustomEvent = typeof global !== "undefined" ? global == null ? void 0 : global.CustomEvent : null;
function useNative() {
  try {
    const p = new NativeCustomEvent("cat", { detail: { foo: "bar" } });
    return p.type === "cat" && p.detail.foo === "bar";
  } catch (e) {
  }
  return false;
}
var CustomEvent;
if (NativeCustomEvent && useNative()) {
  CustomEvent = NativeCustomEvent;
} else if (typeof document !== "undefined" && typeof document.createEvent === "function") {
  CustomEvent = function(type, params) {
    params = params || { bubbles: false, cancelable: false, detail: null };
    const evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(type, params.bubbles || false, params.cancelable || false, params.detail || null);
    return evt;
  };
} else {
  CustomEvent = function(type, params) {
    const e = document.createEventObject();
    e.type = type;
    if (params) {
      e.bubbles = Boolean(params.bubbles);
      e.cancelable = Boolean(params.cancelable);
      e.detail = params.detail;
    } else {
      e.bubbles = false;
      e.cancelable = false;
      e.detail = void 0;
    }
    return e;
  };
}
var customEvent_default = CustomEvent;

// src/utils/navEvent.ts
var import_utils = require("@garfish/utils");
function createPopStateEvent(state, originalMethodName) {
  let evt;
  try {
    evt = new PopStateEvent("popstate", { state });
  } catch (err) {
    evt = document.createEvent("PopStateEvent");
    evt.initPopStateEvent("popstate", false, false, state);
  }
  evt.garfish = true;
  evt.garfishTrigger = originalMethodName;
  return evt;
}
var callCapturedEventListeners = (type) => {
  const eventArguments = createPopStateEvent(window.history.state, type);
  window.dispatchEvent(eventArguments);
};
var handlerParams = function(path, query, basename) {
  if (!path || typeof path !== "string")
    return "";
  let url = path;
  if (url[0] !== "/")
    url = "/" + url;
  if (Object.prototype.toString.call(query) === "[object Object]") {
    const qs = Object.keys(query).map((key) => `${key}=${query[key]}`).join("&");
    url += qs ? "?" + qs : "";
  }
  if (basename !== "/")
    url = basename + url;
  if (url[0] !== "/")
    url = "/" + url;
  return url;
};
var push = ({
  path,
  query,
  basename
}) => {
  if (!basename)
    basename = RouterConfig.basename || "/";
  let url = null;
  if ((0, import_utils.validURL)(path)) {
    url = /(^https?:)|(^\/\/)/.test(path) ? path : `//${path}`;
  } else {
    url = handlerParams(path, query, basename);
  }
  history.pushState(__spreadValues({ [__GARFISH_ROUTER_UPDATE_FLAG__]: true }, history.state), "", url);
};
var replace = ({
  path,
  query,
  basename
}) => {
  if (!basename)
    basename = RouterConfig.basename || "/";
  let url = null;
  if ((0, import_utils.validURL)(path)) {
    url = /^(https?:)(\/\/)/.test(path) ? path : `//${path}`;
  } else {
    url = handlerParams(path, query, basename);
  }
  history.replaceState(__spreadValues({ [__GARFISH_ROUTER_UPDATE_FLAG__]: true }, history.state), "", url);
};

// src/linkTo.ts
var hasActive = (activeWhen, path) => {
  if (typeof activeWhen === "string") {
    if (activeWhen[0] !== "/")
      activeWhen = `/${activeWhen}`;
    if (activeWhen === "/" && path === activeWhen)
      return true;
    const activeWhenArr = activeWhen.split("/");
    const pathArr = path.split("/");
    let flag = true;
    activeWhenArr.forEach((pathItem, index) => {
      if (pathItem && pathItem !== pathArr[index]) {
        flag = false;
      }
    });
    return flag;
  } else {
    return activeWhen(path);
  }
};
var linkTo = async ({
  toRouterInfo,
  fromRouterInfo,
  eventType
}) => {
  const {
    current,
    apps,
    deactive,
    active,
    notMatch,
    beforeEach: beforeEach2,
    afterEach: afterEach2,
    autoRefreshApp
  } = RouterConfig;
  const deactiveApps = current.matched.filter((appInfo) => !hasActive(appInfo.activeWhen, getPath(appInfo.basename, location.pathname)));
  const activeApps = apps.filter((appInfo) => {
    return hasActive(appInfo.activeWhen, getPath(appInfo.basename, location.pathname));
  });
  const needToActive = activeApps.filter(({ name }) => {
    return !current.matched.some(({ name: cName }) => name === cName);
  });
  const to = __spreadProps(__spreadValues({}, toRouterInfo), {
    matched: needToActive
  });
  const from = __spreadProps(__spreadValues({}, fromRouterInfo), {
    matched: deactiveApps
  });
  await toMiddleWare(to, from, beforeEach2);
  if (current.matched.length > 0) {
    await asyncForEach(deactiveApps, async (appInfo) => await deactive(appInfo, getPath(appInfo.basename, location.pathname)));
  }
  setRouterConfig({
    current: {
      path: getPath(RouterConfig.basename),
      fullPath: location.pathname,
      href: location.href,
      matched: activeApps,
      state: history.state,
      query: parseQuery(location.search)
    }
  });
  const curState = window.history.state || {};
  if (eventType !== "popstate" && (curState[__GARFISH_ROUTER_UPDATE_FLAG__] || autoRefreshApp)) {
    callCapturedEventListeners(eventType);
  }
  await asyncForEach(needToActive, async (appInfo) => {
    const appRootPath = getAppRootPath(appInfo);
    await active(appInfo, appRootPath);
  });
  if (activeApps.length === 0 && notMatch)
    notMatch(location.pathname);
  await toMiddleWare(to, from, afterEach2);
};

// src/agentRouter.ts
var normalAgent = () => {
  const addRouterListener = function() {
    window.addEventListener(__GARFISH_BEFORE_ROUTER_EVENT__, function(env) {
      RouterConfig.routerChange && RouterConfig.routerChange(location.pathname);
      linkTo(env.detail);
    });
  };
  if (!window[__GARFISH_ROUTER_FLAG__]) {
    const rewrite = function(type) {
      const hapi = history[type];
      return function() {
        const urlBefore = window.location.pathname + window.location.hash;
        const stateBefore = history == null ? void 0 : history.state;
        const res = hapi.apply(this, arguments);
        const urlAfter = window.location.pathname + window.location.hash;
        const stateAfter = history == null ? void 0 : history.state;
        const e = createEvent(type);
        e.arguments = arguments;
        if (urlBefore !== urlAfter || JSON.stringify(stateBefore) !== JSON.stringify(stateAfter)) {
          window.dispatchEvent(new customEvent_default(__GARFISH_BEFORE_ROUTER_EVENT__, {
            detail: {
              toRouterInfo: {
                fullPath: urlAfter,
                href: location.href,
                query: parseQuery(location.search),
                path: getPath(RouterConfig.basename, urlAfter),
                state: stateAfter
              },
              fromRouterInfo: {
                fullPath: urlBefore,
                query: RouterConfig.current.query,
                href: RouterConfig.current.href,
                path: getPath(RouterConfig.basename, urlBefore),
                state: stateBefore
              },
              eventType: type
            }
          }));
        }
        return res;
      };
    };
    history.pushState = rewrite("pushState");
    history.replaceState = rewrite("replaceState");
    window.addEventListener("popstate", function(event) {
      if (event && typeof event === "object" && event.garfish)
        return;
      if (history.state && typeof history.state === "object")
        delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];
      window.dispatchEvent(new customEvent_default(__GARFISH_BEFORE_ROUTER_EVENT__, {
        detail: {
          toRouterInfo: {
            fullPath: location.pathname,
            href: location.href,
            query: parseQuery(location.search),
            path: getPath(RouterConfig.basename)
          },
          fromRouterInfo: {
            fullPath: RouterConfig.current.fullPath,
            path: getPath(RouterConfig.basename, RouterConfig.current.path),
            href: RouterConfig.current.href,
            query: RouterConfig.current.query
          },
          eventType: "popstate"
        }
      }));
    }, false);
    window[__GARFISH_ROUTER_FLAG__] = true;
  }
  addRouterListener();
};
var initRedirect = () => {
  linkTo({
    toRouterInfo: {
      fullPath: location.pathname,
      href: location.href,
      path: getPath(RouterConfig.basename),
      query: parseQuery(location.search),
      state: history.state
    },
    fromRouterInfo: {
      fullPath: "/",
      href: "",
      path: "/",
      query: {},
      state: {}
    },
    eventType: "pushState"
  });
};
var listen = () => {
  normalAgent();
  initRedirect();
};

// src/context.ts
var beforeEach = (hook) => {
  set("beforeEach", hook);
};
var afterEach = (hook) => {
  set("afterEach", hook);
};
var routerChange = (hook) => {
  set("routerChange", hook);
};
var registerRouter = (Apps) => {
  const unregisterApps = Apps.filter((app) => !RouterConfig.apps.some((item) => app.name === item.name));
  set("apps", RouterConfig.apps.concat(unregisterApps));
};
var listenRouterAndReDirect = ({
  apps,
  basename = "/",
  autoRefreshApp,
  active,
  deactive,
  notMatch,
  listening = true
}) => {
  registerRouter(apps);
  setRouterConfig({
    basename,
    autoRefreshApp,
    active,
    deactive,
    notMatch,
    listening
  });
  listen();
};
var Router = {
  push,
  replace,
  beforeEach,
  afterEach,
  registerRouter,
  routerChange,
  listenRouterAndReDirect,
  setRouterConfig,
  routerConfig: RouterConfig
};
var context_default = Router;

// src/index.ts
function GarfishRouter(_args) {
  return function(Garfish) {
    Garfish.apps = {};
    Garfish.router = context_default;
    return {
      name: "router",
      version: "1.17.5",
      bootstrap(options) {
        let activeApp = null;
        const unmounts = {};
        const { basename } = options;
        const { autoRefreshApp = true, onNotMatchRouter = () => null } = Garfish.options;
        async function active(appInfo, rootPath = "/") {
          (0, import_utils4.routerLog)(`${appInfo.name} active`, {
            appInfo,
            rootPath,
            listening: RouterConfig.listening
          });
          if (!RouterConfig.listening)
            return;
          const { name, active: active2, cache = true } = appInfo;
          if (active2)
            return active2(appInfo, rootPath);
          appInfo.rootPath = rootPath;
          const currentApp = activeApp = (0, import_utils4.createKey)();
          const app = await Garfish.loadApp(appInfo.name, {
            cache,
            basename: rootPath,
            entry: appInfo.entry,
            domGetter: appInfo.domGetter
          });
          if (app) {
            app.appInfo.basename = rootPath;
            const call = async (app2, isRender) => {
              if (!app2)
                return;
              const isDes = cache && app2.mounted;
              if (isRender) {
                return await app2[isDes ? "show" : "mount"]();
              } else {
                return app2[isDes ? "hide" : "unmount"]();
              }
            };
            Garfish.apps[name] = app;
            unmounts[name] = () => {
              if (app.mounting) {
                delete Garfish.cacheApps[name];
              }
              call(app, false);
            };
            if (currentApp === activeApp) {
              await call(app, true);
            }
          }
        }
        async function deactive(appInfo, rootPath) {
          (0, import_utils4.routerLog)(`${appInfo.name} deactive`, {
            appInfo,
            rootPath
          });
          activeApp = null;
          const { name, deactive: deactive2 } = appInfo;
          if (deactive2)
            return deactive2(appInfo, rootPath);
          const unmount = unmounts[name];
          unmount && unmount();
          delete Garfish.apps[name];
          const needToDeleteApps = context_default.routerConfig.apps.filter((app) => {
            if (appInfo.rootPath === app.basename)
              return true;
          });
          if (needToDeleteApps.length > 0) {
            needToDeleteApps.forEach((app) => {
              delete Garfish.appInfos[app.name];
              delete Garfish.cacheApps[app.name];
            });
            context_default.setRouterConfig({
              apps: context_default.routerConfig.apps.filter((app) => {
                return !needToDeleteApps.some((needDelete) => app.name === needDelete.name);
              })
            });
          }
        }
        const apps = Object.values(Garfish.appInfos);
        const appList = apps.filter((app) => {
          if (!app.basename)
            app.basename = basename;
          return !!app.activeWhen;
        });
        const listenOptions = {
          basename,
          active,
          deactive,
          autoRefreshApp,
          notMatch: onNotMatchRouter,
          apps: appList,
          listening: true
        };
        (0, import_utils4.routerLog)("listenRouterAndReDirect", listenOptions);
        listenRouterAndReDirect(listenOptions);
      },
      registerApp(appInfos) {
        const appList = Object.values(appInfos);
        context_default.registerRouter(appList.filter((app) => !!app.activeWhen));
        if (!Garfish.running)
          return;
        (0, import_utils4.routerLog)("registerApp initRedirect", appInfos);
        initRedirect();
      }
    };
  };
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GarfishRouter
});
