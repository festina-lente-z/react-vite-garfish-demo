var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/garfish.ts
import { Loader as Loader2 } from "@garfish/loader";
import { EventEmitter2 } from "eventemitter2";
import { warn as warn5, assert as assert4, isPlainObject, __GARFISH_FLAG__ } from "@garfish/utils";
import {
  SyncHook as SyncHook2,
  AsyncHook as AsyncHook2,
  SyncWaterfallHook as SyncWaterfallHook2,
  AsyncWaterfallHook,
  PluginSystem as PluginSystem2
} from "@garfish/hooks";

// src/config.ts
import {
  error,
  deepMerge,
  filterUndefinedVal
} from "@garfish/utils";
var filterAppConfigKeys = {
  beforeBootstrap: true,
  bootstrap: true,
  beforeRegisterApp: true,
  registerApp: true,
  beforeLoad: true,
  afterLoad: true,
  errorLoadApp: true,
  appID: true,
  apps: true,
  disableStatistics: true,
  disablePreloadApp: true,
  plugins: true,
  autoRefreshApp: true,
  onNotMatchRouter: true,
  loader: true
};
var deepMergeConfig = (globalConfig, localConfig) => {
  const _a = globalConfig, { props: globalProps } = _a, newGlobalConfig = __objRest(_a, ["props"]);
  const _b = localConfig, { props: localProps } = _b, newLocalConfig = __objRest(_b, ["props"]);
  const props = __spreadValues(__spreadValues({}, globalProps || {}), localProps || {});
  const result = deepMerge(filterUndefinedVal(newGlobalConfig), filterUndefinedVal(newLocalConfig));
  return __spreadProps(__spreadValues({}, result), {
    props
  });
};
var getAppConfig = (globalConfig, localConfig) => {
  const mergeResult = deepMergeConfig(globalConfig, localConfig);
  Object.keys(mergeResult).forEach((key) => {
    if (filterAppConfigKeys[key]) {
      delete mergeResult[key];
    }
  });
  return mergeResult;
};
var generateAppOptions = (appName, garfish, options) => {
  let appInfo = garfish.appInfos[appName] || { name: appName };
  appInfo = getAppConfig(garfish.options, __spreadProps(__spreadValues(__spreadValues({}, appInfo), options), {
    props: __spreadValues(__spreadValues({}, appInfo.props || {}), (options == null ? void 0 : options.props) || {})
  }));
  return appInfo;
};
var createDefaultOptions = () => {
  const config = {
    appID: "",
    apps: [],
    autoRefreshApp: true,
    disableStatistics: false,
    disablePreloadApp: false,
    basename: "/",
    props: {},
    asyncProviderTimeout: 2e3,
    domGetter: () => document.createElement("div"),
    sandbox: {
      snapshot: false,
      fixBaseUrl: false,
      fixStaticResourceBaseUrl: true,
      disableWith: false,
      strictIsolation: false,
      disableElementtiming: false,
      fixOwnerDocument: false
    },
    beforeLoad: () => {
    },
    afterLoad: () => {
    },
    errorLoadApp: (e) => error(e),
    onNotMatchRouter: () => {
    },
    beforeEval: () => {
    },
    afterEval: () => {
    },
    beforeMount: () => {
    },
    afterMount: () => {
    },
    beforeUnmount: () => {
    },
    afterUnmount: () => {
    },
    errorMountApp: (e) => error(e),
    errorUnmountApp: (e) => error(e),
    customLoader: void 0
  };
  return config;
};

// src/module/app.ts
import {
  warn,
  assert as assert2,
  hasOwn,
  remove,
  Queue,
  coreLog,
  isJsType,
  isObject as isObject2,
  isPromise,
  isGarfishConfigType,
  toBoolean,
  findTarget,
  evalWithEnv,
  transformUrl as transformUrl2,
  __MockBody__,
  __MockHead__,
  getRenderNode,
  sourceListTags,
  createAppContainer,
  setDocCurrentScript,
  getSourceURL
} from "@garfish/utils";

// src/lifecycle.ts
import {
  SyncHook,
  SyncWaterfallHook,
  AsyncHook,
  PluginSystem
} from "@garfish/hooks";
function globalLifecycle() {
  return new PluginSystem({
    beforeBootstrap: new SyncHook(),
    bootstrap: new SyncHook(),
    beforeRegisterApp: new SyncHook(),
    registerApp: new SyncHook(),
    beforeLoad: new AsyncHook(),
    afterLoad: new AsyncHook(),
    errorLoadApp: new SyncHook()
  });
}
function appLifecycle() {
  return new PluginSystem({
    beforeEval: new SyncHook(),
    afterEval: new SyncHook(),
    beforeMount: new SyncHook(),
    afterMount: new SyncHook(),
    errorMountApp: new SyncHook(),
    beforeUnmount: new SyncHook(),
    afterUnmount: new SyncHook(),
    errorUnmountApp: new SyncHook(),
    errorExecCode: new SyncHook(),
    customRender: new SyncWaterfallHook("customRender")
  });
}

// src/module/esModule.ts
import { init, parse } from "@alioth-org/es-module-lexer";
import { Lock } from "@garfish/utils";
import {
  isAbsolute,
  transformUrl,
  haveSourcemap,
  createSourcemap
} from "@garfish/utils";
var __GARFISH_ESM_ENV__ = "__GARFISH_ESM_ENV__";
var getModuleImportProcessor = (code) => {
  let finalCode = "";
  let resetCode = code;
  let prevCodeIndex = 0;
  const rawImport = "import";
  const wrapImport = "_import_";
  return (importAnalysis, newModuleName = "") => {
    const { d: importType, n: moduleName, s, e, ss, se } = importAnalysis;
    const isDynamicImport = importType > -1;
    if (isDynamicImport) {
      const codeStart = ss - prevCodeIndex;
      const codeEnd = se - prevCodeIndex;
      const dynamicImportStatement = resetCode.slice(codeStart, codeEnd);
      finalCode += resetCode.slice(0, codeStart);
      finalCode += dynamicImportStatement.replace(rawImport, wrapImport);
      resetCode = resetCode.slice(codeEnd);
      prevCodeIndex = se;
    } else if (moduleName) {
      const codeStart = s - prevCodeIndex;
      const codeEnd = e - prevCodeIndex;
      finalCode += resetCode.slice(0, codeStart);
      finalCode += newModuleName;
      resetCode = resetCode.slice(codeEnd);
      prevCodeIndex = e;
    }
    return [finalCode, resetCode];
  };
};
var genShellExecutionCode = (id, sourceModuleName, shellUrl) => `;import*as m$$_${id} from'${sourceModuleName}';import{u$$_ as u$$_${id}}from'${shellUrl}';u$$_${id}(m$$_${id})`;
var ESModuleLoader = class {
  constructor(app) {
    this.moduleCache = {};
    this.lock = new Lock();
    this.app = app;
    this.globalVarKey = `${__GARFISH_ESM_ENV__}_${this.app.appId}`;
  }
  execModuleCode(blobUrl) {
    const result = (0, eval)(`import('${blobUrl}')`);
    this.lock.release();
    return result;
  }
  createBlobUrl(code) {
    return URL.createObjectURL(new Blob([code], { type: "text/javascript" }));
  }
  setBlobUrl(saveId, blobUrl) {
    this.moduleCache[saveId].blobUrl = blobUrl;
  }
  async fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, saveUrl, requestUrl) {
    const { resourceManager } = await this.app.context.loader.load({
      scope: this.app.name,
      url: requestUrl
    });
    if (resourceManager) {
      let sourcemap = "";
      let { url, scriptCode } = resourceManager;
      if (!haveSourcemap(scriptCode)) {
        sourcemap = await createSourcemap(scriptCode, requestUrl);
      }
      scriptCode = await this.analysisModule(lockId, scriptCode, envVarStr, noEntryEnvVarStr, saveUrl, url);
      const blobUrl = this.createBlobUrl(`import.meta.url='${url}';${this.app.isNoEntryScript(url) ? noEntryEnvVarStr : envVarStr}${scriptCode}
${sourcemap}`);
      this.setBlobUrl(saveUrl, blobUrl);
    }
  }
  getUrl(referUrl, targetUrl) {
    return !isAbsolute(targetUrl) && referUrl ? transformUrl(referUrl, targetUrl) : targetUrl;
  }
  preloadStaticModuleAsync(analysis, realUrl) {
    const [imports] = analysis;
    for (let i = 0, length = imports.length; i < length; i++) {
      const importAnalysis = imports[i];
      const { d: importType, n: moduleName } = importAnalysis;
      const isDynamicImport = importType > -1;
      if (moduleName && !isDynamicImport) {
        this.app.context.loader.load({
          scope: this.app.name,
          url: this.getUrl(realUrl, moduleName)
        });
      }
    }
  }
  async analysisModule(lockId, code, envVarStr, noEntryEnvVarStr, baseUrl, realUrl) {
    await this.lock.wait(lockId);
    await init();
    const analysis = parse(code, realUrl || "");
    const thisModule = {
      analysis,
      source: code
    };
    if (baseUrl) {
      this.moduleCache[baseUrl] = thisModule;
    }
    let result = ["", code];
    let shellExecutionCode = "";
    const dynamicImport = `var _import_=(url)=>window.${this.globalVarKey}.import(url,'${baseUrl}','${realUrl}');`;
    const processImportModule = getModuleImportProcessor(code);
    const [imports] = analysis;
    this.preloadStaticModuleAsync(analysis, realUrl);
    for (let i = 0, length = imports.length; i < length; i++) {
      const importAnalysis = imports[i];
      const { d: importType, n: moduleName } = importAnalysis;
      const isDynamicImport = importType > -1;
      let saveUrl = moduleName || "";
      let newModuleName = "";
      if (moduleName && !isDynamicImport) {
        const requestUrl = this.getUrl(realUrl, moduleName);
        saveUrl = this.getUrl(baseUrl, moduleName);
        let currentModule = this.moduleCache[saveUrl];
        if (currentModule && !currentModule.blobUrl) {
          if (!currentModule.shellUrl) {
            const [currentModuleImports, currentModuleExports] = currentModule.analysis;
            const wildcardExports = currentModuleImports.filter((importItem) => {
              const statement = currentModule.source.substring(importItem.ss, importItem.se);
              return /^export\s*\*\s*from\s*/.test(statement);
            });
            const wildcardExportStatements = [];
            for (let j = 0, l = wildcardExports.length; j < l; j++) {
              const wildcardExport = wildcardExports[j];
              const wildcardExportUrl = wildcardExport.n || "";
              const wildcardExportSaveUrl = this.getUrl(baseUrl, wildcardExportUrl);
              await this.fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, wildcardExportSaveUrl, this.getUrl(realUrl, wildcardExportUrl));
              const wildcardModule = this.moduleCache[wildcardExportSaveUrl];
              if (wildcardModule == null ? void 0 : wildcardModule.blobUrl) {
                wildcardExportStatements.push(`export * from '${wildcardModule.blobUrl}'`);
              }
            }
            currentModule.shellUrl = this.createBlobUrl(`export function u$$_(m){${currentModuleExports.map((exportSpecifier) => exportSpecifier.n === "default" ? "d$$_=m.default" : `${exportSpecifier.n}=m.${exportSpecifier.n}`).join(",")}}${currentModuleExports.map((exportSpecifier) => exportSpecifier.n === "default" ? "let d$$_;export{d$$_ as default}" : `export let ${exportSpecifier.n}`).join(";")}${wildcardExportStatements.length ? `;${wildcardExportStatements.join(";")}` : ""}
//# sourceURL=${saveUrl}?cycle`);
          }
          newModuleName = currentModule.shellUrl;
        } else if (!currentModule) {
          await this.fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, saveUrl, requestUrl);
          currentModule = this.moduleCache[saveUrl];
          const { blobUrl, shellUrl, shellExecuted } = currentModule;
          newModuleName = blobUrl;
          if (shellUrl && !shellExecuted) {
            shellExecutionCode += genShellExecutionCode(i, newModuleName, shellUrl);
            currentModule.shellExecuted = true;
          }
        } else {
          newModuleName = currentModule.blobUrl;
        }
      }
      result = processImportModule(importAnalysis, newModuleName || moduleName);
    }
    thisModule.source = "";
    delete thisModule.analysis;
    return `${dynamicImport}${shellExecutionCode};${result.join("")}`;
  }
  destroy() {
    for (const key in this.moduleCache) {
      const { blobUrl, shellUrl } = this.moduleCache[key];
      if (blobUrl) {
        URL.revokeObjectURL(blobUrl);
      }
      if (shellUrl) {
        URL.revokeObjectURL(shellUrl);
      }
    }
    this.moduleCache = {};
    this.lock.clear();
    delete this.app.global[this.globalVarKey];
  }
  load(code, env, url, options) {
    return new Promise(async (resolve) => {
      if (url && this.moduleCache[url]) {
        return resolve();
      }
      const genShellCodeWrapper = (blobUrl2, shellUrl, sourceUrl) => {
        return `export * from '${blobUrl2}'${genShellExecutionCode(0, blobUrl2, shellUrl)}
//# sourceURL=${sourceUrl}?cycle`;
      };
      env = __spreadProps(__spreadValues({}, env), {
        resolve,
        import: async (moduleId, baseUrl, realUrl) => {
          let saveUrl = moduleId;
          let requestUrl = moduleId;
          if (!isAbsolute(moduleId)) {
            saveUrl = transformUrl(baseUrl, moduleId);
            requestUrl = transformUrl(realUrl, moduleId);
          }
          let targetModule = this.moduleCache[saveUrl];
          if (!(targetModule == null ? void 0 : targetModule.blobUrl)) {
            await this.fetchModuleResource(this.lock.genId(), envVarStr, noEntryEnvVarStr, saveUrl, requestUrl);
            targetModule = this.moduleCache[saveUrl];
          }
          if (targetModule && targetModule.shellUrl && !targetModule.shellExecuted && targetModule.blobUrl) {
            return this.execModuleCode(this.createBlobUrl(genShellCodeWrapper(targetModule.blobUrl, targetModule.shellUrl, saveUrl)));
          }
          return this.execModuleCode(targetModule.blobUrl);
        }
      });
      const genEnvVarStr = (targetEnv, noEntry) => {
        const newEnv = __spreadValues({}, targetEnv);
        if (noEntry) {
          delete newEnv.exports;
          delete newEnv.module;
        }
        return Object.keys(newEnv).reduce((prevCode, name) => {
          if (name === "resolve" || name === "import")
            return prevCode;
          return `${prevCode} var ${name} = window.${this.globalVarKey}.${name};`;
        }, "");
      };
      const envVarStr = genEnvVarStr(env);
      const noEntryEnvVarStr = genEnvVarStr(env, true);
      let sourcemap = "";
      if (!haveSourcemap(code) && url) {
        sourcemap = await createSourcemap(code, options && options.isInline ? `index.html(inline.${this.app.scriptCount}.js)` : url);
      }
      code = await this.analysisModule(this.lock.genId(), code, envVarStr, noEntryEnvVarStr, url, url);
      code = `import.meta.url='${url}';${(options == null ? void 0 : options.noEntry) ? noEntryEnvVarStr : envVarStr}${code}
;window.${this.globalVarKey}.resolve();
${sourcemap}`;
      this.app.global[this.globalVarKey] = env;
      let blobUrl = this.createBlobUrl(code);
      if (options && !options.isInline && url) {
        this.setBlobUrl(url, blobUrl);
      }
      const currentModule = this.moduleCache[url || ""];
      if ((currentModule == null ? void 0 : currentModule.shellUrl) && !currentModule.shellExecuted) {
        blobUrl = this.createBlobUrl(genShellCodeWrapper(blobUrl, currentModule.shellUrl, url || ""));
      }
      this.execModuleCode(blobUrl);
    });
  }
};

// src/module/app.ts
var appId = 0;
var __GARFISH_GLOBAL_ENV__ = "__GARFISH_GLOBAL_ENV__";
var __GARFISH_EXPORTS__ = "__GARFISH_EXPORTS__";
var App = class {
  constructor(context, appInfo, entryManager, resources, isHtmlMode, customLoader) {
    this.appId = appId++;
    this.scriptCount = 0;
    this.display = false;
    this.mounted = false;
    this.mounting = false;
    this.strictIsolation = false;
    this.esmQueue = new Queue();
    this.esModuleLoader = new ESModuleLoader(this);
    this.global = window;
    this.customExports = {};
    this.sourceList = [];
    this.sourceListMap = /* @__PURE__ */ new Map();
    this.childGarfishConfig = {};
    this.active = false;
    this.unmounting = false;
    this.deferNodeMap = /* @__PURE__ */ new Map();
    var _a;
    this.context = context;
    this.appInfo = appInfo;
    this.name = appInfo.name;
    this.resources = resources;
    this.isHtmlMode = isHtmlMode;
    this.entryManager = entryManager;
    this.appInfo.appId = this.appId;
    this.globalEnvVariables = {
      currentApp: this,
      loader: context.loader,
      externals: context.externals,
      remoteModulesCode: resources.modules
    };
    this.cjsModules = {
      exports: {},
      module: null,
      require: (key) => {
        const pkg = this.global[key] || context.externals[key] || window[key];
        if (!pkg) {
          warn(`Package "${key}" is not found`);
        }
        return pkg;
      }
    };
    this.cjsModules.module = this.cjsModules;
    this.customLoader = customLoader;
    this.hooks = appLifecycle();
    this.hooks.usePlugin(__spreadProps(__spreadValues({}, appInfo), {
      name: `${appInfo.name}-lifecycle`
    }));
    const nodes = entryManager.getNodesByTagName(...sourceListTags);
    for (const key in nodes) {
      nodes[key].forEach((node) => {
        var _a2, _b;
        const url = entryManager.findAttributeValue(node, "href") || entryManager.findAttributeValue(node, "src");
        if (url) {
          this.addSourceList({
            tagName: node.tagName,
            url: entryManager.url ? transformUrl2(entryManager.url, url) : url
          });
        }
        if (isGarfishConfigType({
          type: entryManager.findAttributeValue(node, "type")
        })) {
          this.childGarfishConfig = JSON.parse((_b = (_a2 = node.children) == null ? void 0 : _a2[0]) == null ? void 0 : _b.content);
        }
      });
    }
    this.appInfo.entry && this.addSourceList({ tagName: "html", url: this.appInfo.entry });
    this.asyncProviderTimeout = (_a = this.appInfo.asyncProviderTimeout) != null ? _a : 0;
  }
  get rootElement() {
    return findTarget(this.htmlNode, [`div[${__MockBody__}]`, "body"]);
  }
  get getSourceList() {
    return this.sourceList;
  }
  addSourceList(sourceInfo) {
    if (this.appInfo.disableSourceListCollect)
      return;
    if (Array.isArray(sourceInfo)) {
      const nSourceList = sourceInfo.filter((item) => {
        const url = getSourceURL(item.url);
        if (!this.sourceListMap.has(url) && url.startsWith("http")) {
          this.sourceListMap.set(url, item);
          return true;
        }
        return false;
      });
      this.sourceList = this.sourceList.concat(nSourceList);
    } else {
      const url = getSourceURL(sourceInfo.url);
      if (!this.sourceListMap.get(url) && url.startsWith("http")) {
        this.sourceList.push(sourceInfo);
        this.sourceListMap.set(url, sourceInfo);
      }
    }
  }
  initAsyncProviderRegistration() {
    const { asyncProviderTimeout, customExports } = this;
    if (asyncProviderTimeout) {
      customExports.registerProvider = (provider) => {
        var _a;
        this.asyncProvider = provider;
        (_a = this.resolveAsyncProvider) == null ? void 0 : _a.call(this);
      };
    }
  }
  awaitAsyncProviderRegistration() {
    return new Promise((resolve) => {
      if (this.asyncProvider) {
        resolve(this.asyncProvider);
        return;
      }
      const timeoutId = setTimeout(() => {
        resolve(this.asyncProvider);
      }, this.asyncProviderTimeout);
      this.resolveAsyncProvider = () => {
        clearTimeout(timeoutId);
        resolve(this.asyncProvider);
      };
    });
  }
  getProvider() {
    return this.provider ? Promise.resolve(this.provider) : this.checkAndGetProvider();
  }
  isNoEntryScript(url = "") {
    var _a, _b;
    return (_b = (_a = this.childGarfishConfig.sandbox) == null ? void 0 : _a.noEntryScripts) == null ? void 0 : _b.some((item) => url.indexOf(item) > -1);
  }
  execScript(code, env, url, options) {
    env = __spreadValues(__spreadValues({}, this.getExecScriptEnv(options == null ? void 0 : options.noEntry)), env || {});
    this.scriptCount++;
    const args = [this.appInfo, code, env, url, options];
    this.hooks.lifecycle.beforeEval.emit(...args);
    try {
      this.runCode(code, env, url, options);
    } catch (err) {
      this.hooks.lifecycle.errorExecCode.emit(err, ...args);
      throw err;
    }
    this.hooks.lifecycle.afterEval.emit(...args);
  }
  runCode(code, env, url, options) {
    if (options && options.isModule) {
      this.esmQueue.add(async (next) => {
        await this.esModuleLoader.load(code, __spreadValues(__spreadValues({}, this.getExecScriptEnv()), env), url, options);
        next();
      });
    } else {
      const revertCurrentScript = setDocCurrentScript(this.global.document, code, true, url, options == null ? void 0 : options.async, options == null ? void 0 : options.defer, options == null ? void 0 : options.originScript);
      code += url ? `
//# sourceURL=${url}
` : "";
      if (!hasOwn(env, "window")) {
        env = __spreadProps(__spreadValues({}, env), {
          window: this.global
        });
      }
      evalWithEnv(`;${code}`, env, this.global);
      Promise.resolve().then(revertCurrentScript);
    }
  }
  async show() {
    this.active = true;
    const { display, mounted, provider } = this;
    if (display)
      return false;
    if (!mounted) {
      (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn('Need to call the "app.mount()" method first.');
      return false;
    }
    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, true);
    this.context.activeApps.push(this);
    await this.addContainer();
    this.callRender(provider, false);
    this.display = true;
    this.hooks.lifecycle.afterMount.emit(this.appInfo, this, true);
    return true;
  }
  hide() {
    this.active = false;
    this.mounting = false;
    const { display, mounted, provider } = this;
    if (!display)
      return false;
    if (!mounted) {
      (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn('Need to call the "app.mount()" method first.');
      return false;
    }
    this.hooks.lifecycle.beforeUnmount.emit(this.appInfo, this, true);
    this.callDestroy(provider, false);
    this.display = false;
    remove(this.context.activeApps, this);
    this.hooks.lifecycle.afterUnmount.emit(this.appInfo, this, true);
    return true;
  }
  async mount() {
    if (!this.canMount())
      return false;
    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, false);
    this.active = true;
    this.mounting = true;
    try {
      this.context.activeApps.push(this);
      this.initAsyncProviderRegistration();
      const { asyncScripts, deferScripts } = await this.compileAndRenderContainer();
      if (!this.stopMountAndClearEffect())
        return false;
      deferScripts();
      const provider = await this.getProvider();
      if (!this.stopMountAndClearEffect())
        return false;
      this.callRender(provider, true);
      this.display = true;
      this.mounted = true;
      this.hooks.lifecycle.afterMount.emit(this.appInfo, this, false);
      await asyncScripts;
      if (!this.stopMountAndClearEffect())
        return false;
    } catch (e) {
      this.entryManager.DOMApis.removeElement(this.appContainer);
      this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);
      return false;
    } finally {
      this.mounting = false;
    }
    return true;
  }
  unmount() {
    this.active = false;
    this.mounting = false;
    if (!this.mounted || !this.appContainer) {
      return false;
    }
    if (this.unmounting) {
      (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(`The ${this.name} app unmounting.`);
      return false;
    }
    this.unmounting = true;
    this.hooks.lifecycle.beforeUnmount.emit(this.appInfo, this, false);
    try {
      this.callDestroy(this.provider, true);
      this.display = false;
      this.mounted = false;
      this.provider = void 0;
      this.customExports = {};
      this.cjsModules.exports = {};
      this.esModuleLoader.destroy();
      remove(this.context.activeApps, this);
      this.hooks.lifecycle.afterUnmount.emit(this.appInfo, this, false);
    } catch (e) {
      remove(this.context.activeApps, this);
      this.entryManager.DOMApis.removeElement(this.appContainer);
      this.hooks.lifecycle.errorUnmountApp.emit(e, this.appInfo);
      return false;
    } finally {
      this.unmounting = false;
    }
    return true;
  }
  getExecScriptEnv(noEntry) {
    const envs = {
      [__GARFISH_EXPORTS__]: this.customExports,
      [__GARFISH_GLOBAL_ENV__]: this.globalEnvVariables
    };
    if (noEntry) {
      return __spreadProps(__spreadValues({}, envs), {
        require: this.cjsModules.require
      });
    }
    return __spreadValues(__spreadValues({}, envs), this.cjsModules);
  }
  async compileAndRenderContainer() {
    await this.renderTemplate();
    const execScript = (type) => {
      for (const jsManager of this.resources.js) {
        if (jsManager[type]) {
          try {
            let noEntry = false;
            const targetUrl = jsManager.url || this.appInfo.entry;
            if (type === "defer") {
              const node = this.deferNodeMap.get(jsManager);
              if (node) {
                noEntry = toBoolean(this.entryManager.findAttributeValue(node, "no-entry"));
              }
              if (!noEntry) {
                noEntry = toBoolean(this.isNoEntryScript(targetUrl));
              }
            }
            this.execScript(jsManager.scriptCode, {}, targetUrl, {
              noEntry,
              defer: type === "defer",
              async: type === "async",
              isModule: jsManager.isModule(),
              isInline: jsManager.isInlineScript()
            });
          } catch (e) {
            if (type !== "defer") {
              this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);
            } else {
              throw e;
            }
          }
        }
      }
    };
    return {
      deferScripts: () => execScript("defer"),
      asyncScripts: new Promise((resolve) => {
        setTimeout(() => {
          if (this.stopMountAndClearEffect()) {
            execScript("async");
          }
          resolve();
        });
      })
    };
  }
  canMount() {
    if (this.mounting) {
      (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(`The ${this.appInfo.name} app mounting.`);
      return false;
    }
    if (this.mounted) {
      (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(`The ${this.appInfo.name} app already mounted.`);
      return false;
    }
    if (this.unmounting) {
      (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(`The ${this.appInfo.name} app is unmounting can't Perform application rendering.`);
      return false;
    }
    return true;
  }
  stopMountAndClearEffect() {
    if (!this.active) {
      if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
        warn(`The app "${this.name}" rendering process has been blocked.`);
      }
      this.mounting = false;
      if (this.appContainer) {
        this.entryManager.DOMApis.removeElement(this.appContainer);
      }
      coreLog(`${this.appInfo.name} id:${this.appId} stopMountAndClearEffect`, this.appContainer);
      return false;
    }
    return true;
  }
  callRender(provider, isMount) {
    if (provider && provider.render) {
      provider.render({
        appName: this.appInfo.name,
        dom: this.rootElement,
        basename: this.appInfo.basename,
        appRenderInfo: { isMount },
        props: this.appInfo.props
      });
    }
  }
  callDestroy(provider, isUnmount) {
    const { rootElement, appContainer } = this;
    if (provider && provider.destroy) {
      provider.destroy({
        appName: this.appInfo.name,
        dom: rootElement,
        appRenderInfo: { isUnmount },
        props: this.appInfo.props
      });
    }
    this.entryManager.DOMApis.removeElement(appContainer);
  }
  async addContainer() {
    const wrapperNode = await getRenderNode(this.appInfo.domGetter);
    if (typeof wrapperNode.appendChild === "function") {
      wrapperNode.appendChild(this.appContainer);
    }
  }
  async renderTemplate() {
    const { appInfo, entryManager, resources } = this;
    const { url: baseUrl, DOMApis } = entryManager;
    const { htmlNode, appContainer } = createAppContainer(appInfo);
    const fixStaticResourceBaseUrl = !this.appInfo.sandbox || this.appInfo.sandbox && this.appInfo.sandbox.fixStaticResourceBaseUrl === true;
    this.htmlNode = htmlNode;
    this.appContainer = appContainer;
    await this.addContainer();
    const customRenderer = {
      meta: () => null,
      img: (node) => {
        fixStaticResourceBaseUrl && baseUrl && entryManager.toResolveUrl(node, "src", baseUrl);
        return DOMApis.createElement(node);
      },
      video: (node) => {
        fixStaticResourceBaseUrl && baseUrl && entryManager.toResolveUrl(node, "src", baseUrl);
        return DOMApis.createElement(node);
      },
      audio: (node) => {
        fixStaticResourceBaseUrl && baseUrl && entryManager.toResolveUrl(node, "src", baseUrl);
        return DOMApis.createElement(node);
      },
      iframe: (node) => {
        fixStaticResourceBaseUrl && baseUrl && entryManager.toResolveUrl(node, "src", baseUrl);
        return DOMApis.createElement(node);
      },
      body: (node) => {
        if (!this.strictIsolation) {
          node = entryManager.cloneNode(node);
          node.tagName = "div";
          node.attributes.push({
            key: __MockBody__,
            value: null
          });
        }
        return DOMApis.createElement(node);
      },
      head: (node) => {
        if (!this.strictIsolation) {
          node = entryManager.cloneNode(node);
          node.tagName = "div";
          node.attributes.push({
            key: __MockHead__,
            value: null
          });
        }
        return DOMApis.createElement(node);
      },
      script: (node) => {
        const mimeType = entryManager.findAttributeValue(node, "type");
        const isModule = mimeType === "module";
        if (mimeType) {
          if (!isModule && !isJsType({ type: mimeType })) {
            return DOMApis.createElement(node);
          }
        }
        const jsManager = resources.js.find((manager) => {
          return !manager.async ? manager.isSameOrigin(node) : false;
        });
        if (jsManager) {
          if (jsManager.defer) {
            this.deferNodeMap.set(jsManager, node);
          } else {
            const { url, scriptCode } = jsManager;
            const mockOriginScript = document.createElement("script");
            node.attributes.forEach((attribute) => {
              if (attribute.key) {
                mockOriginScript.setAttribute(attribute.key, attribute.value || "");
              }
            });
            const targetUrl = url || this.appInfo.entry;
            this.execScript(scriptCode, {}, targetUrl, {
              isModule,
              async: false,
              defer: false,
              isInline: jsManager.isInlineScript(),
              noEntry: toBoolean(entryManager.findAttributeValue(node, "no-entry")) || toBoolean(this.isNoEntryScript(targetUrl)),
              originScript: mockOriginScript
            });
          }
        } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          const async = entryManager.findAttributeValue(node, "async");
          if (typeof async === "undefined" || async === "false") {
            const tipInfo = JSON.stringify(node, null, 2);
            warn(`Current js node cannot be found, the resource may not exist.

 ${tipInfo}`);
          }
        }
        return DOMApis.createScriptCommentNode(node);
      },
      style: (node) => {
        const text = node.children[0];
        if (text) {
          const styleManager = new this.context.loader.StyleManager(text.content, baseUrl);
          styleManager.setScope({
            appName: this.name,
            rootElId: this.appContainer.id
          });
          baseUrl && styleManager.correctPath(baseUrl);
          return entryManager.ignoreChildNodesCreation(styleManager.renderAsStyleElement());
        }
        return DOMApis.createElement(node);
      },
      link: (node) => {
        if (DOMApis.isCssLinkNode(node)) {
          const styleManager = this.resources.link.find((manager) => manager.isSameOrigin(node));
          if (styleManager) {
            styleManager.setScope({
              appName: this.name,
              rootElId: this.appContainer.id
            });
            return styleManager.renderAsStyleElement((typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) ? `
/*${DOMApis.createLinkCommentNode(node)}*/
` : "");
          }
        }
        return DOMApis.isPrefetchJsLinkNode(node) ? DOMApis.createScriptCommentNode(node) : DOMApis.isIconLinkNode(node) ? null : DOMApis.createElement(node);
      }
    };
    entryManager.createElements(customRenderer, htmlNode, (node, parent) => {
      return this.hooks.lifecycle.customRender.emit({
        node,
        parent,
        app: this,
        customElement: null
      });
    });
  }
  async checkAndGetProvider() {
    const { appInfo, rootElement, cjsModules, customExports } = this;
    const { name, props, basename } = appInfo;
    let provider = void 0;
    await this.esmQueue.awaitCompletion();
    if (cjsModules.exports) {
      if (isPromise(cjsModules.exports))
        cjsModules.exports = await cjsModules.exports;
      if (cjsModules.exports.provider)
        provider = cjsModules.exports.provider;
    }
    if (customExports.provider) {
      provider = customExports.provider;
    }
    if (this.asyncProviderTimeout && !provider) {
      provider = await this.awaitAsyncProviderRegistration();
    }
    if (typeof provider === "function") {
      provider = await provider(__spreadValues({
        basename,
        dom: rootElement
      }, props || {}), props);
    } else if (isPromise(provider)) {
      provider = await provider;
    }
    if (!isObject2(provider) && typeof provider !== "function") {
      warn(` Invalid module content: ${name}, you should return both render and destroy functions in provider function.`);
    }
    const hookRes = await (this.customLoader && this.customLoader(provider, appInfo, basename));
    if (hookRes) {
      const { mount, unmount } = hookRes || {};
      if (typeof mount === "function" && typeof unmount === "function") {
        provider.render = mount;
        provider.destroy = unmount;
      }
    }
    if (!appInfo.noCheckProvider) {
      assert2(provider, `"provider" is "${provider}".`);
      assert2("render" in provider, '"render" is required in provider.');
      assert2("destroy" in provider, '"destroy" is required in provider.');
    }
    this.provider = provider;
    return provider;
  }
};

// src/module/resource.ts
import { warn as warn2, error as error2, transformUrl as transformUrl3, assert as assert3 } from "@garfish/utils";
function fetchStaticResources(appName, loader, entryManager) {
  const toBoolean2 = (val) => typeof val !== "undefined" && val !== "false";
  const jsNodes = Promise.all(entryManager.findAllJsNodes().map((node) => {
    const src = entryManager.findAttributeValue(node, "src");
    const type = entryManager.findAttributeValue(node, "type");
    let crossOrigin = entryManager.findAttributeValue(node, "crossorigin");
    if (crossOrigin === "") {
      crossOrigin = "anonymous";
    }
    if (src) {
      const fetchUrl = entryManager.url ? transformUrl3(entryManager.url, src) : src;
      const async = entryManager.findAttributeValue(node, "async");
      const defer = entryManager.findAttributeValue(node, "defer");
      return loader.load({
        scope: appName,
        url: fetchUrl,
        crossOrigin,
        defaultContentType: type
      }).then(({ resourceManager: jsManager }) => {
        if (jsManager) {
          jsManager.setDep(node);
          type && jsManager.setMimeType(type);
          jsManager.setAsyncAttribute(toBoolean2(async));
          jsManager.setDefferAttribute(toBoolean2(defer));
          return jsManager;
        } else {
          warn2(`[${appName}] Failed to load script: ${fetchUrl}`);
        }
      }).catch(() => null);
    } else if (node.children.length > 0) {
      const code = node.children[0].content;
      if (code) {
        const jsManager = new loader.JavaScriptManager(code, "");
        jsManager.setDep(node);
        type && jsManager.setMimeType(type);
        return jsManager;
      }
    }
  }).filter(Boolean));
  const linkNodes = Promise.all(entryManager.findAllLinkNodes().map((node) => {
    if (!entryManager.DOMApis.isCssLinkNode(node))
      return;
    const href = entryManager.findAttributeValue(node, "href");
    if (href) {
      const fetchUrl = entryManager.url ? transformUrl3(entryManager.url, href) : href;
      return loader.load({ scope: appName, url: fetchUrl }).then(({ resourceManager: styleManager }) => {
        if (styleManager) {
          styleManager.setDep(node);
          styleManager == null ? void 0 : styleManager.correctPath();
          return styleManager;
        } else {
          warn2(`${appName} Failed to load link: ${fetchUrl}`);
        }
      }).catch(() => null);
    }
  }).filter(Boolean));
  const metaNodes = Promise.all(entryManager.findAllMetaNodes().map((node) => {
    if (!entryManager.DOMApis.isRemoteModule(node))
      return;
    const async = entryManager.findAttributeValue(node, "async");
    const alias = entryManager.findAttributeValue(node, "alias");
    if (!toBoolean2(async)) {
      const src = entryManager.findAttributeValue(node, "src");
      if (src) {
        return loader.loadModule(src).then(({ resourceManager: moduleManager }) => {
          if (moduleManager && alias) {
            moduleManager && moduleManager.setAlias(alias);
          }
          return moduleManager;
        }).catch(() => null);
      }
    } else if (alias) {
      warn2(`Asynchronous loading module, the alias "${alias}" is invalid.`);
    }
  }).filter(Boolean));
  return Promise.all([jsNodes, linkNodes, metaNodes]).then((ls) => ls.map((ns) => ns.filter(Boolean)));
}
async function processAppResources(loader, appInfo) {
  let isHtmlMode = false, fakeEntryManager;
  const resources = { js: [], link: [], modules: [] };
  assert3(appInfo.entry, `[${appInfo.name}] Entry is not specified.`);
  const { resourceManager: entryManager } = await loader.load({
    scope: appInfo.name,
    url: transformUrl3(location.href, appInfo.entry)
  });
  if (entryManager instanceof loader.TemplateManager) {
    isHtmlMode = true;
    const [js, link, modules] = await fetchStaticResources(appInfo.name, loader, entryManager);
    resources.js = js;
    resources.link = link;
    resources.modules = modules;
  } else if (entryManager instanceof loader.JavaScriptManager) {
    isHtmlMode = false;
    const mockTemplateCode = `<script src="${entryManager.url}"><\/script>`;
    fakeEntryManager = new loader.TemplateManager(mockTemplateCode, entryManager.url);
    entryManager.setDep(fakeEntryManager.findAllJsNodes()[0]);
    resources.js = [entryManager];
  } else {
    error2(`Entrance wrong type of resource of "${appInfo.name}".`);
  }
  return [fakeEntryManager || entryManager, resources, isHtmlMode];
}

// src/plugins/fixHMR.ts
function GarfishHMRPlugin() {
  let hasInit = false;
  let isHotUpdate = false;
  return function(Garfish2) {
    return {
      name: "fix-hmr",
      version: "1.17.5",
      bootstrap() {
        if (hasInit)
          return;
        hasInit = true;
        let webpackHotUpdateName = "webpackHotUpdate";
        let webpackHotUpdate = window[webpackHotUpdateName];
        for (const i in window) {
          if (i.includes("webpackHotUpdate")) {
            webpackHotUpdateName = i;
            webpackHotUpdate = window[i];
          }
        }
        if (typeof webpackHotUpdate === "function") {
          window[webpackHotUpdateName] = function() {
            isHotUpdate = true;
            return webpackHotUpdate.apply(this, arguments);
          };
          const observer = new MutationObserver(() => {
            if (!isHotUpdate)
              return;
            isHotUpdate = false;
            Garfish2.activeApps.forEach((app) => {
              if (app.mounted) {
                setTimeout(() => {
                  app.display && app.hide();
                  app.show();
                });
              }
            });
          });
          observer.observe(document.documentElement, {
            subtree: true,
            childList: true,
            attributes: true
          });
        }
      }
    };
  };
}

// src/plugins/lifecycle.ts
function GarfishOptionsLife(options, name) {
  return function() {
    return __spreadValues({
      name,
      version: "1.17.5"
    }, options);
  };
}

// src/plugins/preload.ts
import {
  warn as warn3,
  Queue as Queue2,
  isAbsolute as isAbsolute2,
  transformUrl as transformUrl4,
  idleCallback,
  safeWrapper
} from "@garfish/utils";
import { TemplateManager } from "@garfish/loader";
var storageKey = "__garfishPreloadApp__";
var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
var requestQueue = new Queue2();
var isSlowNetwork = () => navigator.connection ? navigator.connection.saveData || /(2|3)g/.test(navigator.connection.effectiveType) : false;
var requestIdleCallback = typeof idleCallback !== "function" ? window.setTimeout : idleCallback;
function safeLoad({
  loader,
  appName,
  url,
  isModule,
  immediately,
  callback
}) {
  const generateSuccess = (next = () => {
  }) => ({ resourceManager }) => {
    callback && callback(resourceManager);
    setTimeout(next, 500);
  };
  const generateThrowWarn = (next = () => {
  }) => (e) => {
    if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
      warn3(e);
      warn3(`Preload failed. "${url}"`);
    }
    next();
  };
  const loadResource = (next = () => {
  }) => {
    const throwWarn = generateThrowWarn(next);
    const success = generateSuccess(next);
    try {
      if (isModule) {
        loader.loadModule(url).then(success, throwWarn);
      } else {
        loader.load({ scope: appName, url }).then(success, throwWarn);
      }
    } catch (e) {
      throwWarn(e);
      next();
    }
  };
  if (immediately) {
    loadResource();
  } else {
    requestQueue.add((next) => {
      requestIdleCallback(() => loadResource(next));
    });
  }
}
function loadAppResource(loader, info, immediately = false) {
  false;
  const fetchUrl = transformUrl4(location.href, info.entry);
  safeLoad({
    loader,
    appName: info.name,
    url: fetchUrl,
    isModule: false,
    immediately,
    callback: (manager) => {
      const loadStaticResource = () => {
        if (manager instanceof TemplateManager) {
          const baseUrl = manager.url;
          const jsNodes = manager.findAllJsNodes();
          const linkNodes = manager.findAllLinkNodes();
          const metaNodes = manager.findAllMetaNodes();
          if (jsNodes) {
            jsNodes.forEach((node) => {
              const src = manager.findAttributeValue(node, "src");
              src && safeLoad({
                loader,
                appName: info.name,
                url: baseUrl ? transformUrl4(baseUrl, src) : src,
                isModule: false,
                immediately
              });
            });
          }
          if (linkNodes) {
            linkNodes.forEach((node) => {
              if (manager.DOMApis.isCssLinkNode(node)) {
                const href = manager.findAttributeValue(node, "href");
                href && safeLoad({
                  loader,
                  appName: info.name,
                  url: baseUrl ? transformUrl4(baseUrl, href) : href,
                  isModule: false,
                  immediately
                });
              }
            });
          }
          if (metaNodes) {
            metaNodes.forEach((node) => {
              if (manager.DOMApis.isRemoteModule(node)) {
                const src = manager.findAttributeValue(node, "src");
                if (src && isAbsolute2(src)) {
                  safeLoad({
                    loader,
                    appName: info.name,
                    url: src,
                    isModule: true,
                    immediately
                  });
                } else {
                  warn3(`The loading of the remote module must be an absolute path. "${src}"`);
                }
              }
            });
          }
        }
      };
      if (immediately) {
        loadStaticResource();
      } else {
        requestIdleCallback(loadStaticResource);
      }
    }
  });
}
function getRanking() {
  const str = localStorage.getItem(storageKey);
  if (str) {
    const data = JSON.parse(str);
    return data.sort((a, b) => b.count - a.count);
  }
  return [];
}
function setRanking(appName) {
  const str = localStorage.getItem(storageKey);
  const newCurrent = { appName, count: 1 };
  if (!str) {
    safeWrapper(() => localStorage.setItem(storageKey, JSON.stringify([newCurrent])));
  } else {
    const data = JSON.parse(str);
    const current = data.find((app) => app.appName === appName);
    current ? current.count++ : data.push(newCurrent);
    safeWrapper(() => localStorage.setItem(storageKey, JSON.stringify(data)));
  }
}
var loadedMap = /* @__PURE__ */ Object.create(null);
function GarfishPreloadPlugin() {
  return function(Garfish2) {
    Garfish2.preloadApp = (appName) => {
      if (loadedMap[appName]) {
        return;
      }
      loadedMap[appName] = true;
      loadAppResource(Garfish2.loader, Garfish2.appInfos[appName], true);
    };
    return {
      name: "preload",
      version: "1.17.5",
      beforeLoad(appInfo) {
        if (Garfish2.options.disablePreloadApp) {
          return;
        }
        setRanking(appInfo.name);
      },
      registerApp(appInfos) {
        if (Garfish2.options.disablePreloadApp) {
          return;
        }
        setTimeout(() => {
          if (isMobile || isSlowNetwork())
            return;
          const ranking = getRanking();
          for (const { appName } of ranking) {
            if (appInfos[appName] && !loadedMap[appName]) {
              loadedMap[appName] = true;
              loadAppResource(Garfish2.loader, appInfos[appName]);
            }
          }
          for (const key in appInfos) {
            if (!loadedMap[key]) {
              loadAppResource(Garfish2.loader, appInfos[key]);
            }
          }
        }, false ? 0 : 5e3);
      }
    };
  };
}

// src/plugins/performance/subAppObserver.ts
import { getRenderNode as getRenderNode2, warn as warn4 } from "@garfish/utils";
var SubAppObserver = class {
  constructor(options) {
    this.observer = new MutationObserver(this._mutationObserverCallback.bind(this));
    this.subAppBeforeLoadTime = 0;
    this.subAppBeforeMountTime = 0;
    this.subAppStartPageShowTime = 0;
    this.subAppPageShowTime = 0;
    this.entry = "";
    this.observeTimer = 0;
    this.dataTimer = 0;
    this.domQuerySelector = options.subAppRootSelector;
    this.config = { attributes: true, childList: true, subtree: true };
    this.targetSubscriber = [];
    this.timeLag = options.domObserverMaxTime || 3e3;
    this.reportTimeLag = options.waitSubAppNotifyMaxTime || 1e4;
    this.isRecordFinish = false;
    this.cbEntryList = [];
    this.isStartShowFlag = true;
    this.isCallBackFinish = false;
    this.isSubAppNotifyFinish = false;
    this.finishAction = "";
    this.performanceData = {
      resourceLoadTime: 0,
      blankScreenTime: 0,
      firstScreenTime: 0,
      isFirstRender: true,
      entry: "",
      action: ""
    };
  }
  subscribePerformanceData(callback) {
    try {
      this.targetSubscriber.push(callback);
    } catch (e) {
      warn4(e);
    }
  }
  subscribePerformanceDataOnce(callback) {
    try {
      const wrapCallback = (performanceData) => {
        callback(performanceData);
        this.unsubscribePerformanceData(wrapCallback);
      };
      this.targetSubscriber.push(wrapCallback);
    } catch (e) {
      warn4(e);
    }
  }
  unsubscribePerformanceData(callback) {
    try {
      this.targetSubscriber = this.targetSubscriber.filter((sub) => sub === callback);
    } catch (e) {
      warn4(e);
    }
  }
  subAppBeforeLoad(entry) {
    this.entry = entry;
    this.isRecordFinish = false;
    this.isSubAppNotifyFinish = false;
    this.subAppBeforeLoadTime = performance.now();
    this.isCallBackFinish = false;
    this._handleSubscribeCallback(false);
  }
  subAppBeforeMount() {
    this.subAppBeforeMountTime = performance.now();
    this._subAppStartObserver();
  }
  subAppUnmount() {
    if (!this.isRecordFinish) {
      this._subAppEndObserver("subAppUnmount");
    }
    this._handleSubscribeCallback(true);
  }
  afterRenderNotify() {
    if (!this.isRecordFinish) {
      this._subAppEndObserver("SubAppRenderNotify");
    } else if (!this.isSubAppNotifyFinish) {
      this.isSubAppNotifyFinish = true;
      this.isRecordFinish = true;
      this.finishAction = "SubAppRenderNotify";
      this._subAppPerformanceDataHandle();
    }
  }
  _mutationObserverCallback() {
    if (this.isStartShowFlag) {
      this.subAppStartPageShowTime = performance.now();
      this.isStartShowFlag = false;
    }
    clearTimeout(this.observeTimer);
    this.observeTimer = setTimeout(() => {
      clearTimeout(this.observeTimer);
      if (!this.isRecordFinish) {
        this._subAppEndObserver("MutationObserver");
      }
    }, this.timeLag);
  }
  _subAppEndObserver(finishAction) {
    this.isRecordFinish = true;
    this.finishAction = finishAction;
    this.subAppPageShowTime = performance.now();
    this.observer.disconnect();
    this._subAppPerformanceDataHandle();
    this.isStartShowFlag = true;
  }
  async _subAppStartObserver() {
    try {
      const targetNode = await getRenderNode2(this.domQuerySelector);
      this.observer.observe(targetNode, this.config);
      this._subAppClickEventObserver(targetNode);
    } catch (e) {
      warn4(e);
    }
  }
  _subAppPerformanceDataHandle() {
    const timeDifference = this.finishAction === "MutationObserver" ? this.timeLag : 0;
    this.performanceData = {
      resourceLoadTime: this.subAppBeforeMountTime - this.subAppBeforeLoadTime,
      blankScreenTime: this.subAppStartPageShowTime - this.subAppBeforeLoadTime,
      firstScreenTime: this.subAppPageShowTime - this.subAppBeforeLoadTime - timeDifference,
      isFirstRender: this.cbEntryList.indexOf(this.entry) === -1,
      entry: this.entry,
      action: this.finishAction
    };
  }
  _subAppClickEventObserver(targetNode) {
    const eventCallback = () => {
      clearTimeout(this.observeTimer);
      if (!this.isRecordFinish) {
        this._subAppEndObserver("UserEvent");
      }
    };
    targetNode.addEventListener("click", eventCallback);
    targetNode.addEventListener("keyup", eventCallback);
    targetNode.addEventListener("keydown", eventCallback);
    targetNode.addEventListener("keypress", eventCallback);
  }
  _handleCallback() {
    try {
      this.isCallBackFinish = true;
      this.targetSubscriber.forEach((callback) => {
        const {
          firstScreenTime,
          blankScreenTime,
          resourceLoadTime,
          action,
          entry
        } = this.performanceData;
        if (firstScreenTime > 0 && blankScreenTime > 0 && resourceLoadTime > 0 && action && entry) {
          if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
            console.warn("SUCCESS: ", this.performanceData);
          }
          this.cbEntryList.push(this.entry);
          callback(this.performanceData);
        } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          console.warn("ERROR: ", this.performanceData);
        }
      });
    } catch (e) {
      warn4(e);
    }
  }
  _handleSubscribeCallback(isImmediately) {
    try {
      clearTimeout(this.dataTimer);
      if (isImmediately && !this.isCallBackFinish) {
        this._handleCallback();
      } else {
        this.dataTimer = setTimeout(() => {
          this._handleCallback();
        }, this.reportTimeLag);
      }
    } catch (e) {
      warn4(e);
    }
  }
};

// src/plugins/performance/index.ts
function GarfishPerformance() {
  return function() {
    const subAppMap = {};
    return {
      name: "performance",
      beforeLoad(appInfo) {
        if (!subAppMap[appInfo.name] && appInfo.domGetter) {
          subAppMap[appInfo.name] = new SubAppObserver({
            subAppRootSelector: appInfo.domGetter
          });
        }
        subAppMap[appInfo.name].subAppBeforeLoad(appInfo.entry);
      },
      afterLoad(appInfo, appInstance) {
        if (appInstance) {
          appInstance.appPerformance = subAppMap[appInfo.name];
        }
      },
      beforeMount(appInfo) {
        subAppMap[appInfo.name].subAppBeforeMount(appInfo.entry);
      },
      beforeUnmount(appInfo) {
        subAppMap[appInfo.name].subAppUnmount(appInfo.entry);
      }
    };
  };
}

// src/plugins/logger.ts
import { coreLog as coreLog2 } from "@garfish/utils";
function GarfishLogger() {
  return function() {
    return {
      name: "garfish-logger",
      version: "1.17.5",
      beforeLoad(appInfo, ...args) {
        coreLog2(`${appInfo.name} beforeLoad`, [appInfo, ...args]);
      },
      afterLoad(appInfo, appInstance, ...args) {
        if (appInstance) {
          coreLog2(`${appInfo.name} id: ${appInstance.appId} afterLoad`, [
            appInfo,
            ...args
          ]);
        }
      },
      beforeMount(appInfo, appInstance, ...args) {
        coreLog2(`${appInfo.name} id: ${appInstance.appId} beforeMount`, [
          appInfo,
          ...args
        ]);
      },
      afterMount(appInfo, appInstance, ...args) {
        coreLog2(`${appInfo.name} id: ${appInstance.appId} afterMount`, [
          appInfo,
          ...args
        ]);
      },
      beforeUnmount(appInfo, appInstance, ...args) {
        coreLog2(`${appInfo.name} id: ${appInstance.appId} beforeUnmount`, [
          appInfo,
          ...args
        ]);
      },
      afterUnmount(appInfo, appInstance, ...args) {
        coreLog2(`${appInfo.name} id: ${appInstance.appId} afterUnmount`, [
          appInfo,
          ...args
        ]);
      }
    };
  };
}

// src/garfish.ts
var DEFAULT_PROPS = /* @__PURE__ */ new WeakMap();
var HOOKS_API = {
  SyncHook: SyncHook2,
  AsyncHook: AsyncHook2,
  SyncWaterfallHook: SyncWaterfallHook2,
  AsyncWaterfallHook
};
var Garfish = class extends EventEmitter2 {
  constructor(options) {
    super();
    this.running = false;
    this.version = "1.17.5";
    this.flag = __GARFISH_FLAG__;
    this.loader = new Loader2();
    this.hooks = globalLifecycle();
    this.channel = new EventEmitter2();
    this.options = createDefaultOptions();
    this.externals = {};
    this.activeApps = [];
    this.plugins = {};
    this.cacheApps = {};
    this.appInfos = {};
    this.loading = {};
    var _a;
    this.setOptions(options);
    DEFAULT_PROPS.set(this, {});
    (_a = this.options.plugins) == null ? void 0 : _a.forEach((plugin) => this.usePlugin(plugin));
    this.usePlugin(GarfishHMRPlugin());
    this.usePlugin(GarfishPerformance());
    this.usePlugin(GarfishPreloadPlugin());
    this.usePlugin(GarfishLogger());
  }
  get props() {
    return this.options && this.options.props || DEFAULT_PROPS.get(this);
  }
  setOptions(options) {
    assert4(!this.running, "Garfish is running, can`t set options");
    if (isPlainObject(options)) {
      this.options = deepMergeConfig(this.options, options);
    }
    return this;
  }
  createPluginSystem(callback) {
    const hooks = callback(HOOKS_API);
    return new PluginSystem2(hooks);
  }
  usePlugin(plugin, ...args) {
    assert4(!this.running, "Cannot register plugin after Garfish is started.");
    assert4(typeof plugin === "function", "Plugin must be a function.");
    args.unshift(this);
    const pluginConfig = plugin.apply(null, args);
    assert4(pluginConfig.name, "The plugin must have a name.");
    if (!this.plugins[pluginConfig.name]) {
      this.plugins[pluginConfig.name] = pluginConfig;
      this.hooks.usePlugin(pluginConfig);
    } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
      warn5("Please do not register the plugin repeatedly.");
    }
    return this;
  }
  run(options = {}) {
    var _a;
    if (this.running) {
      if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
        warn5("Garfish is already running now, Cannot run Garfish repeatedly.");
      }
      return this;
    }
    this.setOptions(options);
    (_a = options.plugins) == null ? void 0 : _a.forEach((plugin) => this.usePlugin(plugin));
    this.usePlugin(GarfishOptionsLife(this.options, "global-lifecycle"));
    this.hooks.lifecycle.beforeBootstrap.emit(this.options);
    this.registerApp(this.options.apps || []);
    this.running = true;
    this.hooks.lifecycle.bootstrap.emit(this.options);
    return this;
  }
  registerApp(list) {
    const currentAdds = {};
    this.hooks.lifecycle.beforeRegisterApp.emit(list);
    if (!Array.isArray(list))
      list = [list];
    for (const appInfo of list) {
      assert4(appInfo.name, "Miss app.name.");
      if (!this.appInfos[appInfo.name]) {
        assert4(appInfo.entry, `${appInfo.name} application entry is not url: ${appInfo.entry}`);
        currentAdds[appInfo.name] = appInfo;
        this.appInfos[appInfo.name] = appInfo;
      } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
        warn5(`The "${appInfo.name}" app is already registered.`);
      }
    }
    this.hooks.lifecycle.registerApp.emit(currentAdds);
    return this;
  }
  setExternal(nameOrExtObj, value) {
    assert4(nameOrExtObj, "Invalid parameter.");
    if (typeof nameOrExtObj === "object") {
      for (const key in nameOrExtObj) {
        if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          this.externals[key] && warn5(`The "${key}" will be overwritten in external.`);
        }
        this.externals[key] = nameOrExtObj[key];
      }
    } else {
      this.externals[nameOrExtObj] = value;
    }
    return this;
  }
  loadApp(appName, options) {
    assert4(appName, "Miss appName.");
    let appInfo = generateAppOptions(appName, this, options);
    const asyncLoadProcess = async () => {
      const stop = await this.hooks.lifecycle.beforeLoad.emit(appInfo);
      if (stop === false) {
        warn5(`Load ${appName} application is terminated by beforeLoad.`);
        return null;
      }
      appInfo = generateAppOptions(appName, this, appInfo);
      assert4(appInfo.entry, `Can't load unexpected child app "${appName}", Please provide the entry parameters or registered in advance of the app.`);
      let appInstance = null;
      const cacheApp = this.cacheApps[appName];
      if (appInfo.cache && cacheApp) {
        appInstance = cacheApp;
      } else {
        try {
          const [manager, resources, isHtmlMode] = await processAppResources(this.loader, appInfo);
          appInstance = new App(this, appInfo, manager, resources, isHtmlMode, appInfo.customLoader);
          for (const key in this.plugins) {
            appInstance.hooks.usePlugin(this.plugins[key]);
          }
          if (appInfo.cache) {
            this.cacheApps[appName] = appInstance;
          }
        } catch (e) {
          (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn5(e);
          this.hooks.lifecycle.errorLoadApp.emit(e, appInfo);
        }
      }
      await this.hooks.lifecycle.afterLoad.emit(appInfo, appInstance);
      return appInstance;
    };
    if (!this.loading[appName]) {
      this.loading[appName] = asyncLoadProcess().finally(() => {
        delete this.loading[appName];
      });
    }
    return this.loading[appName];
  }
};
export {
  Garfish as default
};
