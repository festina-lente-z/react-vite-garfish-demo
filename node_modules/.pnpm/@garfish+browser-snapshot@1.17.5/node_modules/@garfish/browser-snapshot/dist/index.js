var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  GarfishBrowserSnapshot: () => GarfishBrowserSnapshot,
  default: () => Sandbox
});

// src/patchers/event.ts
var rawAddEventListener;
var rawRemoveEventListener;
var PatchEvent = class {
  constructor() {
    this.listenerMap = /* @__PURE__ */ new Map();
  }
  activate() {
    this.listenerMap.forEach((listeners, type) => [...listeners].forEach((listener) => window.addEventListener(type, listener)));
    if (!rawAddEventListener || !rawRemoveEventListener) {
      rawAddEventListener = window.addEventListener;
      rawRemoveEventListener = window.removeEventListener;
    }
    window.addEventListener = (type, listener, options) => {
      const listeners = this.listenerMap.get(type) || [];
      this.listenerMap.set(type, [...listeners, listener]);
      return rawAddEventListener.call(window, type, listener, options);
    };
    window.removeEventListener = (type, listener, options) => {
      const storedTypeListeners = this.listenerMap.get(type);
      if (storedTypeListeners && storedTypeListeners.length && storedTypeListeners.indexOf(listener) !== -1) {
        storedTypeListeners.splice(storedTypeListeners.indexOf(listener), 1);
      }
      return rawRemoveEventListener.call(window, type, listener, options);
    };
  }
  deactivate() {
    this.listenerMap.forEach((listeners, type) => [...listeners].forEach((listener) => window.removeEventListener(type, listener)));
    window.removeEventListener = rawRemoveEventListener;
    window.addEventListener = rawAddEventListener;
  }
};

// src/patchers/interceptor.ts
function isStyledComponentsLike(element) {
  var _a;
  return element instanceof HTMLStyleElement && !element.textContent && ((_a = element.sheet) == null ? void 0 : _a.cssRules.length);
}
var Snapshot = class {
  constructor(arrDoms) {
    this.arrDoms = arrDoms;
    this.arrDoms = arrDoms;
  }
  static take(target = document.head) {
    let list;
    if (target.childNodes) {
      list = Array.prototype.slice.call(target.childNodes);
    } else {
      list = Array.prototype.slice.call(target);
    }
    return new Snapshot(list);
  }
  diff(s) {
    if (!s) {
      return {
        created: new Snapshot([]),
        removed: new Snapshot([])
      };
    }
    return {
      created: new Snapshot(this.arrDoms.filter((d) => s.arrDoms.indexOf(d) === -1)),
      removed: new Snapshot(s.arrDoms.filter((d) => this.arrDoms.indexOf(d) === -1))
    };
  }
};
var Interceptor = class {
  constructor(dom = document.head) {
    this.dom = dom;
    this.dom = dom;
    this.dynamicStyleSheetElementSet = /* @__PURE__ */ new Set();
    this.styledComponentCSSRulesMap = /* @__PURE__ */ new WeakMap();
  }
  add(createdOrSnapshot, removed) {
    let created;
    if (!removed) {
      const diff = Snapshot.take(this.dom).diff(createdOrSnapshot);
      created = diff.created;
      removed = diff.removed;
    } else {
      created = createdOrSnapshot;
    }
    created.arrDoms.reduce((prev, val) => {
      var _a, _b;
      prev.appendChild(val);
      if (val instanceof HTMLStyleElement) {
        const cssRules = this.styledComponentCSSRulesMap.get(val);
        if (cssRules && cssRules.length) {
          for (let i = 0; i < cssRules.length; i++) {
            const cssRule = cssRules[i];
            (_b = val.sheet) == null ? void 0 : _b.insertRule(cssRule.cssText, (_a = val.sheet) == null ? void 0 : _a.cssRules.length);
          }
        }
      }
      return prev;
    }, this.dom);
    removed.arrDoms.reduce((prev, val) => {
      prev.removeChild(val);
      return prev;
    }, this.dom);
  }
  remove(createdOrSnapshot, removed) {
    let created;
    if (!removed) {
      const diff = Snapshot.take(this.dom).diff(createdOrSnapshot);
      created = diff.created;
      removed = diff.removed;
    } else {
      created = createdOrSnapshot;
    }
    created.arrDoms.reduce((prev, val) => {
      var _a;
      if (val instanceof HTMLStyleElement && isStyledComponentsLike(val) && ((_a = val == null ? void 0 : val.sheet) == null ? void 0 : _a.cssRules)) {
        this.styledComponentCSSRulesMap.set(val, val.sheet.cssRules);
      }
      prev.removeChild(val);
      return prev;
    }, this.dom);
    removed.arrDoms.reduce((prev, val) => {
      prev.appendChild(val);
      return prev;
    }, this.dom);
  }
};

// src/patchers/style.ts
var PatchStyle = class {
  constructor() {
    this.headInterceptor = new Interceptor(document.head);
  }
  activate() {
    this.domSnapshotBefore = Snapshot.take();
    if (this.domSnapshotMutated)
      this.headInterceptor.add(this.domSnapshotMutated.created, this.domSnapshotMutated.removed);
  }
  deactivate() {
    const domSnapshot = Snapshot.take();
    this.domSnapshotMutated = domSnapshot.diff(this.domSnapshotBefore);
    if (!this.domSnapshotMutated)
      return;
    this.headInterceptor.remove(this.domSnapshotMutated.created, this.domSnapshotMutated.removed);
  }
  formateCtx(arrDoms) {
    const effectMap = {
      style: [],
      script: [],
      other: []
    };
    arrDoms.forEach((dom) => {
      let type = "other";
      if (/css/.test(dom.type))
        type = "style";
      if (/javascript/.test(dom.type))
        type = "script";
      effectMap[type].push({
        src: dom.src,
        outerHTML: dom.outerHTML,
        content: dom.innerText
      });
    });
    return effectMap;
  }
};

// src/patchers/history.ts
var rawPushState;
var rawReplaceState;
var PatchHistory = class {
  activate() {
    if (!rawPushState || !rawReplaceState) {
      rawPushState = window.history.pushState;
      rawReplaceState = window.history.replaceState;
    }
  }
  deactivate() {
    window.history.pushState = rawPushState;
    window.history.replaceState = rawReplaceState;
  }
};

// src/patchers/interval.ts
var rawInterval = window.setInterval;
var rawClearInterval = window.clearInterval;
var PatchInterval = class {
  constructor() {
    this.intervals = [];
  }
  activate() {
    window.setInterval = (handler, timeout, ...args) => {
      const intervalId = rawInterval(handler, timeout, ...args);
      this.intervals = [...this.intervals, intervalId];
      return intervalId;
    };
    window.clearInterval = (intervalId) => {
      this.intervals = this.intervals.filter((id) => id !== intervalId);
      return rawClearInterval(intervalId);
    };
  }
  deactivate(_clearEffects) {
    if (_clearEffects) {
      this.intervals.forEach((id) => window.clearInterval(id));
    }
    window.setInterval = rawInterval;
    window.clearInterval = rawClearInterval;
  }
};

// src/patchers/variable.ts
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
var PatchGlobalVal = class {
  constructor(targetToProtect = typeof window !== "undefined" ? window : globalThis, protectVariable = []) {
    this.targetToProtect = targetToProtect;
    this.protectVariable = protectVariable;
    this.snapshotOriginal = /* @__PURE__ */ new Map();
    this.snapshotMutated = /* @__PURE__ */ new Map();
    this.whiteList = [
      "location",
      "addEventListener",
      "removeEventListener",
      "webpackJsonp"
    ];
    this.targetToProtect = targetToProtect;
    this.protectVariable = protectVariable;
    this.whiteList = [...this.whiteList, ...protectVariable];
  }
  safeIterator(fn) {
    for (const i in this.targetToProtect) {
      if (this.whiteList.indexOf(i) !== -1) {
        continue;
      }
      const prop = Object.getOwnPropertyDescriptor(this.targetToProtect, i);
      if (!prop || !prop.writable) {
        continue;
      }
      if (hasOwn(this.targetToProtect, i)) {
        fn(i);
      }
    }
  }
  activate() {
    this.safeIterator((i) => {
      this.snapshotOriginal.set(i, this.targetToProtect[i]);
    });
    this.snapshotMutated.forEach((val, mutateKey) => {
      this.targetToProtect[mutateKey] = this.snapshotMutated.get(mutateKey);
    });
  }
  deactivate() {
    const deleteMap = {};
    const updateMap = {};
    const addMap = {};
    this.safeIterator((normalKey) => {
      if (this.snapshotOriginal.get(normalKey) !== this.targetToProtect[normalKey]) {
        this.snapshotMutated.set(normalKey, this.targetToProtect[normalKey]);
        this.targetToProtect[normalKey] = this.snapshotOriginal.get(normalKey);
        if (this.targetToProtect[normalKey] === void 0) {
          addMap[normalKey] = this.snapshotMutated.get(normalKey);
        } else {
          updateMap[normalKey] = this.snapshotMutated.get(normalKey);
        }
      }
      this.snapshotOriginal.delete(normalKey);
    });
    this.snapshotOriginal.forEach((val, deleteKey) => {
      this.snapshotMutated.set(deleteKey, this.targetToProtect[deleteKey]);
      this.targetToProtect[deleteKey] = this.snapshotOriginal.get(deleteKey);
      deleteMap[deleteKey] = this.targetToProtect[deleteKey];
    });
  }
};

// src/patchers/webpackjsonp.ts
var PatchWebpackJsonp = class {
  activate() {
    this.preWebpackJsonp = window.webpackJsonp;
    window.webpackJsonp = this.currentWebpackJsonp;
  }
  deactivate() {
    this.currentWebpackJsonp = window.webpackJsonp;
    window.webpackJsonp = this.preWebpackJsonp;
  }
};

// src/sandbox.ts
var Sandbox = class {
  constructor(name, protectVariable = [], targetToProtect = typeof window !== "undefined" ? window : globalThis, isInBrowser = typeof window === "undefined" ? false : true) {
    this.name = name;
    this.protectVariable = protectVariable;
    this.targetToProtect = targetToProtect;
    this.isInBrowser = isInBrowser;
    this.type = "snapshot";
    this.isRunning = false;
    this.patchList = [];
    this.name = name;
    this.isInBrowser = isInBrowser;
    this.patchList.push(new PatchGlobalVal(targetToProtect, protectVariable));
    if (this.isInBrowser) {
      this.patchList = [
        ...this.patchList,
        new PatchStyle(),
        new PatchEvent(),
        new PatchHistory(),
        new PatchInterval(),
        new PatchWebpackJsonp()
      ];
    }
  }
  activate() {
    if (this.isRunning)
      return;
    this.patchList.forEach((patch) => {
      patch.activate();
    });
    this.isRunning = true;
  }
  deactivate(clearEffects = true) {
    if (!this.isRunning)
      return;
    [...this.patchList].reverse().forEach((patch) => {
      patch.deactivate(clearEffects);
    });
    this.isRunning = false;
  }
};

// src/index.ts
function GarfishBrowserSnapshot(op) {
  return function(Garfish) {
    const options = {
      openBrowser: false,
      version: "1.17.5",
      name: "browser-snapshot",
      afterLoad(appInfo, appInstance) {
        var _a;
        const config = op || { open: true };
        const sandboxConfig = appInfo.sandbox || ((_a = Garfish == null ? void 0 : Garfish.options) == null ? void 0 : _a.sandbox);
        if (sandboxConfig === false || sandboxConfig.open === false || (sandboxConfig == null ? void 0 : sandboxConfig.snapshot) === false) {
          config.open = false;
        }
        if (sandboxConfig) {
          config.protectVariable = [
            ...(Garfish == null ? void 0 : Garfish.options.protectVariable) || [],
            ...appInfo.protectVariable || []
          ];
        }
        options.openBrowser = !!config.open;
        if (!config.open)
          return;
        if (appInstance) {
          if (appInstance.snapshotSandbox)
            return;
          const sandbox = new Sandbox(appInfo.name, config.protectVariable);
          appInstance.snapshotSandbox = sandbox;
        }
      },
      beforeMount(appInfo, appInstance) {
        if (!appInstance.snapshotSandbox)
          return;
        appInstance.snapshotSandbox.activate();
      },
      afterUnmount(appInfo, appInstance) {
        if (!appInstance.snapshotSandbox)
          return;
        appInstance.snapshotSandbox.deactivate();
      }
    };
    return options;
  };
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GarfishBrowserSnapshot
});
