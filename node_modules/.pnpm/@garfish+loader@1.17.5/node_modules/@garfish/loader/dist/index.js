var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CrossOriginCredentials: () => CrossOriginCredentials,
  JavaScriptManager: () => JavaScriptManager,
  Loader: () => Loader,
  ModuleManager: () => ModuleManager,
  StyleManager: () => StyleManager,
  TemplateManager: () => TemplateManager
});
var import_hooks = require("@garfish/hooks");
var import_utils4 = require("@garfish/utils");

// src/managers/style.ts
var import_utils = require("@garfish/utils");
var MATCH_CSS_URL = /url\(\s*(['"])?(.*?)\1\s*\)/g;
var MATCH_CHARSET_URL = /@charset\s+(['"])(.*?)\1\s*;?/g;
var MATCH_IMPORT_URL = /@import\s+(['"])(.*?)\1/g;
var StyleManager = class {
  constructor(styleCode, url) {
    this.depsStack = /* @__PURE__ */ new Set();
    this.scopeData = null;
    this.url = url || null;
    this.styleCode = styleCode;
  }
  correctPath(baseUrl) {
    const { url, styleCode } = this;
    if (!baseUrl)
      baseUrl = url;
    if (baseUrl && typeof styleCode === "string") {
      this.styleCode = styleCode.replace(MATCH_CHARSET_URL, "").replace(MATCH_IMPORT_URL, function(k0, k1, k2) {
        return k2 ? `@import url(${k1}${k2}${k1})` : k0;
      }).replace(MATCH_CSS_URL, (k0, k1, k2) => {
        if ((0, import_utils.isAbsolute)(k2))
          return k0;
        return `url("${baseUrl ? (0, import_utils.transformUrl)(baseUrl, k2) : k2}")`;
      });
    }
  }
  transformCode(code) {
    return code;
  }
  setDep(node) {
    this.depsStack.add(node);
  }
  setScope(data) {
    this.scopeData = data;
  }
  isSameOrigin(node) {
    return this.depsStack.has(node);
  }
  renderAsStyleElement(extraCode = "") {
    const node = document.createElement("style");
    const code = extraCode + (this.styleCode ? this.styleCode : "/**empty style**/");
    node.setAttribute("type", "text/css");
    node.textContent = this.transformCode(code);
    return node;
  }
  clone() {
    const cloned = new this.constructor();
    cloned.url = this.url;
    cloned.styleCode = this.styleCode;
    cloned.scopeData = this.scopeData;
    cloned.depsStack = new Set(this.depsStack);
    return cloned;
  }
};

// src/managers/module.ts
var ModuleManager = class {
  constructor(moduleCode, url) {
    this.alias = null;
    this.url = url || null;
    this.moduleCode = moduleCode;
  }
  setAlias(name) {
    if (name && typeof name === "string") {
      this.alias = name;
    }
  }
  clone() {
    const cloned = new this.constructor();
    cloned.url = this.url;
    cloned.alias = this.alias;
    cloned.moduleCode = this.moduleCode;
    return cloned;
  }
};

// src/managers/template.ts
var import_utils2 = require("@garfish/utils");
var TemplateManager = class {
  constructor(template, url) {
    this.DOMApis = new import_utils2.DOMApis();
    this.astTree = [];
    this.pretreatmentStore = {};
    this.url = url;
    if (template) {
      const [astTree, collectionEls] = (0, import_utils2.templateParse)(template, [
        "meta",
        "link",
        "style",
        "script"
      ]);
      this.astTree = astTree;
      this.pretreatmentStore = collectionEls;
    }
  }
  getNodesByTagName(...tags) {
    let counter = 0;
    const collection = {};
    for (const tag of tags) {
      if (this.pretreatmentStore[tag]) {
        counter++;
        collection[tag] = this.pretreatmentStore[tag];
      } else {
        collection[tag] = [];
      }
    }
    if (counter !== tags.length) {
      const traverse = (node) => {
        if (node.type !== "element")
          return;
        if (tags.indexOf(node.tagName) > -1 && !this.pretreatmentStore[node.tagName]) {
          collection[node.tagName].push(node);
        }
        for (const child of node.children)
          traverse(child);
      };
      for (const node of this.astTree)
        traverse(node);
    }
    return collection;
  }
  createElements(renderer, parent, commonRender) {
    const elements = [];
    const traverse = (node, parentEl) => {
      var _a;
      let el;
      if (this.DOMApis.isCommentNode(node)) {
      } else if (this.DOMApis.isText(node)) {
        el = this.DOMApis.createTextNode(node);
        parentEl && parentEl.appendChild(el);
      } else if (this.DOMApis.isNode(node)) {
        const { tagName, children } = node;
        if (typeof commonRender === "function") {
          el = (_a = commonRender(node, parent)) == null ? void 0 : _a.customElement;
        }
        if (!el) {
          if (renderer[tagName]) {
            el = renderer[tagName](node);
          } else {
            el = this.DOMApis.createElement(node);
          }
        }
        if (parentEl && el) {
          parentEl.appendChild(el);
        }
        if (el) {
          const { nodeType, _ignoreChildNodes } = el;
          if (!_ignoreChildNodes && nodeType !== 8 && nodeType !== 10) {
            for (const child of children) {
              traverse(child, el);
            }
          }
        }
      }
      return el;
    };
    for (const node of this.astTree) {
      if (this.DOMApis.isNode(node) && node.tagName !== "!doctype") {
        const el = traverse(node, parent);
        el && elements.push(el);
      }
    }
    return elements;
  }
  toResolveUrl(node, type, baseUrl) {
    var _a;
    const src = (_a = node.attributes) == null ? void 0 : _a.find(({ key }) => key === type);
    if (src && src.value && baseUrl) {
      src.value = (0, import_utils2.transformUrl)(baseUrl, src.value);
    }
  }
  ignoreChildNodesCreation(node) {
    if (node) {
      node._ignoreChildNodes = true;
    }
    return node;
  }
  findAllMetaNodes() {
    return this.getNodesByTagName("meta").meta;
  }
  findAllLinkNodes() {
    return this.getNodesByTagName("link").link;
  }
  findAllJsNodes() {
    return this.getNodesByTagName("script").script;
  }
  findAttributeValue(node, type) {
    var _a, _b, _c;
    return (_c = (_b = (_a = node.attributes) == null ? void 0 : _a.find(({ key }) => key === type)) == null ? void 0 : _b.value) != null ? _c : void 0;
  }
  cloneNode(node) {
    return (0, import_utils2.deepMerge)(node, {});
  }
  clone() {
    const cloned = new this.constructor();
    cloned.url = this.url;
    cloned.astTree = this.astTree;
    cloned.pretreatmentStore = this.pretreatmentStore;
    cloned.DOMApis = new import_utils2.DOMApis(this.DOMApis.document);
    return cloned;
  }
};

// src/managers/javascript.ts
var JavaScriptManager = class {
  constructor(scriptCode, url) {
    this.depsStack = /* @__PURE__ */ new Set();
    this.mimeType = "";
    this.async = false;
    this.defer = false;
    this.url = url;
    this.scriptCode = scriptCode;
  }
  isModule() {
    return this.mimeType === "module";
  }
  isInlineScript() {
    return Boolean(!this.url);
  }
  setMimeType(mimeType) {
    this.mimeType = mimeType || "";
  }
  setAsyncAttribute(val) {
    this.async = Boolean(val);
  }
  setDefferAttribute(val) {
    this.defer = Boolean(val);
  }
  setDep(node) {
    this.depsStack.add(node);
  }
  isSameOrigin(node) {
    return this.depsStack.has(node);
  }
  clone() {
    const cloned = new this.constructor();
    cloned.url = this.url;
    cloned.async = this.async;
    cloned.mimeType = this.mimeType;
    cloned.scriptCode = this.scriptCode;
    cloned.depsStack = new Set(this.depsStack);
    return cloned;
  }
};

// src/utils.ts
var import_utils3 = require("@garfish/utils");
function getRequest(customFetch) {
  return async function request(url, config) {
    let result = await customFetch.emit(url, config || {});
    if (!result || !(result instanceof Response)) {
      result = await fetch(url, config || {});
    }
    if (result.status >= 400) {
      (0, import_utils3.error)(`"${url}" load failed with status "${result.status}"`);
    }
    const code = await result.text();
    const type = result.headers.get("content-type") || "";
    const size = Number(result.headers.get("content-size"));
    const mimeType = (0, import_utils3.parseContentType)(type || "");
    return {
      code,
      result,
      mimeType,
      type,
      size: Number.isNaN(size) ? null : size
    };
  };
}
function copyResult(result) {
  if (result.resourceManager) {
    result.resourceManager = result.resourceManager.clone();
  }
  return result;
}
function mergeConfig(loader, url) {
  const extra = loader.requestConfig;
  const config = typeof extra === "function" ? extra(url) : extra;
  const mode = "cors";
  return __spreadValues({ mode }, config);
}

// src/appCache.ts
var cachedDataSet = /* @__PURE__ */ new WeakSet();
var MAX_SIZE = 1024 * 1024 * 50;
var DEFAULT_POLL = Symbol("__defaultBufferPoll__");
var FILE_TYPES = [
  "js" /* js */,
  "css" /* css */,
  "module" /* module */,
  "template" /* template */,
  DEFAULT_POLL
];
var AppCacheContainer = class {
  constructor(maxSize = MAX_SIZE) {
    this.totalSize = 0;
    this.recorder = {};
    this.maxSize = maxSize;
    FILE_TYPES.forEach((key) => {
      this.recorder[key] = 0;
      this[key] = /* @__PURE__ */ new Map();
    });
  }
  bufferPool(type) {
    return this[type];
  }
  has(url) {
    return FILE_TYPES.some((key) => this[key].has(url));
  }
  get(url) {
    for (const key of FILE_TYPES) {
      if (this[key].has(url)) {
        return this[key].get(url);
      }
    }
  }
  set(url, data, type) {
    const curSize = cachedDataSet.has(data) ? 0 : data.size;
    const totalSize = this.totalSize + curSize;
    if (totalSize < this.maxSize) {
      let bar = type;
      let bufferPool = this.bufferPool(type);
      if (!bufferPool) {
        bar = DEFAULT_POLL;
        bufferPool = this.bufferPool(DEFAULT_POLL);
      }
      bufferPool.set(url, data);
      this.totalSize = totalSize;
      this.recorder[bar] += curSize;
      return true;
    }
    return false;
  }
  clear(type) {
    if (typeof type === "string") {
      const cacheBox = this.bufferPool(type);
      if (cacheBox && cacheBox instanceof Map) {
        const size = this.recorder[type];
        this.totalSize -= size;
        this.recorder[type] = 0;
        cacheBox.clear();
      }
    } else {
      FILE_TYPES.forEach((key) => {
        this[key].clear();
        this.recorder[key] = 0;
      });
      this.totalSize = 0;
    }
  }
};

// src/index.ts
var CrossOriginCredentials = /* @__PURE__ */ ((CrossOriginCredentials2) => {
  CrossOriginCredentials2["anonymous"] = "same-origin";
  CrossOriginCredentials2["use-credentials"] = "include";
  return CrossOriginCredentials2;
})(CrossOriginCredentials || {});
var Loader = class {
  constructor(options) {
    this.personalId = import_utils4.__LOADER_FLAG__;
    this.StyleManager = StyleManager;
    this.ModuleManager = ModuleManager;
    this.TemplateManager = TemplateManager;
    this.JavaScriptManager = JavaScriptManager;
    this.hooks = new import_hooks.PluginSystem({
      error: new import_hooks.SyncHook(),
      loaded: new import_hooks.SyncWaterfallHook("loaded"),
      clear: new import_hooks.SyncWaterfallHook("clear"),
      beforeLoad: new import_hooks.SyncWaterfallHook("beforeLoad"),
      fetch: new import_hooks.AsyncHook("fetch")
    });
    this.options = options || {};
    this.loadingList = /* @__PURE__ */ Object.create(null);
    this.cacheStore = /* @__PURE__ */ Object.create(null);
  }
  setOptions(options) {
    this.options = __spreadValues(__spreadValues({}, this.options), options);
  }
  clear(scope, fileType) {
    const appCacheContainer = this.cacheStore[scope];
    if (appCacheContainer) {
      appCacheContainer.clear(fileType);
      this.hooks.lifecycle.clear.emit({ scope, fileType });
    }
  }
  clearAll(fileType) {
    for (const scope in this.cacheStore) {
      this.clear(scope, fileType);
    }
  }
  usePlugin(options) {
    this.hooks.usePlugin(options);
  }
  setLifeCycle(lifeCycle) {
    this.hooks.usePlugin(__spreadValues({
      name: "loader-lifecycle"
    }, lifeCycle));
  }
  loadModule(url) {
    return this.load({
      scope: "modules",
      url,
      isRemoteModule: true
    });
  }
  async load({
    scope,
    url,
    isRemoteModule = false,
    crossOrigin = "anonymous",
    defaultContentType = ""
  }) {
    const { options, loadingList, cacheStore } = this;
    const res = loadingList[url];
    if (res && Object.keys(res).includes(scope)) {
      return (0, import_utils4.macroTask)(res[scope], 4);
    }
    let appCacheContainer = cacheStore[scope];
    if (!appCacheContainer) {
      appCacheContainer = cacheStore[scope] = new AppCacheContainer(options.maxSize);
    }
    if (appCacheContainer.has(url)) {
      return (0, import_utils4.macroTask)(copyResult(appCacheContainer.get(url)), 4);
    } else {
      for (const key in cacheStore) {
        const container = cacheStore[key];
        if (container !== appCacheContainer) {
          if (container.has(url)) {
            const result = container.get(url);
            cachedDataSet.add(result);
            appCacheContainer.set(url, result, result.fileType);
            return (0, import_utils4.macroTask)(copyResult(result), 4);
          }
        }
      }
    }
    const requestConfig = mergeConfig(this, url);
    requestConfig.credentials = CrossOriginCredentials[crossOrigin];
    const resOpts = this.hooks.lifecycle.beforeLoad.emit({
      url,
      scope,
      requestConfig
    });
    const request = getRequest(this.hooks.lifecycle.fetch);
    const loadRes = request(resOpts.url, resOpts.requestConfig).then(({ code, size, result, type }) => {
      let managerCtor, fileType = "";
      if (isRemoteModule) {
        fileType = "module" /* module */;
        managerCtor = this.ModuleManager;
      } else if ((0, import_utils4.isHtmlType)({ type, src: result.url }) || (0, import_utils4.isHtmlType)({
        type: defaultContentType
      })) {
        fileType = "template" /* template */;
        managerCtor = this.TemplateManager;
      } else if ((0, import_utils4.isJsType)({ type: defaultContentType }) || (0, import_utils4.isJsType)({ type, src: result.url })) {
        fileType = "js" /* js */;
        managerCtor = this.JavaScriptManager;
      } else if ((0, import_utils4.isCssType)({ src: result.url, type }) || (0, import_utils4.isCssType)({
        type: defaultContentType
      })) {
        fileType = "css" /* css */;
        managerCtor = this.StyleManager;
      }
      const resourceManager = managerCtor ? new managerCtor(code, result.url) : null;
      const data = this.hooks.lifecycle.loaded.emit({
        result,
        value: {
          url,
          scope,
          resourceManager,
          fileType: fileType || "",
          size: size || code.length,
          code: resourceManager ? "" : code
        }
      });
      fileType && appCacheContainer.set(url, data.value, fileType);
      return copyResult(data.value);
    }).catch((e) => {
      (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && (0, import_utils4.error)(e);
      this.hooks.lifecycle.error.emit(e, { scope });
      throw e;
    }).finally(() => {
    });
    loadingList[url] ? loadingList[url][scope] = loadRes : loadingList[url] = { [scope]: loadRes };
    return loadRes;
  }
};
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CrossOriginCredentials,
  JavaScriptManager,
  Loader,
  ModuleManager,
  StyleManager,
  TemplateManager
});
