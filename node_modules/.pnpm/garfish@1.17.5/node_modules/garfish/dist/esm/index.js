// src/index.ts
import { default as default2 } from "@garfish/core";

// src/instance.ts
import Garfish from "@garfish/core";
import { GarfishRouter } from "@garfish/router";
import { GarfishBrowserVm } from "@garfish/browser-vm";
import { GarfishBrowserSnapshot } from "@garfish/browser-snapshot";
import { def, warn, hasOwn, inBrowser, __GARFISH_FLAG__ } from "@garfish/utils";
function createContext() {
  let fresh = false;
  if (inBrowser() && window["__GARFISH__"] && window["Garfish"]) {
    return window["Garfish"];
  }
  const GarfishInstance2 = new Garfish({
    plugins: [GarfishRouter(), GarfishBrowserVm(), GarfishBrowserSnapshot()]
  });
  const set = (namespace, val = GarfishInstance2) => {
    if (hasOwn(window, namespace)) {
      if (!(window[namespace] && window[namespace].flag === __GARFISH_FLAG__)) {
        const next = () => {
          fresh = true;
          if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
            warn(`"Window.${namespace}" will be overwritten by "garfish".`);
          }
        };
        const desc = Object.getOwnPropertyDescriptor(window, namespace);
        if (desc) {
          if (desc.configurable) {
            def(window, namespace, val);
            next();
          } else if (desc.writable) {
            window[namespace] = val;
            next();
          }
        }
      }
    } else {
      fresh = true;
      def(window, namespace, val);
    }
  };
  if (inBrowser()) {
    set("Garfish");
    def(window, "__GARFISH__", true);
  }
  if (fresh) {
    if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
      if (window["Garfish"].version !== "1.17.5") {
        warn('The "garfish version" used by the main and sub-applications is inconsistent.');
      }
    }
  }
  return GarfishInstance2;
}
var GarfishInstance = createContext();

// src/customElement.ts
function generateCustomerElement(htmlTag, options) {
  class MicroApp extends HTMLElement {
    constructor() {
      super();
      this.appInfo = {
        name: "",
        entry: "",
        basename: ""
      };
      this.options = {
        delay: 200
      };
      this.state = this._observerAppState({
        isLoading: false,
        error: null,
        promise: null,
        loaded: null,
        pastDelay: false
      });
      this.options = options;
    }
    _observerAppState(state) {
      return new Proxy(state, {
        set: (target, p, value, receiver) => {
          const getPlaceHolderAndAppend = () => {
            if (this.placeholder && this.contains(this.placeholder)) {
              this.removeChild(this.placeholder);
            }
            const placeholder = this.options.loading && this.options.loading({
              isLoading: this.state.isLoading,
              error: this.state.error,
              pastDelay: this.state.pastDelay
            });
            placeholder && this.appendChild(placeholder);
            return placeholder;
          };
          const res = Reflect.set(target, p, value, receiver);
          if (p === "error" && value) {
            const placeholder = getPlaceHolderAndAppend();
            if (placeholder)
              this.placeholder = placeholder;
          } else if (p === "pastDelay" && value === true) {
            const placeholder = getPlaceHolderAndAppend();
            if (placeholder)
              this.placeholder = placeholder;
          } else if (p === "isLoading" && value === true) {
            const placeholder = getPlaceHolderAndAppend();
            if (placeholder)
              this.placeholder = placeholder;
          } else if (p === "isLoading" && value === false) {
            if (!this.state.error && this.contains(this.placeholder)) {
              this.removeChild(this.placeholder);
            }
          }
          return res;
        }
      });
    }
    _loadApp() {
      if (this.state.isLoading)
        return;
      this.state.isLoading = true;
      if (typeof this.options.delay === "number") {
        if (this.options.delay === 0) {
          this.state.pastDelay = true;
        } else {
          this._delay = setTimeout(() => {
            this.state.pastDelay = true;
          }, this.options.delay);
        }
      }
      this.state.promise = GarfishInstance.loadApp(this.appInfo.name, {
        entry: this.appInfo.entry,
        domGetter: () => this,
        basename: this.appInfo.basename,
        sandbox: {
          snapshot: false,
          strictIsolation: this.hasAttribute("shadow") || false
        }
      });
    }
    _clearTimeouts() {
      clearTimeout(this._delay);
    }
    async connectedCallback() {
      this.appInfo = {
        name: this.getAttribute("name") || "",
        entry: this.getAttribute("entry") || "",
        basename: this.getAttribute("basename") || "/"
      };
      try {
        this._loadApp();
        this.state.loaded = await this.state.promise;
        if (this.state.loaded.mounted) {
          this.state.loaded.show();
        } else {
          await this.state.loaded.mount();
        }
      } catch (error) {
        this.state.error = error;
      } finally {
        this.state.isLoading = false;
      }
    }
    disconnectedCallback() {
      this._clearTimeouts();
      if (this.state.loaded) {
        this.state.loaded.hide();
      }
    }
    async adoptedCallback() {
    }
    attributeChangedCallback(name, oldValue, newValue) {
      console.log("Custom square element attributes changed.", name, oldValue, newValue);
    }
  }
  if (!customElements.get(htmlTag)) {
    GarfishInstance.run(options.config || {});
    customElements.define(htmlTag, MicroApp);
  }
}
function createLoadableWebComponent(htmlTag, options) {
  if (typeof htmlTag !== "string") {
    throw new Error("garfish requires a `htmlTag` name");
  }
  if (!options.loading) {
    throw new Error("garfish requires a `loading` component");
  }
  const opts = Object.assign({
    loading: false,
    delay: 200,
    timeout: null
  }, options);
  return generateCustomerElement(htmlTag, opts);
}
function defineCustomElements(htmlTag, options) {
  return createLoadableWebComponent(htmlTag, options);
}
export {
  default2 as Garfish,
  GarfishInstance as default,
  defineCustomElements
};
