(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports, module) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse2(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports, module) {
      function setup(env) {
        createDebug2.debug = createDebug2;
        createDebug2.default = createDebug2;
        createDebug2.coerce = coerce;
        createDebug2.disable = disable;
        createDebug2.enable = enable;
        createDebug2.enabled = enabled;
        createDebug2.humanize = require_ms();
        createDebug2.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug2[key] = env[key];
        });
        createDebug2.names = [];
        createDebug2.skips = [];
        createDebug2.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
        }
        createDebug2.selectColor = selectColor;
        function createDebug2(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug2.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug2.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug2.formatArgs.call(self, args);
            const logFn = self.log || createDebug2.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug2.useColors();
          debug.color = createDebug2.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug2.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug2.namespaces) {
                namespacesCache = createDebug2.namespaces;
                enabledCache = createDebug2.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug2.init === "function") {
            createDebug2.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug2.save(namespaces);
          createDebug2.namespaces = namespaces;
          createDebug2.names = [];
          createDebug2.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug2.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug2.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug2.names.map(toNamespace),
            ...createDebug2.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug2.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug2.skips.length; i < len; i++) {
            if (createDebug2.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug2.names.length; i < len; i++) {
            if (createDebug2.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug2.enable(createDebug2.load());
        return createDebug2;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports, module) {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
  var require_has_flag = __commonJS({
    "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module) {
      "use strict";
      module.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    }
  });

  // ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
  var require_supports_color = __commonJS({
    "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
      "use strict";
      var os = __require("os");
      var tty = __require("tty");
      var hasFlag = require_has_flag();
      var { env } = process;
      var forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        forceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = 1;
      }
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min = forceColor || 0;
        if (env.TERM === "dumb") {
          return min;
        }
        if (process.platform === "win32") {
          const osRelease = os.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        return min;
      }
      function getSupportLevel(stream) {
        const level = supportsColor(stream, stream && stream.isTTY);
        return translateLevel(level);
      }
      module.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel(supportsColor(true, tty.isatty(1))),
        stderr: translateLevel(supportsColor(true, tty.isatty(2)))
      };
    }
  });

  // ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js
  var require_node = __commonJS({
    "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js"(exports, module) {
      var tty = __require("tty");
      var util = __require("util");
      exports.init = init2;
      exports.log = log2;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.destroy = util.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      exports.colors = [6, 2, 3, 4, 5, 1];
      try {
        const supportsColor = require_supports_color();
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
          ];
        }
      } catch (error2) {
      }
      exports.inspectOpts = Object.keys(process.env).filter((key) => {
        return /^debug_/i.test(key);
      }).reduce((obj, key) => {
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
          return k.toUpperCase();
        });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        const { namespace: name, useColors: useColors2 } = this;
        if (useColors2) {
          const c = this.color;
          const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
          const prefix = `  ${colorCode};1m${name} \x1B[0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }
      function log2(...args) {
        return process.stderr.write(util.format(...args) + "\n");
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load() {
        return process.env.DEBUG;
      }
      function init2(debug) {
        debug.inspectOpts = {};
        const keys = Object.keys(exports.inspectOpts);
        for (let i = 0; i < keys.length; i++) {
          debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
      };
      formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };
    }
  });

  // ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js
  var require_src = __commonJS({
    "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js"(exports, module) {
      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module.exports = require_browser();
      } else {
        module.exports = require_node();
      }
    }
  });

  // ../../node_modules/.pnpm/eventemitter2@6.4.9/node_modules/eventemitter2/lib/eventemitter2.js
  var require_eventemitter2 = __commonJS({
    "../../node_modules/.pnpm/eventemitter2@6.4.9/node_modules/eventemitter2/lib/eventemitter2.js"(exports, module) {
      !function(undefined2) {
        var hasOwnProperty3 = Object.hasOwnProperty;
        var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        var defaultMaxListeners = 10;
        var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
        var symbolsSupported = typeof Symbol === "function";
        var reflectSupported = typeof Reflect === "object";
        var setImmediateSupported = typeof setImmediate === "function";
        var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
        var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
          var arr = Object.getOwnPropertyNames(obj);
          arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
          return arr;
        } : Object.keys;
        function init2() {
          this._events = {};
          if (this._conf) {
            configure.call(this, this._conf);
          }
        }
        function configure(conf) {
          if (conf) {
            this._conf = conf;
            conf.delimiter && (this.delimiter = conf.delimiter);
            if (conf.maxListeners !== undefined2) {
              this._maxListeners = conf.maxListeners;
            }
            conf.wildcard && (this.wildcard = conf.wildcard);
            conf.newListener && (this._newListener = conf.newListener);
            conf.removeListener && (this._removeListener = conf.removeListener);
            conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
            conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
            if (this.wildcard) {
              this.listenerTree = {};
            }
          }
        }
        function logPossibleMemoryLeak(count, eventName) {
          var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
          if (this.verboseMemoryLeak) {
            errorMsg += " Event name: " + eventName + ".";
          }
          if (typeof process !== "undefined" && process.emitWarning) {
            var e = new Error(errorMsg);
            e.name = "MaxListenersExceededWarning";
            e.emitter = this;
            e.count = count;
            process.emitWarning(e);
          } else {
            console.error(errorMsg);
            if (console.trace) {
              console.trace();
            }
          }
        }
        var toArray = function(a, b, c) {
          var n = arguments.length;
          switch (n) {
            case 0:
              return [];
            case 1:
              return [a];
            case 2:
              return [a, b];
            case 3:
              return [a, b, c];
            default:
              var arr = new Array(n);
              while (n--) {
                arr[n] = arguments[n];
              }
              return arr;
          }
        };
        function toObject(keys, values) {
          var obj = {};
          var key;
          var len = keys.length;
          var valuesCount = values ? values.length : 0;
          for (var i = 0; i < len; i++) {
            key = keys[i];
            obj[key] = i < valuesCount ? values[i] : undefined2;
          }
          return obj;
        }
        function TargetObserver(emitter, target, options) {
          this._emitter = emitter;
          this._target = target;
          this._listeners = {};
          this._listenersCount = 0;
          var on, off;
          if (options.on || options.off) {
            on = options.on;
            off = options.off;
          }
          if (target.addEventListener) {
            on = target.addEventListener;
            off = target.removeEventListener;
          } else if (target.addListener) {
            on = target.addListener;
            off = target.removeListener;
          } else if (target.on) {
            on = target.on;
            off = target.off;
          }
          if (!on && !off) {
            throw Error("target does not implement any known event API");
          }
          if (typeof on !== "function") {
            throw TypeError("on method must be a function");
          }
          if (typeof off !== "function") {
            throw TypeError("off method must be a function");
          }
          this._on = on;
          this._off = off;
          var _observers = emitter._observers;
          if (_observers) {
            _observers.push(this);
          } else {
            emitter._observers = [this];
          }
        }
        Object.assign(TargetObserver.prototype, {
          subscribe: function(event, localEvent, reducer) {
            var observer = this;
            var target = this._target;
            var emitter = this._emitter;
            var listeners = this._listeners;
            var handler = function() {
              var args = toArray.apply(null, arguments);
              var eventObj = {
                data: args,
                name: localEvent,
                original: event
              };
              if (reducer) {
                var result = reducer.call(target, eventObj);
                if (result !== false) {
                  emitter.emit.apply(emitter, [eventObj.name].concat(args));
                }
                return;
              }
              emitter.emit.apply(emitter, [localEvent].concat(args));
            };
            if (listeners[event]) {
              throw Error("Event '" + event + "' is already listening");
            }
            this._listenersCount++;
            if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
              this._onNewListener = function(_event) {
                if (_event === localEvent && listeners[event] === null) {
                  listeners[event] = handler;
                  observer._on.call(target, event, handler);
                }
              };
              emitter.on("newListener", this._onNewListener);
              this._onRemoveListener = function(_event) {
                if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                  listeners[event] = null;
                  observer._off.call(target, event, handler);
                }
              };
              listeners[event] = null;
              emitter.on("removeListener", this._onRemoveListener);
            } else {
              listeners[event] = handler;
              observer._on.call(target, event, handler);
            }
          },
          unsubscribe: function(event) {
            var observer = this;
            var listeners = this._listeners;
            var emitter = this._emitter;
            var handler;
            var events;
            var off = this._off;
            var target = this._target;
            var i;
            if (event && typeof event !== "string") {
              throw TypeError("event must be a string");
            }
            function clearRefs() {
              if (observer._onNewListener) {
                emitter.off("newListener", observer._onNewListener);
                emitter.off("removeListener", observer._onRemoveListener);
                observer._onNewListener = null;
                observer._onRemoveListener = null;
              }
              var index = findTargetIndex.call(emitter, observer);
              emitter._observers.splice(index, 1);
            }
            if (event) {
              handler = listeners[event];
              if (!handler)
                return;
              off.call(target, event, handler);
              delete listeners[event];
              if (!--this._listenersCount) {
                clearRefs();
              }
            } else {
              events = ownKeys(listeners);
              i = events.length;
              while (i-- > 0) {
                event = events[i];
                off.call(target, event, listeners[event]);
              }
              this._listeners = {};
              this._listenersCount = 0;
              clearRefs();
            }
          }
        });
        function resolveOptions(options, schema, reducers, allowUnknown) {
          var computedOptions = Object.assign({}, schema);
          if (!options)
            return computedOptions;
          if (typeof options !== "object") {
            throw TypeError("options must be an object");
          }
          var keys = Object.keys(options);
          var length = keys.length;
          var option, value;
          var reducer;
          function reject(reason) {
            throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
          }
          for (var i = 0; i < length; i++) {
            option = keys[i];
            if (!allowUnknown && !hasOwnProperty3.call(schema, option)) {
              throw Error('Unknown "' + option + '" option');
            }
            value = options[option];
            if (value !== undefined2) {
              reducer = reducers[option];
              computedOptions[option] = reducer ? reducer(value, reject) : value;
            }
          }
          return computedOptions;
        }
        function constructorReducer(value, reject) {
          if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
            reject("value must be a constructor");
          }
          return value;
        }
        function makeTypeReducer(types) {
          var message = "value must be type of " + types.join("|");
          var len = types.length;
          var firstType = types[0];
          var secondType = types[1];
          if (len === 1) {
            return function(v, reject) {
              if (typeof v === firstType) {
                return v;
              }
              reject(message);
            };
          }
          if (len === 2) {
            return function(v, reject) {
              var kind = typeof v;
              if (kind === firstType || kind === secondType)
                return v;
              reject(message);
            };
          }
          return function(v, reject) {
            var kind = typeof v;
            var i = len;
            while (i-- > 0) {
              if (kind === types[i])
                return v;
            }
            reject(message);
          };
        }
        var functionReducer = makeTypeReducer(["function"]);
        var objectFunctionReducer = makeTypeReducer(["object", "function"]);
        function makeCancelablePromise(Promise2, executor, options) {
          var isCancelable;
          var callbacks;
          var timer = 0;
          var subscriptionClosed;
          var promise = new Promise2(function(resolve, reject, onCancel) {
            options = resolveOptions(options, {
              timeout: 0,
              overload: false
            }, {
              timeout: function(value, reject2) {
                value *= 1;
                if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
                  reject2("timeout must be a positive number");
                }
                return value;
              }
            });
            isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
            function cleanup() {
              if (callbacks) {
                callbacks = null;
              }
              if (timer) {
                clearTimeout(timer);
                timer = 0;
              }
            }
            var _resolve = function(value) {
              cleanup();
              resolve(value);
            };
            var _reject = function(err) {
              cleanup();
              reject(err);
            };
            if (isCancelable) {
              executor(_resolve, _reject, onCancel);
            } else {
              callbacks = [function(reason) {
                _reject(reason || Error("canceled"));
              }];
              executor(_resolve, _reject, function(cb) {
                if (subscriptionClosed) {
                  throw Error("Unable to subscribe on cancel event asynchronously");
                }
                if (typeof cb !== "function") {
                  throw TypeError("onCancel callback must be a function");
                }
                callbacks.push(cb);
              });
              subscriptionClosed = true;
            }
            if (options.timeout > 0) {
              timer = setTimeout(function() {
                var reason = Error("timeout");
                reason.code = "ETIMEDOUT";
                timer = 0;
                promise.cancel(reason);
                reject(reason);
              }, options.timeout);
            }
          });
          if (!isCancelable) {
            promise.cancel = function(reason) {
              if (!callbacks) {
                return;
              }
              var length = callbacks.length;
              for (var i = 1; i < length; i++) {
                callbacks[i](reason);
              }
              callbacks[0](reason);
              callbacks = null;
            };
          }
          return promise;
        }
        function findTargetIndex(observer) {
          var observers = this._observers;
          if (!observers) {
            return -1;
          }
          var len = observers.length;
          for (var i = 0; i < len; i++) {
            if (observers[i]._target === observer)
              return i;
          }
          return -1;
        }
        function searchListenerTree(handlers, type, tree, i, typeLength) {
          if (!tree) {
            return null;
          }
          if (i === 0) {
            var kind = typeof type;
            if (kind === "string") {
              var ns2, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
              if ((n = type.indexOf(delimiter)) !== -1) {
                ns2 = new Array(5);
                do {
                  ns2[l++] = type.slice(j, n);
                  j = n + dl;
                } while ((n = type.indexOf(delimiter, j)) !== -1);
                ns2[l++] = type.slice(j);
                type = ns2;
                typeLength = l;
              } else {
                type = [type];
                typeLength = 1;
              }
            } else if (kind === "object") {
              typeLength = type.length;
            } else {
              type = [type];
              typeLength = 1;
            }
          }
          var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;
          if (i === typeLength) {
            if (tree._listeners) {
              if (typeof tree._listeners === "function") {
                handlers && handlers.push(tree._listeners);
                listeners = [tree];
              } else {
                handlers && handlers.push.apply(handlers, tree._listeners);
                listeners = [tree];
              }
            }
          } else {
            if (currentType === "*") {
              branches = ownKeys(tree);
              n = branches.length;
              while (n-- > 0) {
                branch = branches[n];
                if (branch !== "_listeners") {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
                  if (_listeners) {
                    if (listeners) {
                      listeners.push.apply(listeners, _listeners);
                    } else {
                      listeners = _listeners;
                    }
                  }
                }
              }
              return listeners;
            } else if (currentType === "**") {
              endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
              if (endReached && tree._listeners) {
                listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
              }
              branches = ownKeys(tree);
              n = branches.length;
              while (n-- > 0) {
                branch = branches[n];
                if (branch !== "_listeners") {
                  if (branch === "*" || branch === "**") {
                    if (tree[branch]._listeners && !endReached) {
                      _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                      if (_listeners) {
                        if (listeners) {
                          listeners.push.apply(listeners, _listeners);
                        } else {
                          listeners = _listeners;
                        }
                      }
                    }
                    _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                  } else if (branch === nextType) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
                  } else {
                    _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                  }
                  if (_listeners) {
                    if (listeners) {
                      listeners.push.apply(listeners, _listeners);
                    } else {
                      listeners = _listeners;
                    }
                  }
                }
              }
              return listeners;
            } else if (tree[currentType]) {
              listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
            }
          }
          xTree = tree["*"];
          if (xTree) {
            searchListenerTree(handlers, type, xTree, i + 1, typeLength);
          }
          xxTree = tree["**"];
          if (xxTree) {
            if (i < typeLength) {
              if (xxTree._listeners) {
                searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
              }
              branches = ownKeys(xxTree);
              n = branches.length;
              while (n-- > 0) {
                branch = branches[n];
                if (branch !== "_listeners") {
                  if (branch === nextType) {
                    searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
                  } else if (branch === currentType) {
                    searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
                  } else {
                    isolatedBranch = {};
                    isolatedBranch[branch] = xxTree[branch];
                    searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1, typeLength);
                  }
                }
              }
            } else if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            } else if (xxTree["*"] && xxTree["*"]._listeners) {
              searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
            }
          }
          return listeners;
        }
        function growListenerTree(type, listener, prepend) {
          var len = 0, j = 0, i, delimiter = this.delimiter, dl = delimiter.length, ns2;
          if (typeof type === "string") {
            if ((i = type.indexOf(delimiter)) !== -1) {
              ns2 = new Array(5);
              do {
                ns2[len++] = type.slice(j, i);
                j = i + dl;
              } while ((i = type.indexOf(delimiter, j)) !== -1);
              ns2[len++] = type.slice(j);
            } else {
              ns2 = [type];
              len = 1;
            }
          } else {
            ns2 = type;
            len = type.length;
          }
          if (len > 1) {
            for (i = 0; i + 1 < len; i++) {
              if (ns2[i] === "**" && ns2[i + 1] === "**") {
                return;
              }
            }
          }
          var tree = this.listenerTree, name;
          for (i = 0; i < len; i++) {
            name = ns2[i];
            tree = tree[name] || (tree[name] = {});
            if (i === len - 1) {
              if (!tree._listeners) {
                tree._listeners = listener;
              } else {
                if (typeof tree._listeners === "function") {
                  tree._listeners = [tree._listeners];
                }
                if (prepend) {
                  tree._listeners.unshift(listener);
                } else {
                  tree._listeners.push(listener);
                }
                if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                  tree._listeners.warned = true;
                  logPossibleMemoryLeak.call(this, tree._listeners.length, name);
                }
              }
              return true;
            }
          }
          return true;
        }
        function collectTreeEvents(tree, events, root, asArray) {
          var branches = ownKeys(tree);
          var i = branches.length;
          var branch, branchName, path;
          var hasListeners = tree["_listeners"];
          var isArrayPath;
          while (i-- > 0) {
            branchName = branches[i];
            branch = tree[branchName];
            if (branchName === "_listeners") {
              path = root;
            } else {
              path = root ? root.concat(branchName) : [branchName];
            }
            isArrayPath = asArray || typeof branchName === "symbol";
            hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
            if (typeof branch === "object") {
              collectTreeEvents.call(this, branch, events, path, isArrayPath);
            }
          }
          return events;
        }
        function recursivelyGarbageCollect(root) {
          var keys = ownKeys(root);
          var i = keys.length;
          var obj, key, flag;
          while (i-- > 0) {
            key = keys[i];
            obj = root[key];
            if (obj) {
              flag = true;
              if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
                delete root[key];
              }
            }
          }
          return flag;
        }
        function Listener(emitter, event, listener) {
          this.emitter = emitter;
          this.event = event;
          this.listener = listener;
        }
        Listener.prototype.off = function() {
          this.emitter.off(this.event, this.listener);
          return this;
        };
        function setupListener(event, listener, options) {
          if (options === true) {
            promisify = true;
          } else if (options === false) {
            async = true;
          } else {
            if (!options || typeof options !== "object") {
              throw TypeError("options should be an object or true");
            }
            var async = options.async;
            var promisify = options.promisify;
            var nextTick2 = options.nextTick;
            var objectify = options.objectify;
          }
          if (async || nextTick2 || promisify) {
            var _listener = listener;
            var _origin = listener._origin || listener;
            if (nextTick2 && !nextTickSupported) {
              throw Error("process.nextTick is not supported");
            }
            if (promisify === undefined2) {
              promisify = listener.constructor.name === "AsyncFunction";
            }
            listener = function() {
              var args = arguments;
              var context = this;
              var event2 = this.event;
              return promisify ? nextTick2 ? Promise.resolve() : new Promise(function(resolve) {
                _setImmediate(resolve);
              }).then(function() {
                context.event = event2;
                return _listener.apply(context, args);
              }) : (nextTick2 ? process.nextTick : _setImmediate)(function() {
                context.event = event2;
                _listener.apply(context, args);
              });
            };
            listener._async = true;
            listener._origin = _origin;
          }
          return [listener, objectify ? new Listener(this, event, listener) : this];
        }
        function EventEmitter(conf) {
          this._events = {};
          this._newListener = false;
          this._removeListener = false;
          this.verboseMemoryLeak = false;
          configure.call(this, conf);
        }
        EventEmitter.EventEmitter2 = EventEmitter;
        EventEmitter.prototype.listenTo = function(target, events, options) {
          if (typeof target !== "object") {
            throw TypeError("target musts be an object");
          }
          var emitter = this;
          options = resolveOptions(options, {
            on: undefined2,
            off: undefined2,
            reducers: undefined2
          }, {
            on: functionReducer,
            off: functionReducer,
            reducers: objectFunctionReducer
          });
          function listen2(events2) {
            if (typeof events2 !== "object") {
              throw TypeError("events must be an object");
            }
            var reducers = options.reducers;
            var index = findTargetIndex.call(emitter, target);
            var observer;
            if (index === -1) {
              observer = new TargetObserver(emitter, target, options);
            } else {
              observer = emitter._observers[index];
            }
            var keys = ownKeys(events2);
            var len = keys.length;
            var event;
            var isSingleReducer = typeof reducers === "function";
            for (var i = 0; i < len; i++) {
              event = keys[i];
              observer.subscribe(event, events2[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);
            }
          }
          isArray(events) ? listen2(toObject(events)) : typeof events === "string" ? listen2(toObject(events.split(/\s+/))) : listen2(events);
          return this;
        };
        EventEmitter.prototype.stopListeningTo = function(target, event) {
          var observers = this._observers;
          if (!observers) {
            return false;
          }
          var i = observers.length;
          var observer;
          var matched = false;
          if (target && typeof target !== "object") {
            throw TypeError("target should be an object");
          }
          while (i-- > 0) {
            observer = observers[i];
            if (!target || observer._target === target) {
              observer.unsubscribe(event);
              matched = true;
            }
          }
          return matched;
        };
        EventEmitter.prototype.delimiter = ".";
        EventEmitter.prototype.setMaxListeners = function(n) {
          if (n !== undefined2) {
            this._maxListeners = n;
            if (!this._conf)
              this._conf = {};
            this._conf.maxListeners = n;
          }
        };
        EventEmitter.prototype.getMaxListeners = function() {
          return this._maxListeners;
        };
        EventEmitter.prototype.event = "";
        EventEmitter.prototype.once = function(event, fn, options) {
          return this._once(event, fn, false, options);
        };
        EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
          return this._once(event, fn, true, options);
        };
        EventEmitter.prototype._once = function(event, fn, prepend, options) {
          return this._many(event, 1, fn, prepend, options);
        };
        EventEmitter.prototype.many = function(event, ttl, fn, options) {
          return this._many(event, ttl, fn, false, options);
        };
        EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
          return this._many(event, ttl, fn, true, options);
        };
        EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
          var self = this;
          if (typeof fn !== "function") {
            throw new Error("many only accepts instances of Function");
          }
          function listener() {
            if (--ttl === 0) {
              self.off(event, listener);
            }
            return fn.apply(this, arguments);
          }
          listener._origin = fn;
          return this._on(event, listener, prepend, options);
        };
        EventEmitter.prototype.emit = function() {
          if (!this._events && !this._all) {
            return false;
          }
          this._events || init2.call(this);
          var type = arguments[0], ns2, wildcard = this.wildcard;
          var args, l, i, j, containsSymbol;
          if (type === "newListener" && !this._newListener) {
            if (!this._events.newListener) {
              return false;
            }
          }
          if (wildcard) {
            ns2 = type;
            if (type !== "newListener" && type !== "removeListener") {
              if (typeof type === "object") {
                l = type.length;
                if (symbolsSupported) {
                  for (i = 0; i < l; i++) {
                    if (typeof type[i] === "symbol") {
                      containsSymbol = true;
                      break;
                    }
                  }
                }
                if (!containsSymbol) {
                  type = type.join(this.delimiter);
                }
              }
            }
          }
          var al = arguments.length;
          var handler;
          if (this._all && this._all.length) {
            handler = this._all.slice();
            for (i = 0, l = handler.length; i < l; i++) {
              this.event = type;
              switch (al) {
                case 1:
                  handler[i].call(this, type);
                  break;
                case 2:
                  handler[i].call(this, type, arguments[1]);
                  break;
                case 3:
                  handler[i].call(this, type, arguments[1], arguments[2]);
                  break;
                default:
                  handler[i].apply(this, arguments);
              }
            }
          }
          if (wildcard) {
            handler = [];
            searchListenerTree.call(this, handler, ns2, this.listenerTree, 0, l);
          } else {
            handler = this._events[type];
            if (typeof handler === "function") {
              this.event = type;
              switch (al) {
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  args = new Array(al - 1);
                  for (j = 1; j < al; j++)
                    args[j - 1] = arguments[j];
                  handler.apply(this, args);
              }
              return true;
            } else if (handler) {
              handler = handler.slice();
            }
          }
          if (handler && handler.length) {
            if (al > 3) {
              args = new Array(al - 1);
              for (j = 1; j < al; j++)
                args[j - 1] = arguments[j];
            }
            for (i = 0, l = handler.length; i < l; i++) {
              this.event = type;
              switch (al) {
                case 1:
                  handler[i].call(this);
                  break;
                case 2:
                  handler[i].call(this, arguments[1]);
                  break;
                case 3:
                  handler[i].call(this, arguments[1], arguments[2]);
                  break;
                default:
                  handler[i].apply(this, args);
              }
            }
            return true;
          } else if (!this.ignoreErrors && !this._all && type === "error") {
            if (arguments[1] instanceof Error) {
              throw arguments[1];
            } else {
              throw new Error("Uncaught, unspecified 'error' event.");
            }
          }
          return !!this._all;
        };
        EventEmitter.prototype.emitAsync = function() {
          if (!this._events && !this._all) {
            return false;
          }
          this._events || init2.call(this);
          var type = arguments[0], wildcard = this.wildcard, ns2, containsSymbol;
          var args, l, i, j;
          if (type === "newListener" && !this._newListener) {
            if (!this._events.newListener) {
              return Promise.resolve([false]);
            }
          }
          if (wildcard) {
            ns2 = type;
            if (type !== "newListener" && type !== "removeListener") {
              if (typeof type === "object") {
                l = type.length;
                if (symbolsSupported) {
                  for (i = 0; i < l; i++) {
                    if (typeof type[i] === "symbol") {
                      containsSymbol = true;
                      break;
                    }
                  }
                }
                if (!containsSymbol) {
                  type = type.join(this.delimiter);
                }
              }
            }
          }
          var promises = [];
          var al = arguments.length;
          var handler;
          if (this._all) {
            for (i = 0, l = this._all.length; i < l; i++) {
              this.event = type;
              switch (al) {
                case 1:
                  promises.push(this._all[i].call(this, type));
                  break;
                case 2:
                  promises.push(this._all[i].call(this, type, arguments[1]));
                  break;
                case 3:
                  promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                  break;
                default:
                  promises.push(this._all[i].apply(this, arguments));
              }
            }
          }
          if (wildcard) {
            handler = [];
            searchListenerTree.call(this, handler, ns2, this.listenerTree, 0);
          } else {
            handler = this._events[type];
          }
          if (typeof handler === "function") {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(handler.call(this));
                break;
              case 2:
                promises.push(handler.call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler.call(this, arguments[1], arguments[2]));
                break;
              default:
                args = new Array(al - 1);
                for (j = 1; j < al; j++)
                  args[j - 1] = arguments[j];
                promises.push(handler.apply(this, args));
            }
          } else if (handler && handler.length) {
            handler = handler.slice();
            if (al > 3) {
              args = new Array(al - 1);
              for (j = 1; j < al; j++)
                args[j - 1] = arguments[j];
            }
            for (i = 0, l = handler.length; i < l; i++) {
              this.event = type;
              switch (al) {
                case 1:
                  promises.push(handler[i].call(this));
                  break;
                case 2:
                  promises.push(handler[i].call(this, arguments[1]));
                  break;
                case 3:
                  promises.push(handler[i].call(this, arguments[1], arguments[2]));
                  break;
                default:
                  promises.push(handler[i].apply(this, args));
              }
            }
          } else if (!this.ignoreErrors && !this._all && type === "error") {
            if (arguments[1] instanceof Error) {
              return Promise.reject(arguments[1]);
            } else {
              return Promise.reject("Uncaught, unspecified 'error' event.");
            }
          }
          return Promise.all(promises);
        };
        EventEmitter.prototype.on = function(type, listener, options) {
          return this._on(type, listener, false, options);
        };
        EventEmitter.prototype.prependListener = function(type, listener, options) {
          return this._on(type, listener, true, options);
        };
        EventEmitter.prototype.onAny = function(fn) {
          return this._onAny(fn, false);
        };
        EventEmitter.prototype.prependAny = function(fn) {
          return this._onAny(fn, true);
        };
        EventEmitter.prototype.addListener = EventEmitter.prototype.on;
        EventEmitter.prototype._onAny = function(fn, prepend) {
          if (typeof fn !== "function") {
            throw new Error("onAny only accepts instances of Function");
          }
          if (!this._all) {
            this._all = [];
          }
          if (prepend) {
            this._all.unshift(fn);
          } else {
            this._all.push(fn);
          }
          return this;
        };
        EventEmitter.prototype._on = function(type, listener, prepend, options) {
          if (typeof type === "function") {
            this._onAny(type, listener);
            return this;
          }
          if (typeof listener !== "function") {
            throw new Error("on only accepts instances of Function");
          }
          this._events || init2.call(this);
          var returnValue = this, temp;
          if (options !== undefined2) {
            temp = setupListener.call(this, type, listener, options);
            listener = temp[0];
            returnValue = temp[1];
          }
          if (this._newListener) {
            this.emit("newListener", type, listener);
          }
          if (this.wildcard) {
            growListenerTree.call(this, type, listener, prepend);
            return returnValue;
          }
          if (!this._events[type]) {
            this._events[type] = listener;
          } else {
            if (typeof this._events[type] === "function") {
              this._events[type] = [this._events[type]];
            }
            if (prepend) {
              this._events[type].unshift(listener);
            } else {
              this._events[type].push(listener);
            }
            if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
              this._events[type].warned = true;
              logPossibleMemoryLeak.call(this, this._events[type].length, type);
            }
          }
          return returnValue;
        };
        EventEmitter.prototype.off = function(type, listener) {
          if (typeof listener !== "function") {
            throw new Error("removeListener only takes instances of Function");
          }
          var handlers, leafs = [];
          if (this.wildcard) {
            var ns2 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            leafs = searchListenerTree.call(this, null, ns2, this.listenerTree, 0);
            if (!leafs)
              return this;
          } else {
            if (!this._events[type])
              return this;
            handlers = this._events[type];
            leafs.push({ _listeners: handlers });
          }
          for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
            var leaf = leafs[iLeaf];
            handlers = leaf._listeners;
            if (isArray(handlers)) {
              var position = -1;
              for (var i = 0, length = handlers.length; i < length; i++) {
                if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                  position = i;
                  break;
                }
              }
              if (position < 0) {
                continue;
              }
              if (this.wildcard) {
                leaf._listeners.splice(position, 1);
              } else {
                this._events[type].splice(position, 1);
              }
              if (handlers.length === 0) {
                if (this.wildcard) {
                  delete leaf._listeners;
                } else {
                  delete this._events[type];
                }
              }
              if (this._removeListener)
                this.emit("removeListener", type, listener);
              return this;
            } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
              if (this._removeListener)
                this.emit("removeListener", type, listener);
            }
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
          return this;
        };
        EventEmitter.prototype.offAny = function(fn) {
          var i = 0, l = 0, fns;
          if (fn && this._all && this._all.length > 0) {
            fns = this._all;
            for (i = 0, l = fns.length; i < l; i++) {
              if (fn === fns[i]) {
                fns.splice(i, 1);
                if (this._removeListener)
                  this.emit("removeListenerAny", fn);
                return this;
              }
            }
          } else {
            fns = this._all;
            if (this._removeListener) {
              for (i = 0, l = fns.length; i < l; i++)
                this.emit("removeListenerAny", fns[i]);
            }
            this._all = [];
          }
          return this;
        };
        EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
        EventEmitter.prototype.removeAllListeners = function(type) {
          if (type === undefined2) {
            !this._events || init2.call(this);
            return this;
          }
          if (this.wildcard) {
            var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
            if (!leafs)
              return this;
            for (i = 0; i < leafs.length; i++) {
              leaf = leafs[i];
              leaf._listeners = null;
            }
            this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
          } else if (this._events) {
            this._events[type] = null;
          }
          return this;
        };
        EventEmitter.prototype.listeners = function(type) {
          var _events = this._events;
          var keys, listeners, allListeners;
          var i;
          var listenerTree;
          if (type === undefined2) {
            if (this.wildcard) {
              throw Error("event name required for wildcard emitter");
            }
            if (!_events) {
              return [];
            }
            keys = ownKeys(_events);
            i = keys.length;
            allListeners = [];
            while (i-- > 0) {
              listeners = _events[keys[i]];
              if (typeof listeners === "function") {
                allListeners.push(listeners);
              } else {
                allListeners.push.apply(allListeners, listeners);
              }
            }
            return allListeners;
          } else {
            if (this.wildcard) {
              listenerTree = this.listenerTree;
              if (!listenerTree)
                return [];
              var handlers = [];
              var ns2 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
              searchListenerTree.call(this, handlers, ns2, listenerTree, 0);
              return handlers;
            }
            if (!_events) {
              return [];
            }
            listeners = _events[type];
            if (!listeners) {
              return [];
            }
            return typeof listeners === "function" ? [listeners] : listeners;
          }
        };
        EventEmitter.prototype.eventNames = function(nsAsArray) {
          var _events = this._events;
          return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
        };
        EventEmitter.prototype.listenerCount = function(type) {
          return this.listeners(type).length;
        };
        EventEmitter.prototype.hasListeners = function(type) {
          if (this.wildcard) {
            var handlers = [];
            var ns2 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns2, this.listenerTree, 0);
            return handlers.length > 0;
          }
          var _events = this._events;
          var _all = this._all;
          return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
        };
        EventEmitter.prototype.listenersAny = function() {
          if (this._all) {
            return this._all;
          } else {
            return [];
          }
        };
        EventEmitter.prototype.waitFor = function(event, options) {
          var self = this;
          var type = typeof options;
          if (type === "number") {
            options = { timeout: options };
          } else if (type === "function") {
            options = { filter: options };
          }
          options = resolveOptions(options, {
            timeout: 0,
            filter: undefined2,
            handleError: false,
            Promise,
            overload: false
          }, {
            filter: functionReducer,
            Promise: constructorReducer
          });
          return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
            function listener() {
              var filter = options.filter;
              if (filter && !filter.apply(self, arguments)) {
                return;
              }
              self.off(event, listener);
              if (options.handleError) {
                var err = arguments[0];
                err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
              } else {
                resolve(toArray.apply(null, arguments));
              }
            }
            onCancel(function() {
              self.off(event, listener);
            });
            self._on(event, listener, false);
          }, {
            timeout: options.timeout,
            overload: options.overload
          });
        };
        function once(emitter, name, options) {
          options = resolveOptions(options, {
            Promise,
            timeout: 0,
            overload: false
          }, {
            Promise: constructorReducer
          });
          var _Promise = options.Promise;
          return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
            var handler;
            if (typeof emitter.addEventListener === "function") {
              handler = function() {
                resolve(toArray.apply(null, arguments));
              };
              onCancel(function() {
                emitter.removeEventListener(name, handler);
              });
              emitter.addEventListener(name, handler, { once: true });
              return;
            }
            var eventListener = function() {
              errorListener && emitter.removeListener("error", errorListener);
              resolve(toArray.apply(null, arguments));
            };
            var errorListener;
            if (name !== "error") {
              errorListener = function(err) {
                emitter.removeListener(name, eventListener);
                reject(err);
              };
              emitter.once("error", errorListener);
            }
            onCancel(function() {
              errorListener && emitter.removeListener("error", errorListener);
              emitter.removeListener(name, eventListener);
            });
            emitter.once(name, eventListener);
          }, {
            timeout: options.timeout,
            overload: options.overload
          });
        }
        var prototype = EventEmitter.prototype;
        Object.defineProperties(EventEmitter, {
          defaultMaxListeners: {
            get: function() {
              return prototype._maxListeners;
            },
            set: function(n) {
              if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
                throw TypeError("n must be a non-negative number");
              }
              prototype._maxListeners = n;
            },
            enumerable: true
          },
          once: {
            value: once,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperties(prototype, {
          _maxListeners: {
            value: defaultMaxListeners,
            writable: true,
            configurable: true
          },
          _observers: { value: null, writable: true, configurable: true }
        });
        if (typeof define === "function" && define.amd) {
          define(function() {
            return EventEmitter;
          });
        } else if (typeof exports === "object") {
          module.exports = EventEmitter;
        } else {
          var _global = new Function("", "return this")();
          _global.EventEmitter2 = EventEmitter;
        }
      }();
    }
  });

  // ../utils/src/utils.ts
  var noop = () => {
  };
  var objectToString = Object.prototype.toString;
  var idleCallback = window.requestIdleCallback || window.requestAnimationFrame;
  function createKey() {
    return Math.random().toString(36).substr(2, 8);
  }
  function isObject(val) {
    return val && typeof val === "object";
  }
  function isPlainObject(val) {
    return objectToString.call(val) === "[object Object]";
  }
  function getType(val) {
    return objectToString.call(val).slice(8, -1).toLowerCase();
  }
  function isPromise(obj) {
    return isObject(obj) && typeof obj.then === "function";
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }
  function def(obj, key, value) {
    Object.defineProperty(obj, key, {
      get: () => value,
      set: (val) => {
        if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          if (val !== value) {
            error(`Try to modify a read-only property ${key}`);
          }
        }
      },
      configurable: (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) ? true : false
    });
  }
  function makeMap(list) {
    const map = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return (val) => !!map[val];
  }
  function inBrowser() {
    return typeof window !== "undefined";
  }
  var warnPrefix = "[Garfish warning]";
  var processError = (error2, fn) => {
    try {
      if (typeof error2 === "string") {
        error2 = `${warnPrefix}: ${error2}

`;
        fn(error2, true);
      } else if (error2 instanceof Error) {
        if (!error2.message.startsWith(warnPrefix)) {
          error2.message = `${warnPrefix}: ${error2.message}`;
        }
        fn(error2, false);
      }
    } catch (e) {
      fn(error2, typeof error2 === "string");
    }
  };
  function warn(msg) {
    processError(msg, (e, isString) => {
      const warnMsg = isString ? e : e.message;
      if (false) {
        callTestCallback(warn, warnMsg);
        return;
      }
      console.warn(warnMsg);
    });
  }
  function error(error2) {
    processError(error2, (e, isString) => {
      if (isString) {
        throw new Error(e);
      } else {
        throw e;
      }
    });
  }
  function validURL(str) {
    const pattern = new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$", "i");
    return !!pattern.test(str);
  }
  function internFunc(internalizeString) {
    const temporaryOb = {};
    temporaryOb[internalizeString] = true;
    return Object.keys(temporaryOb)[0];
  }
  function evalWithEnv(code, params, context, useStrict = false) {
    const keys = Object.keys(params);
    const nativeWindow = (0, eval)("window;");
    const randomValKey = "__garfish__exec_temporary__";
    const values = keys.map((k) => `window.${randomValKey}.${k}`);
    const contextKey = "__garfish_exec_temporary_context__";
    try {
      nativeWindow[randomValKey] = params;
      nativeWindow[contextKey] = context;
      const evalInfo = [
        `;(function(${keys.join(",")}){${useStrict ? '"use strict";' : ""}`,
        `
}).call(window.${contextKey},${values.join(",")});`
      ];
      const internalizeString = internFunc(evalInfo[0] + code + evalInfo[1]);
      (0, eval)(internalizeString);
    } catch (e) {
      throw e;
    } finally {
      delete nativeWindow[randomValKey];
      delete nativeWindow[contextKey];
    }
  }
  function safeWrapper(callback, disableWarn) {
    try {
      callback();
    } catch (e) {
      !disableWarn && (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(e);
    }
  }
  function nextTick(cb) {
    Promise.resolve().then(cb);
  }
  function assert(condition, msg) {
    if (!condition) {
      error(msg || "unknow reason");
    }
  }
  function toBoolean(val) {
    if (val === "")
      return true;
    if (val === "false")
      return false;
    return Boolean(val);
  }
  function remove(list, el) {
    if (Array.isArray(list)) {
      const i = list.indexOf(el);
      if (i > -1) {
        list.splice(i, 1);
        return true;
      }
      return false;
    } else {
      if (list.has(el)) {
        list.delete(el);
        return true;
      }
      return false;
    }
  }
  function unique(list) {
    const res = [];
    for (let i = 0, len = list.length; i < len; i++) {
      for (let j = i + 1; j < len; j++) {
        if (list[i] === list[j]) {
          j = ++i;
        }
      }
      res.push(list[i]);
    }
    return false ? res.sort() : res;
  }
  function isPrimitive(val) {
    return val === null || typeof val === "string" || typeof val === "number" || typeof val === "bigint" || typeof val === "symbol" || typeof val === "boolean" || typeof val === "undefined" || objectToString.call(val) === "[object RegExp]";
  }
  function filterUndefinedVal(ob) {
    return Object.keys(ob).reduce((res, key) => {
      if (res[key] === void 0) {
        delete res[key];
      }
      return res;
    }, ob);
  }
  function deepMerge(o, n, dp, ignores) {
    const leftRecord = /* @__PURE__ */ new WeakMap();
    const rightRecord = /* @__PURE__ */ new WeakMap();
    const valueRecord = /* @__PURE__ */ new WeakMap();
    const ignoresMap = makeMap(ignores || []);
    const isArray = Array.isArray;
    const isAllRefs = (a, b) => {
      if (leftRecord.has(a) || rightRecord.has(a)) {
        return leftRecord.has(b) || rightRecord.has(b);
      }
    };
    const clone = (v) => {
      if (isPrimitive(v) || typeof v === "function") {
        return v;
      } else if (valueRecord.has(v)) {
        return valueRecord.get(v);
      } else if (leftRecord.has(v)) {
        return leftRecord.get(v);
      } else if (rightRecord.has(v)) {
        return rightRecord.get(v);
      } else if (isArray(v)) {
        if (dp)
          v = unique(v);
        const arr = [];
        valueRecord.set(v, arr);
        for (let i = 0, len = v.length; i < len; i++) {
          arr[i] = clone(v[i]);
        }
        return arr;
      } else if (typeof v === "object") {
        const obj = {};
        valueRecord.set(v, obj);
        const keys = Reflect.ownKeys(v);
        keys.forEach((key) => obj[key] = clone(v[key]));
        return obj;
      }
    };
    const setValue = (r, k, key) => {
      if (r.has(k)) {
        return r.get(k);
      } else {
        if (ignoresMap[key]) {
          return k;
        }
        const val = clone(k);
        if (!isPrimitive(val) && typeof val !== "function") {
          r.set(k, val);
        }
        return val;
      }
    };
    const mergeObject = (l, r) => {
      const res = {};
      const leftKeys = Reflect.ownKeys(l);
      const rightKeys = Reflect.ownKeys(r);
      leftRecord.set(l, res);
      rightRecord.set(r, res);
      leftKeys.forEach((key) => {
        const lv = l[key];
        const rv = r[key];
        if (hasOwn(r, key)) {
          if (isArray(lv) && isArray(rv)) {
            const item = clone([...lv, ...rv]);
            res[key] = dp ? unique(item) : item;
          } else if (isPlainObject(lv) && isPlainObject(rv)) {
            res[key] = isAllRefs(lv, rv) ? leftRecord.get(lv) : mergeObject(lv, rv);
          } else {
            res[key] = setValue(rightRecord, rv, key);
          }
        } else {
          res[key] = setValue(leftRecord, lv, key);
        }
      });
      rightKeys.forEach((key) => {
        if (hasOwn(res, key))
          return;
        res[key] = setValue(rightRecord, r[key], key);
      });
      return res;
    };
    return mergeObject(o, n);
  }
  function isAbsolute(url) {
    if (!/^[a-zA-Z]:\\/.test(url)) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url)) {
        return true;
      }
    }
    return false;
  }
  function transformUrl(resolvePath, curPath) {
    if (curPath.startsWith("http") || curPath.startsWith("//")) {
      return curPath;
    }
    const baseUrl = new URL(resolvePath, location.href);
    const realPath = new URL(curPath, baseUrl.href);
    return realPath.href;
  }
  function toWsProtocol(url) {
    const data = new URL(url);
    if (data.protocol.startsWith("http")) {
      data.protocol = data.protocol === "https:" ? "wss:" : "ws:";
      return data.toString();
    }
    return url;
  }
  function findTarget(el, selectors) {
    for (const s of selectors) {
      const target = el.querySelector(s);
      if (target)
        return target;
    }
    return el;
  }
  function setDocCurrentScript(target, code, define2, url, async, defer, originScript) {
    if (!target)
      return noop;
    const el = document.createElement("script");
    if (!url && code) {
      el.textContent = code;
    }
    if (url) {
      el.src = url;
    }
    originScript && originScript.getAttributeNames().forEach((attribute) => {
      el.setAttribute(attribute, originScript.getAttribute(attribute) || "");
    });
    if (async) {
      el.setAttribute("async", "true");
    }
    if (defer) {
      el.setAttribute("defer", "true");
    }
    const set2 = (val) => {
      try {
        if (define2) {
          Object.defineProperty(target, "currentScript", {
            value: val,
            writable: true,
            configurable: true
          });
        } else {
          target.currentScript = val;
        }
      } catch (e) {
        if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          warn(e);
        }
      }
    };
    set2(el);
    return () => safeWrapper(() => delete target.currentScript, true);
  }
  function toBase64(input, mimeType) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.readAsDataURL(new Blob([input], { type: mimeType }));
      reader.onload = () => resolve(reader.result);
    });
  }
  function safari13Deal() {
    let fromSetFlag = false;
    return {
      triggerSet() {
        fromSetFlag = true;
      },
      handleDescriptor(descriptor) {
        if (fromSetFlag === true) {
          fromSetFlag = false;
          if ((descriptor == null ? void 0 : descriptor.writable) === false)
            descriptor.writable = true;
          if ((descriptor == null ? void 0 : descriptor.enumerable) === false)
            descriptor.enumerable = true;
          if ((descriptor == null ? void 0 : descriptor.configurable) === false)
            descriptor.configurable = true;
        }
      }
    };
  }
  var SOURCEMAP_REG = /[@#] sourceMappingURL=/g;
  function haveSourcemap(code) {
    return SOURCEMAP_REG.test(code);
  }
  async function createSourcemap(code, filename) {
    const content = await toBase64(JSON.stringify({
      version: 3,
      sources: [filename],
      sourcesContent: [code],
      mappings: ";" + code.split("\n").map(() => "AACA").join(";")
    }));
    return `//@ sourceMappingURL=${content}`;
  }
  function getSourceURL(url) {
    if (url instanceof URL)
      return url.href;
    if (url instanceof Request)
      return url.url;
    return url.startsWith("/") ? `${location.origin}${url}` : url;
  }
  function macroTask(value, time = 0) {
    return new Promise((resolve) => {
      setTimeout(() => resolve(value), time);
    });
  }

  // ../utils/src/queue.ts
  var Queue = class {
    constructor() {
      this.fx = [];
      this.init = true;
      this.lock = false;
      this.finishDefers = /* @__PURE__ */ new Set();
    }
    next() {
      if (!this.lock) {
        this.lock = true;
        if (this.fx.length === 0) {
          this.init = true;
          this.finishDefers.forEach((d) => d.resolve());
          this.finishDefers.clear();
        } else {
          const fn = this.fx.shift();
          if (fn) {
            fn(() => {
              this.lock = false;
              this.next();
            });
          }
        }
      }
    }
    add(fn) {
      this.fx.push(fn);
      if (this.init) {
        this.lock = false;
        this.init = false;
        this.next();
      }
    }
    awaitCompletion() {
      if (this.init)
        return Promise.resolve();
      const defer = {};
      this.finishDefers.add(defer);
      return new Promise((resolve, reject) => {
        defer.resolve = resolve;
        defer.reject = reject;
      });
    }
  };

  // ../utils/src/sentry.ts
  var sourceListTags = [
    "link",
    "style",
    "script",
    "img",
    "video",
    "audio",
    "iframe"
  ];
  var sourceNode = makeMap(sourceListTags);

  // ../utils/src/domApis.ts
  var xChar = 120;
  var colonChar = 58;
  var ns = "http://www.w3.org/2000/svg";
  var xlinkNS = "http://www.w3.org/1999/xlink";
  var xmlNS = "http://www.w3.org/XML/1998/namespace";
  var xlinkPrefix = "xlink";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var isSVG = makeMap(SVG_TAGS.split(","));
  function changeTagNameToLowerCase(tagName) {
    return isSVG(tagName) ? tagName : tagName.toLowerCase();
  }
  function attributesString(attributes) {
    if (!attributes || attributes.length === 0)
      return "";
    return attributes.reduce((total, { key, value }) => {
      return total + (value ? `${key}="${value}" ` : key);
    }, "");
  }
  var DOMApis = class {
    constructor(cusDocument) {
      this.document = cusDocument || document;
    }
    isText(node) {
      return node && node.type === "text";
    }
    isNode(node) {
      return node && node.type === "element";
    }
    isCommentNode(node) {
      return node && node.type === "comment";
    }
    isCssLinkNode(node) {
      if (this.isNode(node) && node.tagName === "link") {
        return !!node.attributes.find(({ key, value }) => key === "rel" && value === "stylesheet");
      }
      return false;
    }
    isIconLinkNode(node) {
      if (this.isNode(node) && node.tagName === "link") {
        return !!node.attributes.find(({ key, value }) => key === "rel" && value === "icon");
      }
      return false;
    }
    isPrefetchJsLinkNode(node) {
      if (!this.isNode(node) || node.tagName !== "link")
        return false;
      let hasRelAttr, hasAsAttr;
      for (const { key, value } of node.attributes) {
        if (key === "rel") {
          hasRelAttr = true;
          if (value !== "preload" && value !== "prefetch") {
            return false;
          }
        } else if (key === "as") {
          hasAsAttr = true;
          if (value !== "script")
            return false;
        }
      }
      return Boolean(hasRelAttr && hasAsAttr);
    }
    isRemoteModule(node) {
      if (!this.isNode(node) || node.tagName !== "meta")
        return false;
      let hasNameAttr, hasSrcAttr;
      for (const { key, value } of node.attributes) {
        if (key === "name") {
          hasNameAttr = true;
          if (value !== "garfish-remote-module") {
            return false;
          }
        } else if (key === "src") {
          hasSrcAttr = true;
          if (typeof value === "undefined" || value === "") {
            return false;
          }
        }
      }
      return Boolean(hasNameAttr && hasSrcAttr);
    }
    removeElement(el) {
      const parentNode = el && el.parentNode;
      if (parentNode) {
        parentNode.removeChild(el);
      }
    }
    createElement(node) {
      const { tagName, attributes } = node;
      const el = isSVG(tagName) ? this.document.createElementNS(ns, tagName) : this.document.createElement(tagName);
      this.applyAttributes(el, attributes);
      return el;
    }
    createTextNode(node) {
      return this.document.createTextNode(node.content);
    }
    createStyleNode(content) {
      const el = this.document.createElement("style");
      content && (el.textContent = content);
      this.applyAttributes(el, [{ key: "type", value: "text/css" }]);
      return el;
    }
    createLinkCommentNode(node) {
      if (this.isNode(node)) {
        const ps = attributesString(node.attributes);
        return `<link ${ps.slice(0, -1)}></link>`;
      } else {
        node = node ? `src="${node}" ` : "";
        return this.document.createComment(`<link ${node}execute by garfish(dynamic)></link>`);
      }
    }
    createScriptCommentNode(node) {
      if (this.isNode(node)) {
        const { attributes, children } = node;
        const ps = attributesString(attributes);
        const code = (children == null ? void 0 : children[0]) ? children[0].content : "";
        return this.document.createComment(`<script ${ps} execute by garfish>${code}<\/script>`);
      } else {
        const { src, code } = node;
        const url = src ? `src="${src}" ` : "";
        return this.document.createComment(`<script ${url}execute by garfish(dynamic)>${code}<\/script>`);
      }
    }
    applyAttributes(el, attributes) {
      if (!attributes || attributes.length === 0)
        return;
      for (const { key, value } of attributes) {
        if (key) {
          if (value === null) {
            el.setAttribute(key, "");
          } else if (typeof value === "string") {
            if (key.charCodeAt(0) !== xChar) {
              el.setAttribute(key, value);
            } else if (key.charCodeAt(3) === colonChar) {
              el.setAttributeNS(xmlNS, key, value);
            } else if (key.charCodeAt(5) === colonChar && key.slice(0, 5) === xlinkPrefix) {
              el.setAttributeNS(xlinkNS, key, value);
            } else {
              el.setAttribute(key, value);
            }
          }
        }
      }
    }
  };

  // ../utils/src/garfish.ts
  var __LOADER_FLAG__ = Symbol.for("__LOADER_FLAG__");
  var __GARFISH_FLAG__ = Symbol.for("__GARFISH_FLAG__");
  var __MockHtml__ = "__garfishmockhtml__";
  var __MockBody__ = "__garfishmockbody__";
  var __MockHead__ = "__garfishmockhead__";
  var __REMOVE_NODE__ = "__garfishremovenode__";

  // ../utils/src/mimeType.ts
  function parseContentType(input) {
    input = input == null ? void 0 : input.trim();
    if (!input)
      return null;
    let idx = 0;
    let type = "";
    let subType = "";
    while (idx < input.length && input[idx] !== "/") {
      type += input[idx];
      idx++;
    }
    if (type.length === 0 || idx >= input.length) {
      return null;
    }
    idx++;
    while (idx < input.length && input[idx] !== ";") {
      subType += input[idx];
      idx++;
    }
    subType = subType.replace(/[ \t\n\r]+$/, "");
    if (subType.length === 0)
      return null;
    return {
      type: type.toLocaleLowerCase(),
      subtype: subType.toLocaleLowerCase()
    };
  }
  function isCss(mt) {
    return mt ? mt.type === "text" && mt.subtype === "css" : false;
  }
  function isHtml(mt) {
    return mt ? mt.type === "text" && mt.subtype === "html" : false;
  }
  function isJs(mt) {
    const { type, subtype } = mt || {};
    switch (type) {
      case "text": {
        switch (subtype) {
          case "ecmascript":
          case "javascript":
          case "javascript1.0":
          case "javascript1.1":
          case "javascript1.2":
          case "javascript1.3":
          case "javascript1.4":
          case "javascript1.5":
          case "jscript":
          case "livescript":
          case "x-ecmascript":
          case "x-javascript": {
            return true;
          }
          default: {
            return false;
          }
        }
      }
      case "application": {
        switch (subtype) {
          case "ecmascript":
          case "javascript":
          case "x-ecmascript":
          case "x-javascript": {
            return true;
          }
          default: {
            return false;
          }
        }
      }
      default: {
        return false;
      }
    }
  }
  function isJsonp(mt, src) {
    const callbackRegExp = /callback/;
    try {
      const search = new URL(src).search;
      const { type, subtype } = mt || {};
      if (type === "application" && subtype === "json" && callbackRegExp.test(search)) {
        return true;
      }
    } catch (e) {
      return false;
    }
    return false;
  }
  function isJsType({ src = "", type }) {
    if (/\.js$/.test(src))
      return true;
    if (type) {
      if (type === "module")
        return true;
      const mimeTypeInfo = parseContentType(type);
      if (isJsonp(mimeTypeInfo, src))
        return true;
      if (isJs(mimeTypeInfo))
        return true;
    }
    return false;
  }
  function isCssType({ src = "", type }) {
    if (/\.css$/.test(src))
      return true;
    if (type) {
      const mimeTypeInfo = parseContentType(type);
      if (isCss(mimeTypeInfo))
        return true;
    }
    return false;
  }
  function isHtmlType({
    src = "",
    type
  }) {
    if (/\.html$/.test(src))
      return true;
    if (type) {
      const mimeTypeInfo = parseContentType(type);
      if (isHtml(mimeTypeInfo))
        return true;
    }
    return false;
  }
  function isGarfishConfigType({
    type = ""
  }) {
    return /garfish-config/i.test(type);
  }

  // ../utils/src/dispatchEvents.ts
  var reactEvents = [
    "onAbort",
    "onAnimationCancel",
    "onAnimationEnd",
    "onAnimationIteration",
    "onAuxClick",
    "onBlur",
    "onChange",
    "onClick",
    "onClose",
    "onContextMenu",
    "onDoubleClick",
    "onError",
    "onFocus",
    "onGotPointerCapture",
    "onInput",
    "onKeyDown",
    "onKeyPress",
    "onKeyUp",
    "onLoad",
    "onLoadEnd",
    "onLoadStart",
    "onLostPointerCapture",
    "onMouseDown",
    "onMouseMove",
    "onMouseOut",
    "onMouseOver",
    "onMouseUp",
    "onPointerCancel",
    "onPointerDown",
    "onPointerEnter",
    "onPointerLeave",
    "onPointerMove",
    "onPointerOut",
    "onPointerOver",
    "onPointerUp",
    "onReset",
    "onResize",
    "onScroll",
    "onSelect",
    "onSelectionChange",
    "onSelectStart",
    "onSubmit",
    "onTouchCancel",
    "onTouchMove",
    "onTouchStart",
    "onTouchEnd",
    "onTransitionCancel",
    "onTransitionEnd",
    "onDrag",
    "onDragEnd",
    "onDragEnter",
    "onDragExit",
    "onDragLeave",
    "onDragOver",
    "onDragStart",
    "onDrop",
    "onFocusOut"
  ];
  var divergentNativeEvents = {
    onDoubleClick: "dblclick"
  };
  var mimickedReactEvents = {
    onInput: "onChange",
    onFocusOut: "onBlur",
    onSelectionChange: "onSelect"
  };
  function dispatchEvents(shadowRoot) {
    const removeEventListeners = [];
    reactEvents.forEach(function(reactEventName) {
      const nativeEventName = getNativeEventName(reactEventName);
      function retargetEvent(event) {
        const path = event.path || event.composedPath && event.composedPath() || composedPath(event.target);
        for (let i = 0; i < path.length; i++) {
          const el = path[i];
          let props = null;
          const reactComponent = findReactComponent(el);
          const eventHandlers = findReactEventHandlers(el);
          if (!eventHandlers) {
            props = findReactProps(reactComponent);
          } else {
            props = eventHandlers;
          }
          if (reactComponent && props) {
            dispatchEvent(event, reactEventName, props);
          }
          if (reactComponent && props && mimickedReactEvents[reactEventName]) {
            dispatchEvent(event, mimickedReactEvents[reactEventName], props);
          }
          if (event.cancelBubble) {
            break;
          }
          if (el === shadowRoot) {
            break;
          }
        }
      }
      shadowRoot.addEventListener(nativeEventName, retargetEvent, false);
      removeEventListeners.push(function() {
        shadowRoot.removeEventListener(nativeEventName, retargetEvent, false);
      });
    });
    return function() {
      removeEventListeners.forEach(function(removeEventListener) {
        removeEventListener();
      });
    };
  }
  function findReactEventHandlers(item) {
    return findReactProperty(item, "__reactEventHandlers");
  }
  function findReactComponent(item) {
    return findReactProperty(item, "_reactInternal");
  }
  function findReactProperty(item, propertyPrefix) {
    for (const key in item) {
      if (hasOwn(item, key) && key.indexOf(propertyPrefix) !== -1) {
        return item[key];
      }
    }
  }
  function findReactProps(component) {
    if (!component)
      return void 0;
    if (component.memoizedProps)
      return component.memoizedProps;
    if (component._currentElement && component._currentElement.props)
      return component._currentElement.props;
  }
  function dispatchEvent(event, eventType, componentProps) {
    event.persist = function() {
      event.isPersistent = () => true;
    };
    if (componentProps[eventType]) {
      componentProps[eventType](event);
    }
  }
  function getNativeEventName(reactEventName) {
    if (divergentNativeEvents[reactEventName]) {
      return divergentNativeEvents[reactEventName];
    }
    return reactEventName.replace(/^on/, "").toLowerCase();
  }
  function composedPath(el) {
    const path = [];
    while (el) {
      path.push(el);
      if (el.tagName === "HTML") {
        path.push(document);
        path.push(window);
        return path;
      }
      el = el.parentElement;
    }
  }

  // ../utils/src/container.ts
  var appContainerId = "garfish_app_for";
  function createAppContainer(appInfo) {
    let htmlNode = document.createElement("div");
    const appContainer = document.createElement("div");
    if (appInfo.sandbox && appInfo.sandbox.strictIsolation) {
      htmlNode = document.createElement("html");
      const root = appContainer.attachShadow({ mode: "open" });
      root.appendChild(htmlNode);
      dispatchEvents(root);
    } else {
      htmlNode.setAttribute(__MockHtml__, "");
      appContainer.appendChild(htmlNode);
    }
    appContainer.id = `${appContainerId}_${appInfo.name}_${createKey()}`;
    return {
      htmlNode,
      appContainer
    };
  }
  function waitElementReady(selector, callback, leftTime) {
    const timeInterval = 50;
    const elem = document.querySelector(selector);
    if (elem !== null || leftTime <= 0) {
      callback(elem);
      return;
    }
    setTimeout(function() {
      waitElementReady(selector, callback, leftTime - timeInterval);
    }, timeInterval);
  }
  function delay(duration) {
    return new Promise(function(resolve) {
      setTimeout(resolve, duration);
    });
  }
  function waitElement(selector, timeout = 3e3) {
    const waitPromise = new Promise(function(resolve) {
      waitElementReady(selector, function(elem) {
        return resolve(elem);
      }, timeout);
    });
    return Promise.race([delay(timeout), waitPromise]);
  }
  async function getRenderNode(domGetter) {
    assert(domGetter, `Invalid domGetter:
 ${domGetter}.`);
    let appWrapperNode;
    if (typeof domGetter === "string") {
      appWrapperNode = await waitElement(domGetter);
    } else if (typeof domGetter === "function") {
      appWrapperNode = await Promise.resolve(domGetter());
    }
    assert(appWrapperNode instanceof Element, `Invalid domGetter: ${domGetter}`);
    return appWrapperNode;
  }

  // ../utils/src/templateParse.ts
  function Attributes({ name, value }) {
    this.key = name;
    this.value = value;
  }
  var generateAttributes = (el) => {
    const list = [];
    const attrs = el.attributes;
    const len = attrs.length;
    if (len > 0) {
      if (len === 1) {
        list[0] = new Attributes(attrs[0]);
      } else if (len === 2) {
        list[0] = new Attributes(attrs[0]);
        list[1] = new Attributes(attrs[1]);
      } else {
        for (let i = 0; i < len; i++) {
          list[i] = new Attributes(attrs[i]);
        }
      }
    }
    return list;
  };
  var createElement = (el, filter) => {
    switch (el.nodeType) {
      case 3 /* TEXT */:
        return {
          type: "text",
          content: el.textContent
        };
      case 8 /* COMMENT */:
        return {
          type: "comment",
          content: el.textContent
        };
      case 1 /* ELEMENT */:
        return filter({
          type: "element",
          tagName: changeTagNameToLowerCase(el.tagName),
          attributes: generateAttributes(el),
          children: Array.from(el.childNodes).map((node) => {
            return createElement(node, filter);
          })
        });
      default:
        error(`Invalid node type "${el.nodeType}"`);
    }
  };
  function templateParse(code, tags) {
    let astTree = [];
    const htmlNode = document.createElement("html");
    const collectionEls = {};
    const filter = (el) => {
      if (tags.includes(el.tagName)) {
        collectionEls[el.tagName].push(el);
      }
      return el;
    };
    htmlNode.innerHTML = code;
    for (const tag of tags) {
      collectionEls[tag] = [];
    }
    astTree = Array.from(htmlNode.childNodes).map((node) => {
      return createElement(node, filter);
    });
    return [astTree, collectionEls];
  }

  // ../utils/src/logger.ts
  var import_debug = __toESM(require_src());
  var log = (0, import_debug.default)("garfish");
  var coreLog = log.extend("core");
  var routerLog = log.extend("router");

  // ../utils/src/lock.ts
  var Lock = class {
    constructor() {
      this.id = 0;
      this.lockQueue = [];
    }
    genId() {
      return ++this.id;
    }
    getId() {
      return this.id;
    }
    async wait(id2) {
      const { lockQueue } = this;
      const firstLock = lockQueue[0];
      const lastLock = firstLock ? lockQueue[lockQueue.length - 1] : void 0;
      if ((firstLock == null ? void 0 : firstLock.id) === id2)
        return;
      let lockItem = lockQueue.find((item) => item.id === id2);
      if (!lockItem) {
        let promiseResolve = () => {
        };
        const waiting = new Promise((resolve) => {
          promiseResolve = resolve;
        });
        lockItem = { id: id2, waiting, resolve: promiseResolve };
        lockQueue.push(lockItem);
      }
      if (lastLock) {
        await lastLock.waiting;
      }
    }
    release() {
      const { lockQueue } = this;
      const firstLock = lockQueue[0];
      if (!firstLock)
        return;
      lockQueue.shift();
      firstLock.resolve();
    }
    clear() {
      this.lockQueue = [];
    }
  };

  // ../hooks/src/syncHook.ts
  var SyncHook = class {
    constructor(type) {
      this.type = "";
      this.listeners = /* @__PURE__ */ new Set();
      if (type)
        this.type = type;
    }
    on(fn) {
      if (typeof fn === "function") {
        this.listeners.add(fn);
      } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
        warn('Invalid parameter in "Hook".');
      }
    }
    once(fn) {
      const self = this;
      this.on(function wrapper(...args) {
        self.remove(wrapper);
        return fn.apply(null, args);
      });
    }
    emit(...data) {
      if (this.listeners.size > 0) {
        this.listeners.forEach((fn) => fn.apply(null, data));
      }
    }
    remove(fn) {
      return this.listeners.delete(fn);
    }
    removeAll() {
      this.listeners.clear();
    }
  };

  // ../hooks/src/asyncHook.ts
  var AsyncHook = class extends SyncHook {
    emit(...data) {
      let result;
      const ls = Array.from(this.listeners);
      if (ls.length > 0) {
        let i = 0;
        const call = (prev) => {
          if (prev === false) {
            return false;
          } else if (i < ls.length) {
            return Promise.resolve(ls[i++].apply(null, data)).then(call);
          } else {
            return prev;
          }
        };
        result = call();
      }
      return Promise.resolve(result);
    }
  };

  // ../hooks/src/syncWaterfallHook.ts
  function checkReturnData(originData, returnData) {
    if (!isObject(returnData))
      return false;
    if (originData !== returnData) {
      for (const key in originData) {
        if (!(key in returnData)) {
          return false;
        }
      }
    }
    return true;
  }
  var SyncWaterfallHook = class extends SyncHook {
    constructor(type) {
      super();
      this.onerror = error;
      this.type = type;
    }
    emit(data) {
      if (!isObject(data)) {
        error(`"${this.type}" hook response data must be an object.`);
      }
      for (const fn of this.listeners) {
        try {
          const tempData = fn(data);
          if (checkReturnData(data, tempData)) {
            data = tempData;
          } else {
            this.onerror(`The return value of hook "${this.type}" is incorrect.`);
            break;
          }
        } catch (e) {
          (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(e);
          this.onerror(e);
        }
      }
      return data;
    }
  };

  // ../hooks/src/asyncWaterfallHooks.ts
  var AsyncWaterfallHook = class extends SyncHook {
    constructor(type) {
      super();
      this.onerror = error;
      this.type = type;
    }
    emit(data) {
      if (!isObject(data)) {
        error(`"${this.type}" hook response data must be an object.`);
      }
      const ls = Array.from(this.listeners);
      if (ls.length > 0) {
        let i = 0;
        const processError2 = (e) => {
          (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(e);
          this.onerror(e);
          return data;
        };
        const call = (prevData) => {
          if (prevData === false) {
            return false;
          } else if (checkReturnData(data, prevData)) {
            data = prevData;
            if (i < ls.length) {
              try {
                return Promise.resolve(ls[i++](data)).then(call, processError2);
              } catch (e) {
                return processError2(e);
              }
            }
          } else {
            this.onerror(`The return value of hook "${this.type}" is incorrect.`);
          }
          return data;
        };
        return Promise.resolve(call(data));
      }
      return Promise.resolve(data);
    }
  };

  // ../hooks/src/pluginSystem.ts
  var PluginSystem = class {
    constructor(lifecycle) {
      this.registerPlugins = {};
      this.lifecycle = lifecycle;
      this.lifecycleKeys = Object.keys(lifecycle);
    }
    usePlugin(plugin) {
      assert(isPlainObject(plugin), "Invalid plugin configuration.");
      const pluginName = plugin.name;
      assert(pluginName, "Plugin must provide a name.");
      if (!this.registerPlugins[pluginName]) {
        this.registerPlugins[pluginName] = plugin;
        for (const key in this.lifecycle) {
          const pluginLife = plugin[key];
          if (pluginLife) {
            this.lifecycle[key].on(pluginLife);
          }
        }
      } else {
        warn(`Repeat to register plugin hooks "${pluginName}".`);
      }
    }
    removePlugin(pluginName) {
      assert(pluginName, "Must provide a name.");
      const plugin = this.registerPlugins[pluginName];
      assert(plugin, `plugin "${pluginName}" is not registered.`);
      for (const key in plugin) {
        if (key === "name")
          continue;
        this.lifecycle[key].remove(plugin[key]);
      }
    }
    inherit({ lifecycle, registerPlugins }) {
      for (const hookName in lifecycle) {
        assert(!this.lifecycle[hookName], `"${hookName}" hook has conflict and cannot be inherited.`);
        this.lifecycle[hookName] = lifecycle[hookName];
      }
      for (const pluginName in registerPlugins) {
        assert(!this.registerPlugins[pluginName], `"${pluginName}" plugin has conflict and cannot be inherited.`);
        this.usePlugin(registerPlugins[pluginName]);
      }
      return this;
    }
  };

  // ../loader/src/managers/style.ts
  var MATCH_CSS_URL = /url\(\s*(['"])?(.*?)\1\s*\)/g;
  var MATCH_CHARSET_URL = /@charset\s+(['"])(.*?)\1\s*;?/g;
  var MATCH_IMPORT_URL = /@import\s+(['"])(.*?)\1/g;
  var StyleManager = class {
    constructor(styleCode, url) {
      this.depsStack = /* @__PURE__ */ new Set();
      this.scopeData = null;
      this.url = url || null;
      this.styleCode = styleCode;
    }
    correctPath(baseUrl) {
      const { url, styleCode } = this;
      if (!baseUrl)
        baseUrl = url;
      if (baseUrl && typeof styleCode === "string") {
        this.styleCode = styleCode.replace(MATCH_CHARSET_URL, "").replace(MATCH_IMPORT_URL, function(k0, k1, k2) {
          return k2 ? `@import url(${k1}${k2}${k1})` : k0;
        }).replace(MATCH_CSS_URL, (k0, k1, k2) => {
          if (isAbsolute(k2))
            return k0;
          return `url("${baseUrl ? transformUrl(baseUrl, k2) : k2}")`;
        });
      }
    }
    transformCode(code) {
      return code;
    }
    setDep(node) {
      this.depsStack.add(node);
    }
    setScope(data) {
      this.scopeData = data;
    }
    isSameOrigin(node) {
      return this.depsStack.has(node);
    }
    renderAsStyleElement(extraCode = "") {
      const node = document.createElement("style");
      const code = extraCode + (this.styleCode ? this.styleCode : "/**empty style**/");
      node.setAttribute("type", "text/css");
      node.textContent = this.transformCode(code);
      return node;
    }
    clone() {
      const cloned = new this.constructor();
      cloned.url = this.url;
      cloned.styleCode = this.styleCode;
      cloned.scopeData = this.scopeData;
      cloned.depsStack = new Set(this.depsStack);
      return cloned;
    }
  };

  // ../loader/src/managers/module.ts
  var ModuleManager = class {
    constructor(moduleCode, url) {
      this.alias = null;
      this.url = url || null;
      this.moduleCode = moduleCode;
    }
    setAlias(name) {
      if (name && typeof name === "string") {
        this.alias = name;
      }
    }
    clone() {
      const cloned = new this.constructor();
      cloned.url = this.url;
      cloned.alias = this.alias;
      cloned.moduleCode = this.moduleCode;
      return cloned;
    }
  };

  // ../loader/src/managers/template.ts
  var TemplateManager = class {
    constructor(template, url) {
      this.DOMApis = new DOMApis();
      this.astTree = [];
      this.pretreatmentStore = {};
      this.url = url;
      if (template) {
        const [astTree, collectionEls] = templateParse(template, [
          "meta",
          "link",
          "style",
          "script"
        ]);
        this.astTree = astTree;
        this.pretreatmentStore = collectionEls;
      }
    }
    getNodesByTagName(...tags) {
      let counter = 0;
      const collection = {};
      for (const tag of tags) {
        if (this.pretreatmentStore[tag]) {
          counter++;
          collection[tag] = this.pretreatmentStore[tag];
        } else {
          collection[tag] = [];
        }
      }
      if (counter !== tags.length) {
        const traverse = (node) => {
          if (node.type !== "element")
            return;
          if (tags.indexOf(node.tagName) > -1 && !this.pretreatmentStore[node.tagName]) {
            collection[node.tagName].push(node);
          }
          for (const child of node.children)
            traverse(child);
        };
        for (const node of this.astTree)
          traverse(node);
      }
      return collection;
    }
    createElements(renderer, parent, commonRender) {
      const elements = [];
      const traverse = (node, parentEl) => {
        var _a;
        let el;
        if (this.DOMApis.isCommentNode(node)) {
        } else if (this.DOMApis.isText(node)) {
          el = this.DOMApis.createTextNode(node);
          parentEl && parentEl.appendChild(el);
        } else if (this.DOMApis.isNode(node)) {
          const { tagName, children } = node;
          if (typeof commonRender === "function") {
            el = (_a = commonRender(node, parent)) == null ? void 0 : _a.customElement;
          }
          if (!el) {
            if (renderer[tagName]) {
              el = renderer[tagName](node);
            } else {
              el = this.DOMApis.createElement(node);
            }
          }
          if (parentEl && el) {
            parentEl.appendChild(el);
          }
          if (el) {
            const { nodeType, _ignoreChildNodes } = el;
            if (!_ignoreChildNodes && nodeType !== 8 && nodeType !== 10) {
              for (const child of children) {
                traverse(child, el);
              }
            }
          }
        }
        return el;
      };
      for (const node of this.astTree) {
        if (this.DOMApis.isNode(node) && node.tagName !== "!doctype") {
          const el = traverse(node, parent);
          el && elements.push(el);
        }
      }
      return elements;
    }
    toResolveUrl(node, type, baseUrl) {
      var _a;
      const src = (_a = node.attributes) == null ? void 0 : _a.find(({ key }) => key === type);
      if (src && src.value && baseUrl) {
        src.value = transformUrl(baseUrl, src.value);
      }
    }
    ignoreChildNodesCreation(node) {
      if (node) {
        node._ignoreChildNodes = true;
      }
      return node;
    }
    findAllMetaNodes() {
      return this.getNodesByTagName("meta").meta;
    }
    findAllLinkNodes() {
      return this.getNodesByTagName("link").link;
    }
    findAllJsNodes() {
      return this.getNodesByTagName("script").script;
    }
    findAttributeValue(node, type) {
      var _a, _b, _c;
      return (_c = (_b = (_a = node.attributes) == null ? void 0 : _a.find(({ key }) => key === type)) == null ? void 0 : _b.value) != null ? _c : void 0;
    }
    cloneNode(node) {
      return deepMerge(node, {});
    }
    clone() {
      const cloned = new this.constructor();
      cloned.url = this.url;
      cloned.astTree = this.astTree;
      cloned.pretreatmentStore = this.pretreatmentStore;
      cloned.DOMApis = new DOMApis(this.DOMApis.document);
      return cloned;
    }
  };

  // ../loader/src/managers/javascript.ts
  var JavaScriptManager = class {
    constructor(scriptCode, url) {
      this.depsStack = /* @__PURE__ */ new Set();
      this.mimeType = "";
      this.async = false;
      this.defer = false;
      this.url = url;
      this.scriptCode = scriptCode;
    }
    isModule() {
      return this.mimeType === "module";
    }
    isInlineScript() {
      return Boolean(!this.url);
    }
    setMimeType(mimeType) {
      this.mimeType = mimeType || "";
    }
    setAsyncAttribute(val) {
      this.async = Boolean(val);
    }
    setDefferAttribute(val) {
      this.defer = Boolean(val);
    }
    setDep(node) {
      this.depsStack.add(node);
    }
    isSameOrigin(node) {
      return this.depsStack.has(node);
    }
    clone() {
      const cloned = new this.constructor();
      cloned.url = this.url;
      cloned.async = this.async;
      cloned.mimeType = this.mimeType;
      cloned.scriptCode = this.scriptCode;
      cloned.depsStack = new Set(this.depsStack);
      return cloned;
    }
  };

  // ../loader/src/utils.ts
  function getRequest(customFetch) {
    return async function request(url, config) {
      let result = await customFetch.emit(url, config || {});
      if (!result || !(result instanceof Response)) {
        result = await fetch(url, config || {});
      }
      if (result.status >= 400) {
        error(`"${url}" load failed with status "${result.status}"`);
      }
      const code = await result.text();
      const type = result.headers.get("content-type") || "";
      const size = Number(result.headers.get("content-size"));
      const mimeType = parseContentType(type || "");
      return {
        code,
        result,
        mimeType,
        type,
        size: Number.isNaN(size) ? null : size
      };
    };
  }
  function copyResult(result) {
    if (result.resourceManager) {
      result.resourceManager = result.resourceManager.clone();
    }
    return result;
  }
  function mergeConfig(loader, url) {
    const extra = loader.requestConfig;
    const config = typeof extra === "function" ? extra(url) : extra;
    const mode = "cors";
    return __spreadValues({ mode }, config);
  }

  // ../loader/src/appCache.ts
  var cachedDataSet = /* @__PURE__ */ new WeakSet();
  var MAX_SIZE = 1024 * 1024 * 50;
  var DEFAULT_POLL = Symbol("__defaultBufferPoll__");
  var FILE_TYPES = [
    "js" /* js */,
    "css" /* css */,
    "module" /* module */,
    "template" /* template */,
    DEFAULT_POLL
  ];
  var AppCacheContainer = class {
    constructor(maxSize = MAX_SIZE) {
      this.totalSize = 0;
      this.recorder = {};
      this.maxSize = maxSize;
      FILE_TYPES.forEach((key) => {
        this.recorder[key] = 0;
        this[key] = /* @__PURE__ */ new Map();
      });
    }
    bufferPool(type) {
      return this[type];
    }
    has(url) {
      return FILE_TYPES.some((key) => this[key].has(url));
    }
    get(url) {
      for (const key of FILE_TYPES) {
        if (this[key].has(url)) {
          return this[key].get(url);
        }
      }
    }
    set(url, data, type) {
      const curSize = cachedDataSet.has(data) ? 0 : data.size;
      const totalSize = this.totalSize + curSize;
      if (totalSize < this.maxSize) {
        let bar = type;
        let bufferPool = this.bufferPool(type);
        if (!bufferPool) {
          bar = DEFAULT_POLL;
          bufferPool = this.bufferPool(DEFAULT_POLL);
        }
        bufferPool.set(url, data);
        this.totalSize = totalSize;
        this.recorder[bar] += curSize;
        return true;
      }
      return false;
    }
    clear(type) {
      if (typeof type === "string") {
        const cacheBox = this.bufferPool(type);
        if (cacheBox && cacheBox instanceof Map) {
          const size = this.recorder[type];
          this.totalSize -= size;
          this.recorder[type] = 0;
          cacheBox.clear();
        }
      } else {
        FILE_TYPES.forEach((key) => {
          this[key].clear();
          this.recorder[key] = 0;
        });
        this.totalSize = 0;
      }
    }
  };

  // ../loader/src/index.ts
  var CrossOriginCredentials = /* @__PURE__ */ ((CrossOriginCredentials2) => {
    CrossOriginCredentials2["anonymous"] = "same-origin";
    CrossOriginCredentials2["use-credentials"] = "include";
    return CrossOriginCredentials2;
  })(CrossOriginCredentials || {});
  var Loader = class {
    constructor(options) {
      this.personalId = __LOADER_FLAG__;
      this.StyleManager = StyleManager;
      this.ModuleManager = ModuleManager;
      this.TemplateManager = TemplateManager;
      this.JavaScriptManager = JavaScriptManager;
      this.hooks = new PluginSystem({
        error: new SyncHook(),
        loaded: new SyncWaterfallHook("loaded"),
        clear: new SyncWaterfallHook("clear"),
        beforeLoad: new SyncWaterfallHook("beforeLoad"),
        fetch: new AsyncHook("fetch")
      });
      this.options = options || {};
      this.loadingList = /* @__PURE__ */ Object.create(null);
      this.cacheStore = /* @__PURE__ */ Object.create(null);
    }
    setOptions(options) {
      this.options = __spreadValues(__spreadValues({}, this.options), options);
    }
    clear(scope, fileType) {
      const appCacheContainer = this.cacheStore[scope];
      if (appCacheContainer) {
        appCacheContainer.clear(fileType);
        this.hooks.lifecycle.clear.emit({ scope, fileType });
      }
    }
    clearAll(fileType) {
      for (const scope in this.cacheStore) {
        this.clear(scope, fileType);
      }
    }
    usePlugin(options) {
      this.hooks.usePlugin(options);
    }
    setLifeCycle(lifeCycle) {
      this.hooks.usePlugin(__spreadValues({
        name: "loader-lifecycle"
      }, lifeCycle));
    }
    loadModule(url) {
      return this.load({
        scope: "modules",
        url,
        isRemoteModule: true
      });
    }
    async load({
      scope,
      url,
      isRemoteModule = false,
      crossOrigin = "anonymous",
      defaultContentType = ""
    }) {
      const { options, loadingList, cacheStore } = this;
      const res = loadingList[url];
      if (res && Object.keys(res).includes(scope)) {
        return macroTask(res[scope], 4);
      }
      let appCacheContainer = cacheStore[scope];
      if (!appCacheContainer) {
        appCacheContainer = cacheStore[scope] = new AppCacheContainer(options.maxSize);
      }
      if (appCacheContainer.has(url)) {
        return macroTask(copyResult(appCacheContainer.get(url)), 4);
      } else {
        for (const key in cacheStore) {
          const container = cacheStore[key];
          if (container !== appCacheContainer) {
            if (container.has(url)) {
              const result = container.get(url);
              cachedDataSet.add(result);
              appCacheContainer.set(url, result, result.fileType);
              return macroTask(copyResult(result), 4);
            }
          }
        }
      }
      const requestConfig = mergeConfig(this, url);
      requestConfig.credentials = CrossOriginCredentials[crossOrigin];
      const resOpts = this.hooks.lifecycle.beforeLoad.emit({
        url,
        scope,
        requestConfig
      });
      const request = getRequest(this.hooks.lifecycle.fetch);
      const loadRes = request(resOpts.url, resOpts.requestConfig).then(({ code, size, result, type }) => {
        let managerCtor, fileType = "";
        if (isRemoteModule) {
          fileType = "module" /* module */;
          managerCtor = this.ModuleManager;
        } else if (isHtmlType({ type, src: result.url }) || isHtmlType({
          type: defaultContentType
        })) {
          fileType = "template" /* template */;
          managerCtor = this.TemplateManager;
        } else if (isJsType({ type: defaultContentType }) || isJsType({ type, src: result.url })) {
          fileType = "js" /* js */;
          managerCtor = this.JavaScriptManager;
        } else if (isCssType({ src: result.url, type }) || isCssType({
          type: defaultContentType
        })) {
          fileType = "css" /* css */;
          managerCtor = this.StyleManager;
        }
        const resourceManager = managerCtor ? new managerCtor(code, result.url) : null;
        const data = this.hooks.lifecycle.loaded.emit({
          result,
          value: {
            url,
            scope,
            resourceManager,
            fileType: fileType || "",
            size: size || code.length,
            code: resourceManager ? "" : code
          }
        });
        fileType && appCacheContainer.set(url, data.value, fileType);
        return copyResult(data.value);
      }).catch((e) => {
        (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && error(e);
        this.hooks.lifecycle.error.emit(e, { scope });
        throw e;
      }).finally(() => {
      });
      loadingList[url] ? loadingList[url][scope] = loadRes : loadingList[url] = { [scope]: loadRes };
      return loadRes;
    }
  };

  // ../core/src/garfish.ts
  var import_eventemitter2 = __toESM(require_eventemitter2());

  // ../core/src/config.ts
  var filterAppConfigKeys = {
    beforeBootstrap: true,
    bootstrap: true,
    beforeRegisterApp: true,
    registerApp: true,
    beforeLoad: true,
    afterLoad: true,
    errorLoadApp: true,
    appID: true,
    apps: true,
    disableStatistics: true,
    disablePreloadApp: true,
    plugins: true,
    autoRefreshApp: true,
    onNotMatchRouter: true,
    loader: true
  };
  var deepMergeConfig = (globalConfig, localConfig) => {
    const _a = globalConfig, { props: globalProps } = _a, newGlobalConfig = __objRest(_a, ["props"]);
    const _b = localConfig, { props: localProps } = _b, newLocalConfig = __objRest(_b, ["props"]);
    const props = __spreadValues(__spreadValues({}, globalProps || {}), localProps || {});
    const result = deepMerge(filterUndefinedVal(newGlobalConfig), filterUndefinedVal(newLocalConfig));
    return __spreadProps(__spreadValues({}, result), {
      props
    });
  };
  var getAppConfig = (globalConfig, localConfig) => {
    const mergeResult = deepMergeConfig(globalConfig, localConfig);
    Object.keys(mergeResult).forEach((key) => {
      if (filterAppConfigKeys[key]) {
        delete mergeResult[key];
      }
    });
    return mergeResult;
  };
  var generateAppOptions = (appName, garfish, options) => {
    let appInfo = garfish.appInfos[appName] || { name: appName };
    appInfo = getAppConfig(garfish.options, __spreadProps(__spreadValues(__spreadValues({}, appInfo), options), {
      props: __spreadValues(__spreadValues({}, appInfo.props || {}), (options == null ? void 0 : options.props) || {})
    }));
    return appInfo;
  };
  var createDefaultOptions = () => {
    const config = {
      appID: "",
      apps: [],
      autoRefreshApp: true,
      disableStatistics: false,
      disablePreloadApp: false,
      basename: "/",
      props: {},
      asyncProviderTimeout: 2e3,
      domGetter: () => document.createElement("div"),
      sandbox: {
        snapshot: false,
        fixBaseUrl: false,
        fixStaticResourceBaseUrl: true,
        disableWith: false,
        strictIsolation: false,
        disableElementtiming: false,
        fixOwnerDocument: false
      },
      beforeLoad: () => {
      },
      afterLoad: () => {
      },
      errorLoadApp: (e) => error(e),
      onNotMatchRouter: () => {
      },
      beforeEval: () => {
      },
      afterEval: () => {
      },
      beforeMount: () => {
      },
      afterMount: () => {
      },
      beforeUnmount: () => {
      },
      afterUnmount: () => {
      },
      errorMountApp: (e) => error(e),
      errorUnmountApp: (e) => error(e),
      customLoader: void 0
    };
    return config;
  };

  // ../core/src/lifecycle.ts
  function globalLifecycle() {
    return new PluginSystem({
      beforeBootstrap: new SyncHook(),
      bootstrap: new SyncHook(),
      beforeRegisterApp: new SyncHook(),
      registerApp: new SyncHook(),
      beforeLoad: new AsyncHook(),
      afterLoad: new AsyncHook(),
      errorLoadApp: new SyncHook()
    });
  }
  function appLifecycle() {
    return new PluginSystem({
      beforeEval: new SyncHook(),
      afterEval: new SyncHook(),
      beforeMount: new SyncHook(),
      afterMount: new SyncHook(),
      errorMountApp: new SyncHook(),
      beforeUnmount: new SyncHook(),
      afterUnmount: new SyncHook(),
      errorUnmountApp: new SyncHook(),
      errorExecCode: new SyncHook(),
      customRender: new SyncWaterfallHook("customRender")
    });
  }

  // ../../node_modules/.pnpm/@alioth-org+es-module-lexer@1.1.0/node_modules/@alioth-org/es-module-lexer/dist/lexer.js
  var A = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  function parse(E2, g = "@") {
    if (!C)
      return init().then(() => parse(E2));
    const I = E2.length + 1, K = (C.__heap_base.value || C.__heap_base) + 4 * I - C.memory.buffer.byteLength;
    K > 0 && C.memory.grow(Math.ceil(K / 65536));
    const k = C.sa(I - 1);
    if ((A ? B : Q)(E2, new Uint16Array(C.memory.buffer, k, I)), !C.parse())
      throw Object.assign(new Error(`Parse error ${g}:${E2.slice(0, C.e()).split("\n").length}:${C.e() - E2.lastIndexOf("\n", C.e() - 1)}`), { idx: C.e() });
    const o = [], D = [];
    for (; C.ri(); ) {
      const A2 = C.is(), Q2 = C.ie(), B2 = C.ai(), g2 = C.id(), I2 = C.ss(), K2 = C.se();
      let k2;
      C.ip() && (k2 = w(E2.slice(g2 === -1 ? A2 - 1 : A2, g2 === -1 ? Q2 + 1 : Q2))), o.push({ n: k2, s: A2, e: Q2, ss: I2, se: K2, d: g2, a: B2 });
    }
    for (; C.re(); ) {
      const A2 = C.es(), Q2 = C.ee(), B2 = C.els(), g2 = C.ele(), I2 = E2.slice(A2, Q2), K2 = I2[0], k2 = B2 < 0 ? void 0 : E2.slice(B2, g2), o2 = k2 ? k2[0] : "";
      D.push({ s: A2, e: Q2, ls: B2, le: g2, n: K2 === '"' || K2 === "'" ? w(I2) : I2, ln: o2 === '"' || o2 === "'" ? w(k2) : k2 });
    }
    function w(A2) {
      try {
        return (0, eval)(A2);
      } catch (A3) {
      }
    }
    return [o, D, !!C.f()];
  }
  function Q(A2, Q2) {
    const B2 = A2.length;
    let C2 = 0;
    for (; C2 < B2; ) {
      const B3 = A2.charCodeAt(C2);
      Q2[C2++] = (255 & B3) << 8 | B3 >>> 8;
    }
  }
  function B(A2, Q2) {
    const B2 = A2.length;
    let C2 = 0;
    for (; C2 < B2; )
      Q2[C2] = A2.charCodeAt(C2++);
  }
  var C;
  var E;
  var init = () => {
    var A2;
    return E || (E = WebAssembly.compile((A2 = "AGFzbQEAAAABKghgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gAn9/AAMtLAABAQICAgICAgICAgICAgICAgIAAwMDBAQAAAADAAAAAAMDBQYAAAcABgIFBAUBcAEBAQUDAQABBg8CfwFBsPIAC38AQbDyAAsHcBMGbWVtb3J5AgACc2EAAAFlAAMCaXMABAJpZQAFAnNzAAYCc2UABwJhaQAIAmlkAAkCaXAACgJlcwALAmVlAAwDZWxzAA0DZWxlAA4CcmkADwJyZQAQAWYAEQVwYXJzZQASC19faGVhcF9iYXNlAwEKsjssaAEBf0EAIAA2AvgJQQAoAtQJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgL8CUEAIAA2AoAKQQBBADYC2AlBAEEANgLoCUEAQQA2AuAJQQBBADYC3AlBAEEANgLwCUEAQQA2AuQJIAELnwEBA39BACgC6AkhBEEAQQAoAoAKIgU2AugJQQAgBDYC7AlBACAFQSBqNgKACiAEQRxqQdgJIAQbIAU2AgBBACgCzAkhBEEAKALICSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGGyAEIANGGzYCDCAFIAM2AhQgBUEANgIQIAUgAjYCBCAFQQA2AhwgBUEAKALICSADRjoAGAtWAQF/QQAoAvAJIgRBEGpB3AkgBBtBACgCgAoiBDYCAEEAIAQ2AvAJQQAgBEEUajYCgAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKECgsVAEEAKALgCSgCAEEAKALUCWtBAXULHgEBf0EAKALgCSgCBCIAQQAoAtQJa0EBdUF/IAAbCxUAQQAoAuAJKAIIQQAoAtQJa0EBdQseAQF/QQAoAuAJKAIMIgBBACgC1AlrQQF1QX8gABsLHgEBf0EAKALgCSgCECIAQQAoAtQJa0EBdUF/IAAbCzsBAX8CQEEAKALgCSgCFCIAQQAoAsgJRw0AQX8PCwJAIABBACgCzAlHDQBBfg8LIABBACgC1AlrQQF1CwsAQQAoAuAJLQAYCxUAQQAoAuQJKAIAQQAoAtQJa0EBdQsVAEEAKALkCSgCBEEAKALUCWtBAXULHgEBf0EAKALkCSgCCCIAQQAoAtQJa0EBdUF/IAAbCx4BAX9BACgC5AkoAgwiAEEAKALUCWtBAXVBfyAAGwslAQF/QQBBACgC4AkiAEEcakHYCSAAGygCACIANgLgCSAAQQBHCyUBAX9BAEEAKALkCSIAQRBqQdwJIAAbKAIAIgA2AuQJIABBAEcLCABBAC0AiAoL5gwBBn8jAEGA0ABrIgAkAEEAQQE6AIgKQQBBACgC0Ak2ApAKQQBBACgC1AlBfmoiATYCpApBACABQQAoAvgJQQF0aiICNgKoCkEAQQA7AYoKQQBBADsBjApBAEEAOgCUCkEAQQA2AoQKQQBBADoA9AlBACAAQYAQajYCmApBACAANgKcCkEAQQA6AKAKAkACQAJAAkADQEEAIAFBAmoiAzYCpAogASACTw0BAkAgAy8BACICQXdqQQVJDQACQAJAAkACQAJAIAJBm39qDgUBCAgIAgALIAJBIEYNBCACQS9GDQMgAkE7Rg0CDAcLQQAvAYwKDQEgAxATRQ0BIAFBBGpBgghBChArDQEQFEEALQCICg0BQQBBACgCpAoiATYCkAoMBwsgAxATRQ0AIAFBBGpBjAhBChArDQAQFQtBAEEAKAKkCjYCkAoMAQsCQCABLwEEIgNBKkYNACADQS9HDQQQFgwBC0EBEBcLQQAoAqgKIQJBACgCpAohAQwACwtBACECIAMhAUEALQD0CQ0CDAELQQAgATYCpApBAEEAOgCICgsDQEEAIAFBAmoiAzYCpAoCQAJAAkACQAJAAkACQAJAAkAgAUEAKAKoCk8NACADLwEAIgJBd2pBBUkNCAJAAkACQAJAAkACQAJAAkACQAJAIAJBYGoOChIRBhEREREFAQIACwJAAkACQAJAIAJBoH9qDgoLFBQDFAEUFBQCAAsgAkGFf2oOAwUTBgkLQQAvAYwKDRIgAxATRQ0SIAFBBGpBgghBChArDRIQFAwSCyADEBNFDREgAUEEakGMCEEKECsNERAVDBELIAMQE0UNECABKQAEQuyAhIOwjsA5Ug0QIAEvAQwiA0F3aiIBQRdLDQ5BASABdEGfgIAEcUUNDgwPC0EAQQAvAYwKIgFBAWo7AYwKQQAoApgKIAFBA3RqIgFBATYCACABQQAoApAKNgIEDA8LQQAvAYwKIgJFDQtBACACQX9qIgQ7AYwKQQAvAYoKIgJFDQ4gAkECdEEAKAKcCmpBfGooAgAiBSgCFEEAKAKYCiAEQf//A3FBA3RqKAIERw0OAkAgBSgCBA0AIAUgAzYCBAtBACACQX9qOwGKCiAFIAFBBGo2AgwMDgsCQEEAKAKQCiIBLwEAQSlHDQBBACgC6AkiA0UNACADKAIEIAFHDQBBAEEAKALsCSIDNgLoCQJAIANFDQAgA0EANgIcDAELQQBBADYC2AkLQQBBAC8BjAoiA0EBajsBjApBACgCmAogA0EDdGoiA0EGQQJBAC0AoAobNgIAIAMgATYCBEEAQQA6AKAKDA0LQQAvAYwKIgFFDQlBACABQX9qIgE7AYwKQQAoApgKIAFB//8DcUEDdGooAgBBBEYNBAwMC0EnEBgMCwtBIhAYDAoLIAJBL0cNCQJAAkAgAS8BBCIBQSpGDQAgAUEvRw0BEBYMDAtBARAXDAsLAkACQEEAKAKQCiIBLwEAIgMQGUUNAAJAAkAgA0FVag4EAAgBAwgLIAFBfmovAQBBK0YNBgwHCyABQX5qLwEAQS1GDQUMBgsCQCADQf0ARg0AIANBKUcNBUEAKAKYCkEALwGMCkEDdGooAgQQGkUNBQwGC0EAKAKYCkEALwGMCkEDdGoiAigCBBAbDQUgAigCAEEGRg0FDAQLIAFBfmovAQBBUGpB//8DcUEKSQ0DDAQLQQAoApgKQQAvAYwKIgFBA3QiA2pBACgCkAo2AgRBACABQQFqOwGMCkEAKAKYCiADakEDNgIACxAcDAcLQQAtAPQJQQAvAYoKQQAvAYwKcnJFIQIMCQsgARAdDQAgA0UNACADQS9GQQAtAJQKQQBHcQ0AIAFBfmohAUEAKALUCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApAKIAEvAQAhAyABQX5qIgQhASADEB5FDQALIARBAmohBAtBASEFIANB//8DcRAfRQ0BIARBfmohAQJAA0AgAUECaiIDIAJNDQFBACABNgKQCiABLwEAIQMgAUF+aiIEIQEgAxAfDQALIARBAmohAwsgAxAgRQ0BECFBAEEAOgCUCgwFCxAhQQAhBQtBACAFOgCUCgwDCxAiQQAhAgwFCyADQaABRw0BC0EAQQE6AKAKC0EAQQAoAqQKNgKQCgtBACgCpAohAQwACwsgAEGA0ABqJAAgAgsdAAJAQQAoAtQJIABHDQBBAQ8LIABBfmovAQAQHgvFCgEHf0EAQQAoAqQKIgBBDGoiATYCpApBACgC8AkhAkEBECYhAwJAAkACQAJAAkACQAJAQQAoAqQKIgQgAUcNACADECVFDQELAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKkCkEBECYhBEEAKAKkCiEBA0ACQAJAIARB//8DcSIDQSJGDQAgA0EnRg0AIAMQKBpBACgCpAohAwwBCyADEBhBAEEAKAKkCkECaiIDNgKkCgtBARAmGgJAIAEgAxApIgRBLEcNAEEAQQAoAqQKQQJqNgKkCkEBECYhBAtBACgCpAohAyAEQf0ARg0DIAMgAUYNCiADIQEgA0EAKAKoCk0NAAwKCwtBACAEQQJqNgKkCkEBECYaQQAoAqQKIgMgAxApGgwCC0EAQQA6AIgKAkACQAJAAkACQAJAIANBn39qDgwCCAQBCAMICAgICAUACyADQfYARg0EDAcLQQAgBEEOaiIANgKkCkHhACEDAkBBARAmIgJB4QBHDQBBACEBQQAoAqQKIgIQE0UNCyACKQACQvOA5IPgjcAxUg0LIAIvAQoQH0UNC0EAIAJBCmo2AqQKQQAQJiECC0HmACEDQQAhASACQeYARw0JQQAhAUEAKAKkCiICEBNFDQogAkECakGkCEEOECsNCiACLwEQIgVBd2oiBkEXSw0HQQEgBnRBn4CABHFFDQcMCAtBACAEQQpqNgKkCkEBECYaQQAoAqQKIQQLQQAgBEEQajYCpAoCQEEBECYiBEEqRw0AQQBBACgCpApBAmo2AqQKQQEQJiEEC0EAKAKkCiEDIAQQKBogA0EAKAKkCiIEIAMgBBACQQBBACgCpApBfmo2AqQKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQHkUNAEEAIARBCmo2AqQKQQEQJiEEQQAoAqQKIQMgBBAoGiADQQAoAqQKIgQgAyAEEAJBAEEAKAKkCkF+ajYCpAoPC0EAIARBBGoiBDYCpAoLQQAgBEEEaiIDNgKkCkEAQQA6AIgKAkADQEEAIANBAmo2AqQKQQEQJiEEQQAoAqQKIQMgBBAoQSByQfsARg0BQQAoAqQKIgQgA0YNBCADIAQgAyAEEAJBARAmQSxHDQFBACgCpAohAwwACwtBAEEAKAKkCkF+ajYCpAoPC0EAIANBAmo2AqQKC0EBECYhBEEAKAKkCiEDAkAgBEHmAEcNACADQQJqQZ4IQQYQKw0AQQAgA0EIajYCpAogAEEBECYQJyACQRBqQdwJIAIbIQMDQCADKAIAIgNFDQIgA0IANwIIIANBEGohAwwACwtBACADQX5qNgKkCgsPCwJAIAVBWGoOAwEDAQALIAVBoAFHDQILQQAgAkEQajYCpApBASEBAkBBARAmIgJBKkcNAEEAQQAoAqQKQQJqNgKkCkEBECYhAgsgAkEoRw0AIAQgAEEAQQAQAkEAIARBDGo2AqQKDwtB4wAhAwJAIAJB4wBGDQAgAiEDDAELQQAoAqQKIgIQE0UNACACKQACQuyAhIOwjsA5Ug0AAkACQCACLwEKIgVBd2oiBkEXSw0AQQEgBnRBn4CABHENAQsgBUGgAUYNACAFQfsARw0BC0EAIAJBCmo2AqQKQQEhAUEBECYiA0H7AEcNACAEIABBAEEAEAJBACAEQQxqNgKkCg8LQQAoAqQKIQIgAxAoGgJAAkAgAUUNAEEAKAKkCiIDIAJNDQAgBCAAIAIgAxACQQAoAqQKQX5qIQMMAQsgBCAAQQBBABACIARBDGohAwtBACADNgKkCg8LECILvgYBBH9BAEEAKAKkCiIAQQxqIgE2AqQKAkACQAJAAkACQAJAAkACQAJAAkBBARAmIgJBWWoOCAQCAQQBAQEDAAsgAkEiRg0DIAJB+wBGDQQLQQAoAqQKIAFHDQJBACAAQQpqNgKkCg8LQQAoApgKQQAvAYwKIgJBA3RqIgFBACgCpAo2AgRBACACQQFqOwGMCiABQQU2AgBBACgCkAovAQBBLkYNA0EAQQAoAqQKIgFBAmo2AqQKQQEQJiECIABBACgCpApBACABEAFBAEEALwGKCiIBQQFqOwGKCkEAKAKcCiABQQJ0akEAKALoCTYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKkCkF+ajYCpAoPCyACEBhBAEEAKAKkCkECaiICNgKkCgJAAkACQEEBECZBV2oOBAECAgACC0EAQQAoAqQKQQJqNgKkCkEBECYaQQAoAugJIgEgAjYCBCABQQE6ABggAUEAKAKkCiICNgIQQQAgAkF+ajYCpAoPC0EAKALoCSIBIAI2AgQgAUEBOgAYQQBBAC8BjApBf2o7AYwKIAFBACgCpApBAmo2AgxBAEEALwGKCkF/ajsBigoPC0EAQQAoAqQKQX5qNgKkCg8LQQBBACgCpApBAmo2AqQKQQEQJkHtAEcNAkEAKAKkCiICQQJqQZYIQQYQKw0CQQAoApAKLwEAQS5GDQIgACAAIAJBCGpBACgCzAkQAQ8LQQAvAYwKDQJBACgCpAohAkEAKAKoCiEDA0AgAiADTw0FAkACQCACLwEAIgFBJ0YNACABQSJHDQELIAAgARAnDwtBACACQQJqIgI2AqQKDAALC0EAKAKkCiECQQAvAYwKDQICQANAAkACQAJAIAJBACgCqApPDQBBARAmIgJBIkYNASACQSdGDQEgAkH9AEcNAkEAQQAoAqQKQQJqNgKkCgtBARAmGkEAKAKkCiICKQAAQuaAyIPwjcA2Ug0HQQAgAkEIajYCpApBARAmIgJBIkYNAyACQSdGDQMMBwsgAhAYC0EAQQAoAqQKQQJqIgI2AqQKDAALCyAAIAIQJwsPC0EAQQAoAqQKQX5qNgKkCg8LQQAgAkF+ajYCpAoPCxAiC0cBA39BACgCpApBAmohAEEAKAKoCiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AqQKC5gBAQN/QQBBACgCpAoiAUECajYCpAogAUEGaiEBQQAoAqgKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AqQKDAELIAFBfmohAQtBACABNgKkCg8LIAFBAmohAQwACwuIAQEEf0EAKAKkCiEBQQAoAqgKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKkChAiDwtBACABNgKkCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQZgJQQUQIw0AIABBoglBAxAjDQAgAEGoCUECECMhAQsgAQuDAQECf0EBIQECQAJAAkACQAJAAkAgAC8BACICQUVqDgQFBAQBAAsCQCACQZt/ag4EAwQEAgALIAJBKUYNBCACQfkARw0DIABBfmpBtAlBBhAjDwsgAEF+ai8BAEE9Rg8LIABBfmpBrAlBBBAjDwsgAEF+akHACUEDECMPC0EAIQELIAEL3gEBBH9BACgCpAohAEEAKAKoCiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2AqQKQQBBAC8BjAoiAkEBajsBjApBACgCmAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCpApBAEEALwGMCkF/aiIAOwGMCkEAKAKYCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2AqQKCxAiCwu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQbwIQQIQIw8LIABBfGpBwAhBAxAjDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAkDwsgAEF6akHjABAkDwsgAEF8akHGCEEEECMPCyAAQXxqQc4IQQYQIw8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB2ghBBhAjDwsgAEF4akHmCEECECMPCyAAQX5qQeoIQQQQIw8LQQEhASAAQX5qIgBB6QAQJA0EIABB8ghBBRAjDwsgAEF+akHkABAkDwsgAEF+akH8CEEHECMPCyAAQX5qQYoJQQQQIw8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAkDwsgAEF8akGSCUEDECMhAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAlcSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akHqCEEEECMPCyAAQX5qLwEAQfUARw0AIABBfGpBzghBBhAjIQELIAELcAECfwJAAkADQEEAQQAoAqQKIgBBAmoiATYCpAogAEEAKAKoCk8NAQJAAkACQCABLwEAIgFBpX9qDgIBAgALAkAgAUF2ag4EBAMDBAALIAFBL0cNAgwECxAqGgwBC0EAIABBBGo2AqQKDAALCxAiCws1AQF/QQBBAToA9AlBACgCpAohAEEAQQAoAqgKQQJqNgKkCkEAIABBACgC1AlrQQF1NgKECgtJAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC1AkiBUkNACAAIAEgAhArDQACQCAAIAVHDQBBAQ8LIAQvAQAQHiEDCyADCz0BAn9BACECAkBBACgC1AkiAyAASw0AIAAvAQAgAUcNAAJAIAMgAEcNAEEBDwsgAEF+ai8BABAeIQILIAILaAECf0EBIQECQAJAIABBX2oiAkEFSw0AQQEgAnRBMXENAQsgAEH4/wNxQShGDQAgAEFGakH//wNxQQZJDQACQCAAQaV/aiICQQNLDQAgAkEBRw0BCyAAQYV/akH//wNxQQRJIQELIAELnAEBA39BACgCpAohAQJAA0ACQAJAIAEvAQAiAkEvRw0AAkAgAS8BAiIBQSpGDQAgAUEvRw0EEBYMAgsgABAXDAELAkACQCAARQ0AIAJBd2oiAUEXSw0BQQEgAXRBn4CABHFFDQEMAgsgAhAfRQ0DDAELIAJBoAFHDQILQQBBACgCpAoiA0ECaiIBNgKkCiADQQAoAqgKSQ0ACwsgAgvCAwEBfwJAIAFBIkYNACABQSdGDQAQIg8LQQAoAqQKIQIgARAYIAAgAkECakEAKAKkCkEAKALICRABQQBBACgCpApBAmo2AqQKQQAQJiEAQQAoAqQKIQECQAJAIABB4QBHDQAgAUECakGyCEEKECtFDQELQQAgAUF+ajYCpAoPC0EAIAFBDGo2AqQKAkBBARAmQfsARg0AQQAgATYCpAoPC0EAKAKkCiICIQADQEEAIABBAmo2AqQKAkACQAJAQQEQJiIAQSJGDQAgAEEnRw0BQScQGEEAQQAoAqQKQQJqNgKkCkEBECYhAAwCC0EiEBhBAEEAKAKkCkECajYCpApBARAmIQAMAQsgABAoIQALAkAgAEE6Rg0AQQAgATYCpAoPC0EAQQAoAqQKQQJqNgKkCgJAQQEQJiIAQSJGDQAgAEEnRg0AQQAgATYCpAoPCyAAEBhBAEEAKAKkCkECajYCpAoCQAJAQQEQJiIAQSxGDQAgAEH9AEYNAUEAIAE2AqQKDwtBAEEAKAKkCkECajYCpApBARAmQf0ARg0AQQAoAqQKIQAMAQsLQQAoAugJIgEgAjYCECABQQAoAqQKQQJqNgIMC20BAn8CQAJAA0ACQCAAQf//A3EiAUF3aiICQRdLDQBBASACdEGfgIAEcQ0CCyABQaABRg0BIAAhAiABECUNAkEAIQJBAEEAKAKkCiIAQQJqNgKkCiAALwECIgANAAwCCwsgACECCyACQf//A3ELqwEBBH8CQAJAQQAoAqQKIgIvAQAiA0HhAEYNACABIQQgACEFDAELQQAgAkEEajYCpApBARAmIQJBACgCpAohBQJAAkAgAkEiRg0AIAJBJ0YNACACECgaQQAoAqQKIQQMAQsgAhAYQQBBACgCpApBAmoiBDYCpAoLQQEQJiEDQQAoAqQKIQILAkAgAiAFRg0AIAUgBEEAIAAgACABRiICG0EAIAEgAhsQAgsgAwtyAQR/QQAoAqQKIQBBACgCqAohAQJAAkADQCAAQQJqIQIgACABTw0BAkACQCACLwEAIgNBpH9qDgIBBAALIAIhACADQXZqDgQCAQECAQsgAEEEaiEADAALC0EAIAI2AqQKECJBAA8LQQAgAjYCpApB3QALSQEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIAFBAWohASAAQQFqIQAgAkF/aiICDQAMAgsLIAQgBWshAwsgAwsL5AECAEGACAvGAQAAeABwAG8AcgB0AG0AcABvAHIAdABlAHQAYQBmAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGYAbwByAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABByAkLEAEAAAACAAAAAAQAADA5AAA=", typeof Buffer != "undefined" ? Buffer.from(A2, "base64") : Uint8Array.from(atob(A2), (A3) => A3.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A3 }) => {
      C = A3;
    })), E;
  };

  // ../core/src/module/esModule.ts
  var __GARFISH_ESM_ENV__ = "__GARFISH_ESM_ENV__";
  var getModuleImportProcessor = (code) => {
    let finalCode = "";
    let resetCode = code;
    let prevCodeIndex = 0;
    const rawImport = "import";
    const wrapImport = "_import_";
    return (importAnalysis, newModuleName = "") => {
      const { d: importType, n: moduleName, s, e, ss, se } = importAnalysis;
      const isDynamicImport = importType > -1;
      if (isDynamicImport) {
        const codeStart = ss - prevCodeIndex;
        const codeEnd = se - prevCodeIndex;
        const dynamicImportStatement = resetCode.slice(codeStart, codeEnd);
        finalCode += resetCode.slice(0, codeStart);
        finalCode += dynamicImportStatement.replace(rawImport, wrapImport);
        resetCode = resetCode.slice(codeEnd);
        prevCodeIndex = se;
      } else if (moduleName) {
        const codeStart = s - prevCodeIndex;
        const codeEnd = e - prevCodeIndex;
        finalCode += resetCode.slice(0, codeStart);
        finalCode += newModuleName;
        resetCode = resetCode.slice(codeEnd);
        prevCodeIndex = e;
      }
      return [finalCode, resetCode];
    };
  };
  var genShellExecutionCode = (id2, sourceModuleName, shellUrl) => `;import*as m$$_${id2} from'${sourceModuleName}';import{u$$_ as u$$_${id2}}from'${shellUrl}';u$$_${id2}(m$$_${id2})`;
  var ESModuleLoader = class {
    constructor(app) {
      this.moduleCache = {};
      this.lock = new Lock();
      this.app = app;
      this.globalVarKey = `${__GARFISH_ESM_ENV__}_${this.app.appId}`;
    }
    execModuleCode(blobUrl) {
      const result = (0, eval)(`import('${blobUrl}')`);
      this.lock.release();
      return result;
    }
    createBlobUrl(code) {
      return URL.createObjectURL(new Blob([code], { type: "text/javascript" }));
    }
    setBlobUrl(saveId, blobUrl) {
      this.moduleCache[saveId].blobUrl = blobUrl;
    }
    async fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, saveUrl, requestUrl) {
      const { resourceManager } = await this.app.context.loader.load({
        scope: this.app.name,
        url: requestUrl
      });
      if (resourceManager) {
        let sourcemap = "";
        let { url, scriptCode } = resourceManager;
        if (!haveSourcemap(scriptCode)) {
          sourcemap = await createSourcemap(scriptCode, requestUrl);
        }
        scriptCode = await this.analysisModule(lockId, scriptCode, envVarStr, noEntryEnvVarStr, saveUrl, url);
        const blobUrl = this.createBlobUrl(`import.meta.url='${url}';${this.app.isNoEntryScript(url) ? noEntryEnvVarStr : envVarStr}${scriptCode}
${sourcemap}`);
        this.setBlobUrl(saveUrl, blobUrl);
      }
    }
    getUrl(referUrl, targetUrl) {
      return !isAbsolute(targetUrl) && referUrl ? transformUrl(referUrl, targetUrl) : targetUrl;
    }
    preloadStaticModuleAsync(analysis, realUrl) {
      const [imports] = analysis;
      for (let i = 0, length = imports.length; i < length; i++) {
        const importAnalysis = imports[i];
        const { d: importType, n: moduleName } = importAnalysis;
        const isDynamicImport = importType > -1;
        if (moduleName && !isDynamicImport) {
          this.app.context.loader.load({
            scope: this.app.name,
            url: this.getUrl(realUrl, moduleName)
          });
        }
      }
    }
    async analysisModule(lockId, code, envVarStr, noEntryEnvVarStr, baseUrl, realUrl) {
      await this.lock.wait(lockId);
      await init();
      const analysis = parse(code, realUrl || "");
      const thisModule = {
        analysis,
        source: code
      };
      if (baseUrl) {
        this.moduleCache[baseUrl] = thisModule;
      }
      let result = ["", code];
      let shellExecutionCode = "";
      const dynamicImport = `var _import_=(url)=>window.${this.globalVarKey}.import(url,'${baseUrl}','${realUrl}');`;
      const processImportModule = getModuleImportProcessor(code);
      const [imports] = analysis;
      this.preloadStaticModuleAsync(analysis, realUrl);
      for (let i = 0, length = imports.length; i < length; i++) {
        const importAnalysis = imports[i];
        const { d: importType, n: moduleName } = importAnalysis;
        const isDynamicImport = importType > -1;
        let saveUrl = moduleName || "";
        let newModuleName = "";
        if (moduleName && !isDynamicImport) {
          const requestUrl = this.getUrl(realUrl, moduleName);
          saveUrl = this.getUrl(baseUrl, moduleName);
          let currentModule = this.moduleCache[saveUrl];
          if (currentModule && !currentModule.blobUrl) {
            if (!currentModule.shellUrl) {
              const [currentModuleImports, currentModuleExports] = currentModule.analysis;
              const wildcardExports = currentModuleImports.filter((importItem) => {
                const statement = currentModule.source.substring(importItem.ss, importItem.se);
                return /^export\s*\*\s*from\s*/.test(statement);
              });
              const wildcardExportStatements = [];
              for (let j = 0, l = wildcardExports.length; j < l; j++) {
                const wildcardExport = wildcardExports[j];
                const wildcardExportUrl = wildcardExport.n || "";
                const wildcardExportSaveUrl = this.getUrl(baseUrl, wildcardExportUrl);
                await this.fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, wildcardExportSaveUrl, this.getUrl(realUrl, wildcardExportUrl));
                const wildcardModule = this.moduleCache[wildcardExportSaveUrl];
                if (wildcardModule == null ? void 0 : wildcardModule.blobUrl) {
                  wildcardExportStatements.push(`export * from '${wildcardModule.blobUrl}'`);
                }
              }
              currentModule.shellUrl = this.createBlobUrl(`export function u$$_(m){${currentModuleExports.map((exportSpecifier) => exportSpecifier.n === "default" ? "d$$_=m.default" : `${exportSpecifier.n}=m.${exportSpecifier.n}`).join(",")}}${currentModuleExports.map((exportSpecifier) => exportSpecifier.n === "default" ? "let d$$_;export{d$$_ as default}" : `export let ${exportSpecifier.n}`).join(";")}${wildcardExportStatements.length ? `;${wildcardExportStatements.join(";")}` : ""}
//# sourceURL=${saveUrl}?cycle`);
            }
            newModuleName = currentModule.shellUrl;
          } else if (!currentModule) {
            await this.fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, saveUrl, requestUrl);
            currentModule = this.moduleCache[saveUrl];
            const { blobUrl, shellUrl, shellExecuted } = currentModule;
            newModuleName = blobUrl;
            if (shellUrl && !shellExecuted) {
              shellExecutionCode += genShellExecutionCode(i, newModuleName, shellUrl);
              currentModule.shellExecuted = true;
            }
          } else {
            newModuleName = currentModule.blobUrl;
          }
        }
        result = processImportModule(importAnalysis, newModuleName || moduleName);
      }
      thisModule.source = "";
      delete thisModule.analysis;
      return `${dynamicImport}${shellExecutionCode};${result.join("")}`;
    }
    destroy() {
      for (const key in this.moduleCache) {
        const { blobUrl, shellUrl } = this.moduleCache[key];
        if (blobUrl) {
          URL.revokeObjectURL(blobUrl);
        }
        if (shellUrl) {
          URL.revokeObjectURL(shellUrl);
        }
      }
      this.moduleCache = {};
      this.lock.clear();
      delete this.app.global[this.globalVarKey];
    }
    load(code, env, url, options) {
      return new Promise(async (resolve) => {
        if (url && this.moduleCache[url]) {
          return resolve();
        }
        const genShellCodeWrapper = (blobUrl2, shellUrl, sourceUrl) => {
          return `export * from '${blobUrl2}'${genShellExecutionCode(0, blobUrl2, shellUrl)}
//# sourceURL=${sourceUrl}?cycle`;
        };
        env = __spreadProps(__spreadValues({}, env), {
          resolve,
          import: async (moduleId, baseUrl, realUrl) => {
            let saveUrl = moduleId;
            let requestUrl = moduleId;
            if (!isAbsolute(moduleId)) {
              saveUrl = transformUrl(baseUrl, moduleId);
              requestUrl = transformUrl(realUrl, moduleId);
            }
            let targetModule = this.moduleCache[saveUrl];
            if (!(targetModule == null ? void 0 : targetModule.blobUrl)) {
              await this.fetchModuleResource(this.lock.genId(), envVarStr, noEntryEnvVarStr, saveUrl, requestUrl);
              targetModule = this.moduleCache[saveUrl];
            }
            if (targetModule && targetModule.shellUrl && !targetModule.shellExecuted && targetModule.blobUrl) {
              return this.execModuleCode(this.createBlobUrl(genShellCodeWrapper(targetModule.blobUrl, targetModule.shellUrl, saveUrl)));
            }
            return this.execModuleCode(targetModule.blobUrl);
          }
        });
        const genEnvVarStr = (targetEnv, noEntry) => {
          const newEnv = __spreadValues({}, targetEnv);
          if (noEntry) {
            delete newEnv.exports;
            delete newEnv.module;
          }
          return Object.keys(newEnv).reduce((prevCode, name) => {
            if (name === "resolve" || name === "import")
              return prevCode;
            return `${prevCode} var ${name} = window.${this.globalVarKey}.${name};`;
          }, "");
        };
        const envVarStr = genEnvVarStr(env);
        const noEntryEnvVarStr = genEnvVarStr(env, true);
        let sourcemap = "";
        if (!haveSourcemap(code) && url) {
          sourcemap = await createSourcemap(code, options && options.isInline ? `index.html(inline.${this.app.scriptCount}.js)` : url);
        }
        code = await this.analysisModule(this.lock.genId(), code, envVarStr, noEntryEnvVarStr, url, url);
        code = `import.meta.url='${url}';${(options == null ? void 0 : options.noEntry) ? noEntryEnvVarStr : envVarStr}${code}
;window.${this.globalVarKey}.resolve();
${sourcemap}`;
        this.app.global[this.globalVarKey] = env;
        let blobUrl = this.createBlobUrl(code);
        if (options && !options.isInline && url) {
          this.setBlobUrl(url, blobUrl);
        }
        const currentModule = this.moduleCache[url || ""];
        if ((currentModule == null ? void 0 : currentModule.shellUrl) && !currentModule.shellExecuted) {
          blobUrl = this.createBlobUrl(genShellCodeWrapper(blobUrl, currentModule.shellUrl, url || ""));
        }
        this.execModuleCode(blobUrl);
      });
    }
  };

  // ../core/src/module/app.ts
  var appId = 0;
  var __GARFISH_GLOBAL_ENV__ = "__GARFISH_GLOBAL_ENV__";
  var __GARFISH_EXPORTS__ = "__GARFISH_EXPORTS__";
  var App = class {
    constructor(context, appInfo, entryManager, resources, isHtmlMode, customLoader) {
      this.appId = appId++;
      this.scriptCount = 0;
      this.display = false;
      this.mounted = false;
      this.mounting = false;
      this.strictIsolation = false;
      this.esmQueue = new Queue();
      this.esModuleLoader = new ESModuleLoader(this);
      this.global = window;
      this.customExports = {};
      this.sourceList = [];
      this.sourceListMap = /* @__PURE__ */ new Map();
      this.childGarfishConfig = {};
      this.active = false;
      this.unmounting = false;
      this.deferNodeMap = /* @__PURE__ */ new Map();
      var _a;
      this.context = context;
      this.appInfo = appInfo;
      this.name = appInfo.name;
      this.resources = resources;
      this.isHtmlMode = isHtmlMode;
      this.entryManager = entryManager;
      this.appInfo.appId = this.appId;
      this.globalEnvVariables = {
        currentApp: this,
        loader: context.loader,
        externals: context.externals,
        remoteModulesCode: resources.modules
      };
      this.cjsModules = {
        exports: {},
        module: null,
        require: (key) => {
          const pkg = this.global[key] || context.externals[key] || window[key];
          if (!pkg) {
            warn(`Package "${key}" is not found`);
          }
          return pkg;
        }
      };
      this.cjsModules.module = this.cjsModules;
      this.customLoader = customLoader;
      this.hooks = appLifecycle();
      this.hooks.usePlugin(__spreadProps(__spreadValues({}, appInfo), {
        name: `${appInfo.name}-lifecycle`
      }));
      const nodes = entryManager.getNodesByTagName(...sourceListTags);
      for (const key in nodes) {
        nodes[key].forEach((node) => {
          var _a2, _b;
          const url = entryManager.findAttributeValue(node, "href") || entryManager.findAttributeValue(node, "src");
          if (url) {
            this.addSourceList({
              tagName: node.tagName,
              url: entryManager.url ? transformUrl(entryManager.url, url) : url
            });
          }
          if (isGarfishConfigType({
            type: entryManager.findAttributeValue(node, "type")
          })) {
            this.childGarfishConfig = JSON.parse((_b = (_a2 = node.children) == null ? void 0 : _a2[0]) == null ? void 0 : _b.content);
          }
        });
      }
      this.appInfo.entry && this.addSourceList({ tagName: "html", url: this.appInfo.entry });
      this.asyncProviderTimeout = (_a = this.appInfo.asyncProviderTimeout) != null ? _a : 0;
    }
    get rootElement() {
      return findTarget(this.htmlNode, [`div[${__MockBody__}]`, "body"]);
    }
    get getSourceList() {
      return this.sourceList;
    }
    addSourceList(sourceInfo) {
      if (this.appInfo.disableSourceListCollect)
        return;
      if (Array.isArray(sourceInfo)) {
        const nSourceList = sourceInfo.filter((item) => {
          const url = getSourceURL(item.url);
          if (!this.sourceListMap.has(url) && url.startsWith("http")) {
            this.sourceListMap.set(url, item);
            return true;
          }
          return false;
        });
        this.sourceList = this.sourceList.concat(nSourceList);
      } else {
        const url = getSourceURL(sourceInfo.url);
        if (!this.sourceListMap.get(url) && url.startsWith("http")) {
          this.sourceList.push(sourceInfo);
          this.sourceListMap.set(url, sourceInfo);
        }
      }
    }
    initAsyncProviderRegistration() {
      const { asyncProviderTimeout, customExports } = this;
      if (asyncProviderTimeout) {
        customExports.registerProvider = (provider) => {
          var _a;
          this.asyncProvider = provider;
          (_a = this.resolveAsyncProvider) == null ? void 0 : _a.call(this);
        };
      }
    }
    awaitAsyncProviderRegistration() {
      return new Promise((resolve) => {
        if (this.asyncProvider) {
          resolve(this.asyncProvider);
          return;
        }
        const timeoutId = setTimeout(() => {
          resolve(this.asyncProvider);
        }, this.asyncProviderTimeout);
        this.resolveAsyncProvider = () => {
          clearTimeout(timeoutId);
          resolve(this.asyncProvider);
        };
      });
    }
    getProvider() {
      return this.provider ? Promise.resolve(this.provider) : this.checkAndGetProvider();
    }
    isNoEntryScript(url = "") {
      var _a, _b;
      return (_b = (_a = this.childGarfishConfig.sandbox) == null ? void 0 : _a.noEntryScripts) == null ? void 0 : _b.some((item) => url.indexOf(item) > -1);
    }
    execScript(code, env, url, options) {
      env = __spreadValues(__spreadValues({}, this.getExecScriptEnv(options == null ? void 0 : options.noEntry)), env || {});
      this.scriptCount++;
      const args = [this.appInfo, code, env, url, options];
      this.hooks.lifecycle.beforeEval.emit(...args);
      try {
        this.runCode(code, env, url, options);
      } catch (err) {
        this.hooks.lifecycle.errorExecCode.emit(err, ...args);
        throw err;
      }
      this.hooks.lifecycle.afterEval.emit(...args);
    }
    runCode(code, env, url, options) {
      if (options && options.isModule) {
        this.esmQueue.add(async (next) => {
          await this.esModuleLoader.load(code, __spreadValues(__spreadValues({}, this.getExecScriptEnv()), env), url, options);
          next();
        });
      } else {
        const revertCurrentScript = setDocCurrentScript(this.global.document, code, true, url, options == null ? void 0 : options.async, options == null ? void 0 : options.defer, options == null ? void 0 : options.originScript);
        code += url ? `
//# sourceURL=${url}
` : "";
        if (!hasOwn(env, "window")) {
          env = __spreadProps(__spreadValues({}, env), {
            window: this.global
          });
        }
        evalWithEnv(`;${code}`, env, this.global);
        Promise.resolve().then(revertCurrentScript);
      }
    }
    async show() {
      this.active = true;
      const { display, mounted, provider } = this;
      if (display)
        return false;
      if (!mounted) {
        (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn('Need to call the "app.mount()" method first.');
        return false;
      }
      this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, true);
      this.context.activeApps.push(this);
      await this.addContainer();
      this.callRender(provider, false);
      this.display = true;
      this.hooks.lifecycle.afterMount.emit(this.appInfo, this, true);
      return true;
    }
    hide() {
      this.active = false;
      this.mounting = false;
      const { display, mounted, provider } = this;
      if (!display)
        return false;
      if (!mounted) {
        (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn('Need to call the "app.mount()" method first.');
        return false;
      }
      this.hooks.lifecycle.beforeUnmount.emit(this.appInfo, this, true);
      this.callDestroy(provider, false);
      this.display = false;
      remove(this.context.activeApps, this);
      this.hooks.lifecycle.afterUnmount.emit(this.appInfo, this, true);
      return true;
    }
    async mount() {
      if (!this.canMount())
        return false;
      this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, false);
      this.active = true;
      this.mounting = true;
      try {
        this.context.activeApps.push(this);
        this.initAsyncProviderRegistration();
        const { asyncScripts, deferScripts } = await this.compileAndRenderContainer();
        if (!this.stopMountAndClearEffect())
          return false;
        deferScripts();
        const provider = await this.getProvider();
        if (!this.stopMountAndClearEffect())
          return false;
        this.callRender(provider, true);
        this.display = true;
        this.mounted = true;
        this.hooks.lifecycle.afterMount.emit(this.appInfo, this, false);
        await asyncScripts;
        if (!this.stopMountAndClearEffect())
          return false;
      } catch (e) {
        this.entryManager.DOMApis.removeElement(this.appContainer);
        this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);
        return false;
      } finally {
        this.mounting = false;
      }
      return true;
    }
    unmount() {
      this.active = false;
      this.mounting = false;
      if (!this.mounted || !this.appContainer) {
        return false;
      }
      if (this.unmounting) {
        (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(`The ${this.name} app unmounting.`);
        return false;
      }
      this.unmounting = true;
      this.hooks.lifecycle.beforeUnmount.emit(this.appInfo, this, false);
      try {
        this.callDestroy(this.provider, true);
        this.display = false;
        this.mounted = false;
        this.provider = void 0;
        this.customExports = {};
        this.cjsModules.exports = {};
        this.esModuleLoader.destroy();
        remove(this.context.activeApps, this);
        this.hooks.lifecycle.afterUnmount.emit(this.appInfo, this, false);
      } catch (e) {
        remove(this.context.activeApps, this);
        this.entryManager.DOMApis.removeElement(this.appContainer);
        this.hooks.lifecycle.errorUnmountApp.emit(e, this.appInfo);
        return false;
      } finally {
        this.unmounting = false;
      }
      return true;
    }
    getExecScriptEnv(noEntry) {
      const envs = {
        [__GARFISH_EXPORTS__]: this.customExports,
        [__GARFISH_GLOBAL_ENV__]: this.globalEnvVariables
      };
      if (noEntry) {
        return __spreadProps(__spreadValues({}, envs), {
          require: this.cjsModules.require
        });
      }
      return __spreadValues(__spreadValues({}, envs), this.cjsModules);
    }
    async compileAndRenderContainer() {
      await this.renderTemplate();
      const execScript = (type) => {
        for (const jsManager of this.resources.js) {
          if (jsManager[type]) {
            try {
              let noEntry = false;
              const targetUrl = jsManager.url || this.appInfo.entry;
              if (type === "defer") {
                const node = this.deferNodeMap.get(jsManager);
                if (node) {
                  noEntry = toBoolean(this.entryManager.findAttributeValue(node, "no-entry"));
                }
                if (!noEntry) {
                  noEntry = toBoolean(this.isNoEntryScript(targetUrl));
                }
              }
              this.execScript(jsManager.scriptCode, {}, targetUrl, {
                noEntry,
                defer: type === "defer",
                async: type === "async",
                isModule: jsManager.isModule(),
                isInline: jsManager.isInlineScript()
              });
            } catch (e) {
              if (type !== "defer") {
                this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);
              } else {
                throw e;
              }
            }
          }
        }
      };
      return {
        deferScripts: () => execScript("defer"),
        asyncScripts: new Promise((resolve) => {
          setTimeout(() => {
            if (this.stopMountAndClearEffect()) {
              execScript("async");
            }
            resolve();
          });
        })
      };
    }
    canMount() {
      if (this.mounting) {
        (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(`The ${this.appInfo.name} app mounting.`);
        return false;
      }
      if (this.mounted) {
        (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(`The ${this.appInfo.name} app already mounted.`);
        return false;
      }
      if (this.unmounting) {
        (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(`The ${this.appInfo.name} app is unmounting can't Perform application rendering.`);
        return false;
      }
      return true;
    }
    stopMountAndClearEffect() {
      if (!this.active) {
        if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          warn(`The app "${this.name}" rendering process has been blocked.`);
        }
        this.mounting = false;
        if (this.appContainer) {
          this.entryManager.DOMApis.removeElement(this.appContainer);
        }
        coreLog(`${this.appInfo.name} id:${this.appId} stopMountAndClearEffect`, this.appContainer);
        return false;
      }
      return true;
    }
    callRender(provider, isMount) {
      if (provider && provider.render) {
        provider.render({
          appName: this.appInfo.name,
          dom: this.rootElement,
          basename: this.appInfo.basename,
          appRenderInfo: { isMount },
          props: this.appInfo.props
        });
      }
    }
    callDestroy(provider, isUnmount) {
      const { rootElement, appContainer } = this;
      if (provider && provider.destroy) {
        provider.destroy({
          appName: this.appInfo.name,
          dom: rootElement,
          appRenderInfo: { isUnmount },
          props: this.appInfo.props
        });
      }
      this.entryManager.DOMApis.removeElement(appContainer);
    }
    async addContainer() {
      const wrapperNode = await getRenderNode(this.appInfo.domGetter);
      if (typeof wrapperNode.appendChild === "function") {
        wrapperNode.appendChild(this.appContainer);
      }
    }
    async renderTemplate() {
      const { appInfo, entryManager, resources } = this;
      const { url: baseUrl, DOMApis: DOMApis2 } = entryManager;
      const { htmlNode, appContainer } = createAppContainer(appInfo);
      const fixStaticResourceBaseUrl = !this.appInfo.sandbox || this.appInfo.sandbox && this.appInfo.sandbox.fixStaticResourceBaseUrl === true;
      this.htmlNode = htmlNode;
      this.appContainer = appContainer;
      await this.addContainer();
      const customRenderer = {
        meta: () => null,
        img: (node) => {
          fixStaticResourceBaseUrl && baseUrl && entryManager.toResolveUrl(node, "src", baseUrl);
          return DOMApis2.createElement(node);
        },
        video: (node) => {
          fixStaticResourceBaseUrl && baseUrl && entryManager.toResolveUrl(node, "src", baseUrl);
          return DOMApis2.createElement(node);
        },
        audio: (node) => {
          fixStaticResourceBaseUrl && baseUrl && entryManager.toResolveUrl(node, "src", baseUrl);
          return DOMApis2.createElement(node);
        },
        iframe: (node) => {
          fixStaticResourceBaseUrl && baseUrl && entryManager.toResolveUrl(node, "src", baseUrl);
          return DOMApis2.createElement(node);
        },
        body: (node) => {
          if (!this.strictIsolation) {
            node = entryManager.cloneNode(node);
            node.tagName = "div";
            node.attributes.push({
              key: __MockBody__,
              value: null
            });
          }
          return DOMApis2.createElement(node);
        },
        head: (node) => {
          if (!this.strictIsolation) {
            node = entryManager.cloneNode(node);
            node.tagName = "div";
            node.attributes.push({
              key: __MockHead__,
              value: null
            });
          }
          return DOMApis2.createElement(node);
        },
        script: (node) => {
          const mimeType = entryManager.findAttributeValue(node, "type");
          const isModule2 = mimeType === "module";
          if (mimeType) {
            if (!isModule2 && !isJsType({ type: mimeType })) {
              return DOMApis2.createElement(node);
            }
          }
          const jsManager = resources.js.find((manager) => {
            return !manager.async ? manager.isSameOrigin(node) : false;
          });
          if (jsManager) {
            if (jsManager.defer) {
              this.deferNodeMap.set(jsManager, node);
            } else {
              const { url, scriptCode } = jsManager;
              const mockOriginScript = document.createElement("script");
              node.attributes.forEach((attribute) => {
                if (attribute.key) {
                  mockOriginScript.setAttribute(attribute.key, attribute.value || "");
                }
              });
              const targetUrl = url || this.appInfo.entry;
              this.execScript(scriptCode, {}, targetUrl, {
                isModule: isModule2,
                async: false,
                defer: false,
                isInline: jsManager.isInlineScript(),
                noEntry: toBoolean(entryManager.findAttributeValue(node, "no-entry")) || toBoolean(this.isNoEntryScript(targetUrl)),
                originScript: mockOriginScript
              });
            }
          } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
            const async = entryManager.findAttributeValue(node, "async");
            if (typeof async === "undefined" || async === "false") {
              const tipInfo = JSON.stringify(node, null, 2);
              warn(`Current js node cannot be found, the resource may not exist.

 ${tipInfo}`);
            }
          }
          return DOMApis2.createScriptCommentNode(node);
        },
        style: (node) => {
          const text = node.children[0];
          if (text) {
            const styleManager = new this.context.loader.StyleManager(text.content, baseUrl);
            styleManager.setScope({
              appName: this.name,
              rootElId: this.appContainer.id
            });
            baseUrl && styleManager.correctPath(baseUrl);
            return entryManager.ignoreChildNodesCreation(styleManager.renderAsStyleElement());
          }
          return DOMApis2.createElement(node);
        },
        link: (node) => {
          if (DOMApis2.isCssLinkNode(node)) {
            const styleManager = this.resources.link.find((manager) => manager.isSameOrigin(node));
            if (styleManager) {
              styleManager.setScope({
                appName: this.name,
                rootElId: this.appContainer.id
              });
              return styleManager.renderAsStyleElement((typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) ? `
/*${DOMApis2.createLinkCommentNode(node)}*/
` : "");
            }
          }
          return DOMApis2.isPrefetchJsLinkNode(node) ? DOMApis2.createScriptCommentNode(node) : DOMApis2.isIconLinkNode(node) ? null : DOMApis2.createElement(node);
        }
      };
      entryManager.createElements(customRenderer, htmlNode, (node, parent) => {
        return this.hooks.lifecycle.customRender.emit({
          node,
          parent,
          app: this,
          customElement: null
        });
      });
    }
    async checkAndGetProvider() {
      const { appInfo, rootElement, cjsModules, customExports } = this;
      const { name, props, basename } = appInfo;
      let provider = void 0;
      await this.esmQueue.awaitCompletion();
      if (cjsModules.exports) {
        if (isPromise(cjsModules.exports))
          cjsModules.exports = await cjsModules.exports;
        if (cjsModules.exports.provider)
          provider = cjsModules.exports.provider;
      }
      if (customExports.provider) {
        provider = customExports.provider;
      }
      if (this.asyncProviderTimeout && !provider) {
        provider = await this.awaitAsyncProviderRegistration();
      }
      if (typeof provider === "function") {
        provider = await provider(__spreadValues({
          basename,
          dom: rootElement
        }, props || {}), props);
      } else if (isPromise(provider)) {
        provider = await provider;
      }
      if (!isObject(provider) && typeof provider !== "function") {
        warn(` Invalid module content: ${name}, you should return both render and destroy functions in provider function.`);
      }
      const hookRes = await (this.customLoader && this.customLoader(provider, appInfo, basename));
      if (hookRes) {
        const { mount, unmount } = hookRes || {};
        if (typeof mount === "function" && typeof unmount === "function") {
          provider.render = mount;
          provider.destroy = unmount;
        }
      }
      if (!appInfo.noCheckProvider) {
        assert(provider, `"provider" is "${provider}".`);
        assert("render" in provider, '"render" is required in provider.');
        assert("destroy" in provider, '"destroy" is required in provider.');
      }
      this.provider = provider;
      return provider;
    }
  };

  // ../core/src/module/resource.ts
  function fetchStaticResources(appName, loader, entryManager) {
    const toBoolean2 = (val) => typeof val !== "undefined" && val !== "false";
    const jsNodes = Promise.all(entryManager.findAllJsNodes().map((node) => {
      const src = entryManager.findAttributeValue(node, "src");
      const type = entryManager.findAttributeValue(node, "type");
      let crossOrigin = entryManager.findAttributeValue(node, "crossorigin");
      if (crossOrigin === "") {
        crossOrigin = "anonymous";
      }
      if (src) {
        const fetchUrl = entryManager.url ? transformUrl(entryManager.url, src) : src;
        const async = entryManager.findAttributeValue(node, "async");
        const defer = entryManager.findAttributeValue(node, "defer");
        return loader.load({
          scope: appName,
          url: fetchUrl,
          crossOrigin,
          defaultContentType: type
        }).then(({ resourceManager: jsManager }) => {
          if (jsManager) {
            jsManager.setDep(node);
            type && jsManager.setMimeType(type);
            jsManager.setAsyncAttribute(toBoolean2(async));
            jsManager.setDefferAttribute(toBoolean2(defer));
            return jsManager;
          } else {
            warn(`[${appName}] Failed to load script: ${fetchUrl}`);
          }
        }).catch(() => null);
      } else if (node.children.length > 0) {
        const code = node.children[0].content;
        if (code) {
          const jsManager = new loader.JavaScriptManager(code, "");
          jsManager.setDep(node);
          type && jsManager.setMimeType(type);
          return jsManager;
        }
      }
    }).filter(Boolean));
    const linkNodes = Promise.all(entryManager.findAllLinkNodes().map((node) => {
      if (!entryManager.DOMApis.isCssLinkNode(node))
        return;
      const href = entryManager.findAttributeValue(node, "href");
      if (href) {
        const fetchUrl = entryManager.url ? transformUrl(entryManager.url, href) : href;
        return loader.load({ scope: appName, url: fetchUrl }).then(({ resourceManager: styleManager }) => {
          if (styleManager) {
            styleManager.setDep(node);
            styleManager == null ? void 0 : styleManager.correctPath();
            return styleManager;
          } else {
            warn(`${appName} Failed to load link: ${fetchUrl}`);
          }
        }).catch(() => null);
      }
    }).filter(Boolean));
    const metaNodes = Promise.all(entryManager.findAllMetaNodes().map((node) => {
      if (!entryManager.DOMApis.isRemoteModule(node))
        return;
      const async = entryManager.findAttributeValue(node, "async");
      const alias = entryManager.findAttributeValue(node, "alias");
      if (!toBoolean2(async)) {
        const src = entryManager.findAttributeValue(node, "src");
        if (src) {
          return loader.loadModule(src).then(({ resourceManager: moduleManager }) => {
            if (moduleManager && alias) {
              moduleManager && moduleManager.setAlias(alias);
            }
            return moduleManager;
          }).catch(() => null);
        }
      } else if (alias) {
        warn(`Asynchronous loading module, the alias "${alias}" is invalid.`);
      }
    }).filter(Boolean));
    return Promise.all([jsNodes, linkNodes, metaNodes]).then((ls) => ls.map((ns2) => ns2.filter(Boolean)));
  }
  async function processAppResources(loader, appInfo) {
    let isHtmlMode = false, fakeEntryManager;
    const resources = { js: [], link: [], modules: [] };
    assert(appInfo.entry, `[${appInfo.name}] Entry is not specified.`);
    const { resourceManager: entryManager } = await loader.load({
      scope: appInfo.name,
      url: transformUrl(location.href, appInfo.entry)
    });
    if (entryManager instanceof loader.TemplateManager) {
      isHtmlMode = true;
      const [js, link, modules] = await fetchStaticResources(appInfo.name, loader, entryManager);
      resources.js = js;
      resources.link = link;
      resources.modules = modules;
    } else if (entryManager instanceof loader.JavaScriptManager) {
      isHtmlMode = false;
      const mockTemplateCode = `<script src="${entryManager.url}"><\/script>`;
      fakeEntryManager = new loader.TemplateManager(mockTemplateCode, entryManager.url);
      entryManager.setDep(fakeEntryManager.findAllJsNodes()[0]);
      resources.js = [entryManager];
    } else {
      error(`Entrance wrong type of resource of "${appInfo.name}".`);
    }
    return [fakeEntryManager || entryManager, resources, isHtmlMode];
  }

  // ../core/src/plugins/fixHMR.ts
  function GarfishHMRPlugin() {
    let hasInit = false;
    let isHotUpdate = false;
    return function(Garfish2) {
      return {
        name: "fix-hmr",
        version: "1.17.5",
        bootstrap() {
          if (hasInit)
            return;
          hasInit = true;
          let webpackHotUpdateName = "webpackHotUpdate";
          let webpackHotUpdate = window[webpackHotUpdateName];
          for (const i in window) {
            if (i.includes("webpackHotUpdate")) {
              webpackHotUpdateName = i;
              webpackHotUpdate = window[i];
            }
          }
          if (typeof webpackHotUpdate === "function") {
            window[webpackHotUpdateName] = function() {
              isHotUpdate = true;
              return webpackHotUpdate.apply(this, arguments);
            };
            const observer = new MutationObserver(() => {
              if (!isHotUpdate)
                return;
              isHotUpdate = false;
              Garfish2.activeApps.forEach((app) => {
                if (app.mounted) {
                  setTimeout(() => {
                    app.display && app.hide();
                    app.show();
                  });
                }
              });
            });
            observer.observe(document.documentElement, {
              subtree: true,
              childList: true,
              attributes: true
            });
          }
        }
      };
    };
  }

  // ../core/src/plugins/lifecycle.ts
  function GarfishOptionsLife(options, name) {
    return function() {
      return __spreadValues({
        name,
        version: "1.17.5"
      }, options);
    };
  }

  // ../core/src/plugins/preload.ts
  var storageKey = "__garfishPreloadApp__";
  var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  var requestQueue = new Queue();
  var isSlowNetwork = () => navigator.connection ? navigator.connection.saveData || /(2|3)g/.test(navigator.connection.effectiveType) : false;
  var requestIdleCallback = typeof idleCallback !== "function" ? window.setTimeout : idleCallback;
  function safeLoad({
    loader,
    appName,
    url,
    isModule: isModule2,
    immediately,
    callback
  }) {
    const generateSuccess = (next = () => {
    }) => ({ resourceManager }) => {
      callback && callback(resourceManager);
      setTimeout(next, 500);
    };
    const generateThrowWarn = (next = () => {
    }) => (e) => {
      if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
        warn(e);
        warn(`Preload failed. "${url}"`);
      }
      next();
    };
    const loadResource = (next = () => {
    }) => {
      const throwWarn = generateThrowWarn(next);
      const success = generateSuccess(next);
      try {
        if (isModule2) {
          loader.loadModule(url).then(success, throwWarn);
        } else {
          loader.load({ scope: appName, url }).then(success, throwWarn);
        }
      } catch (e) {
        throwWarn(e);
        next();
      }
    };
    if (immediately) {
      loadResource();
    } else {
      requestQueue.add((next) => {
        requestIdleCallback(() => loadResource(next));
      });
    }
  }
  function loadAppResource(loader, info, immediately = false) {
    false;
    const fetchUrl = transformUrl(location.href, info.entry);
    safeLoad({
      loader,
      appName: info.name,
      url: fetchUrl,
      isModule: false,
      immediately,
      callback: (manager) => {
        const loadStaticResource = () => {
          if (manager instanceof TemplateManager) {
            const baseUrl = manager.url;
            const jsNodes = manager.findAllJsNodes();
            const linkNodes = manager.findAllLinkNodes();
            const metaNodes = manager.findAllMetaNodes();
            if (jsNodes) {
              jsNodes.forEach((node) => {
                const src = manager.findAttributeValue(node, "src");
                src && safeLoad({
                  loader,
                  appName: info.name,
                  url: baseUrl ? transformUrl(baseUrl, src) : src,
                  isModule: false,
                  immediately
                });
              });
            }
            if (linkNodes) {
              linkNodes.forEach((node) => {
                if (manager.DOMApis.isCssLinkNode(node)) {
                  const href = manager.findAttributeValue(node, "href");
                  href && safeLoad({
                    loader,
                    appName: info.name,
                    url: baseUrl ? transformUrl(baseUrl, href) : href,
                    isModule: false,
                    immediately
                  });
                }
              });
            }
            if (metaNodes) {
              metaNodes.forEach((node) => {
                if (manager.DOMApis.isRemoteModule(node)) {
                  const src = manager.findAttributeValue(node, "src");
                  if (src && isAbsolute(src)) {
                    safeLoad({
                      loader,
                      appName: info.name,
                      url: src,
                      isModule: true,
                      immediately
                    });
                  } else {
                    warn(`The loading of the remote module must be an absolute path. "${src}"`);
                  }
                }
              });
            }
          }
        };
        if (immediately) {
          loadStaticResource();
        } else {
          requestIdleCallback(loadStaticResource);
        }
      }
    });
  }
  function getRanking() {
    const str = localStorage.getItem(storageKey);
    if (str) {
      const data = JSON.parse(str);
      return data.sort((a, b) => b.count - a.count);
    }
    return [];
  }
  function setRanking(appName) {
    const str = localStorage.getItem(storageKey);
    const newCurrent = { appName, count: 1 };
    if (!str) {
      safeWrapper(() => localStorage.setItem(storageKey, JSON.stringify([newCurrent])));
    } else {
      const data = JSON.parse(str);
      const current = data.find((app) => app.appName === appName);
      current ? current.count++ : data.push(newCurrent);
      safeWrapper(() => localStorage.setItem(storageKey, JSON.stringify(data)));
    }
  }
  var loadedMap = /* @__PURE__ */ Object.create(null);
  function GarfishPreloadPlugin() {
    return function(Garfish2) {
      Garfish2.preloadApp = (appName) => {
        if (loadedMap[appName]) {
          return;
        }
        loadedMap[appName] = true;
        loadAppResource(Garfish2.loader, Garfish2.appInfos[appName], true);
      };
      return {
        name: "preload",
        version: "1.17.5",
        beforeLoad(appInfo) {
          if (Garfish2.options.disablePreloadApp) {
            return;
          }
          setRanking(appInfo.name);
        },
        registerApp(appInfos) {
          if (Garfish2.options.disablePreloadApp) {
            return;
          }
          setTimeout(() => {
            if (isMobile || isSlowNetwork())
              return;
            const ranking = getRanking();
            for (const { appName } of ranking) {
              if (appInfos[appName] && !loadedMap[appName]) {
                loadedMap[appName] = true;
                loadAppResource(Garfish2.loader, appInfos[appName]);
              }
            }
            for (const key in appInfos) {
              if (!loadedMap[key]) {
                loadAppResource(Garfish2.loader, appInfos[key]);
              }
            }
          }, false ? 0 : 5e3);
        }
      };
    };
  }

  // ../core/src/plugins/performance/subAppObserver.ts
  var SubAppObserver = class {
    constructor(options) {
      this.observer = new MutationObserver(this._mutationObserverCallback.bind(this));
      this.subAppBeforeLoadTime = 0;
      this.subAppBeforeMountTime = 0;
      this.subAppStartPageShowTime = 0;
      this.subAppPageShowTime = 0;
      this.entry = "";
      this.observeTimer = 0;
      this.dataTimer = 0;
      this.domQuerySelector = options.subAppRootSelector;
      this.config = { attributes: true, childList: true, subtree: true };
      this.targetSubscriber = [];
      this.timeLag = options.domObserverMaxTime || 3e3;
      this.reportTimeLag = options.waitSubAppNotifyMaxTime || 1e4;
      this.isRecordFinish = false;
      this.cbEntryList = [];
      this.isStartShowFlag = true;
      this.isCallBackFinish = false;
      this.isSubAppNotifyFinish = false;
      this.finishAction = "";
      this.performanceData = {
        resourceLoadTime: 0,
        blankScreenTime: 0,
        firstScreenTime: 0,
        isFirstRender: true,
        entry: "",
        action: ""
      };
    }
    subscribePerformanceData(callback) {
      try {
        this.targetSubscriber.push(callback);
      } catch (e) {
        warn(e);
      }
    }
    subscribePerformanceDataOnce(callback) {
      try {
        const wrapCallback = (performanceData) => {
          callback(performanceData);
          this.unsubscribePerformanceData(wrapCallback);
        };
        this.targetSubscriber.push(wrapCallback);
      } catch (e) {
        warn(e);
      }
    }
    unsubscribePerformanceData(callback) {
      try {
        this.targetSubscriber = this.targetSubscriber.filter((sub) => sub === callback);
      } catch (e) {
        warn(e);
      }
    }
    subAppBeforeLoad(entry) {
      this.entry = entry;
      this.isRecordFinish = false;
      this.isSubAppNotifyFinish = false;
      this.subAppBeforeLoadTime = performance.now();
      this.isCallBackFinish = false;
      this._handleSubscribeCallback(false);
    }
    subAppBeforeMount() {
      this.subAppBeforeMountTime = performance.now();
      this._subAppStartObserver();
    }
    subAppUnmount() {
      if (!this.isRecordFinish) {
        this._subAppEndObserver("subAppUnmount");
      }
      this._handleSubscribeCallback(true);
    }
    afterRenderNotify() {
      if (!this.isRecordFinish) {
        this._subAppEndObserver("SubAppRenderNotify");
      } else if (!this.isSubAppNotifyFinish) {
        this.isSubAppNotifyFinish = true;
        this.isRecordFinish = true;
        this.finishAction = "SubAppRenderNotify";
        this._subAppPerformanceDataHandle();
      }
    }
    _mutationObserverCallback() {
      if (this.isStartShowFlag) {
        this.subAppStartPageShowTime = performance.now();
        this.isStartShowFlag = false;
      }
      clearTimeout(this.observeTimer);
      this.observeTimer = setTimeout(() => {
        clearTimeout(this.observeTimer);
        if (!this.isRecordFinish) {
          this._subAppEndObserver("MutationObserver");
        }
      }, this.timeLag);
    }
    _subAppEndObserver(finishAction) {
      this.isRecordFinish = true;
      this.finishAction = finishAction;
      this.subAppPageShowTime = performance.now();
      this.observer.disconnect();
      this._subAppPerformanceDataHandle();
      this.isStartShowFlag = true;
    }
    async _subAppStartObserver() {
      try {
        const targetNode = await getRenderNode(this.domQuerySelector);
        this.observer.observe(targetNode, this.config);
        this._subAppClickEventObserver(targetNode);
      } catch (e) {
        warn(e);
      }
    }
    _subAppPerformanceDataHandle() {
      const timeDifference = this.finishAction === "MutationObserver" ? this.timeLag : 0;
      this.performanceData = {
        resourceLoadTime: this.subAppBeforeMountTime - this.subAppBeforeLoadTime,
        blankScreenTime: this.subAppStartPageShowTime - this.subAppBeforeLoadTime,
        firstScreenTime: this.subAppPageShowTime - this.subAppBeforeLoadTime - timeDifference,
        isFirstRender: this.cbEntryList.indexOf(this.entry) === -1,
        entry: this.entry,
        action: this.finishAction
      };
    }
    _subAppClickEventObserver(targetNode) {
      const eventCallback = () => {
        clearTimeout(this.observeTimer);
        if (!this.isRecordFinish) {
          this._subAppEndObserver("UserEvent");
        }
      };
      targetNode.addEventListener("click", eventCallback);
      targetNode.addEventListener("keyup", eventCallback);
      targetNode.addEventListener("keydown", eventCallback);
      targetNode.addEventListener("keypress", eventCallback);
    }
    _handleCallback() {
      try {
        this.isCallBackFinish = true;
        this.targetSubscriber.forEach((callback) => {
          const {
            firstScreenTime,
            blankScreenTime,
            resourceLoadTime,
            action,
            entry
          } = this.performanceData;
          if (firstScreenTime > 0 && blankScreenTime > 0 && resourceLoadTime > 0 && action && entry) {
            if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
              console.warn("SUCCESS: ", this.performanceData);
            }
            this.cbEntryList.push(this.entry);
            callback(this.performanceData);
          } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
            console.warn("ERROR: ", this.performanceData);
          }
        });
      } catch (e) {
        warn(e);
      }
    }
    _handleSubscribeCallback(isImmediately) {
      try {
        clearTimeout(this.dataTimer);
        if (isImmediately && !this.isCallBackFinish) {
          this._handleCallback();
        } else {
          this.dataTimer = setTimeout(() => {
            this._handleCallback();
          }, this.reportTimeLag);
        }
      } catch (e) {
        warn(e);
      }
    }
  };

  // ../core/src/plugins/performance/index.ts
  function GarfishPerformance() {
    return function() {
      const subAppMap = {};
      return {
        name: "performance",
        beforeLoad(appInfo) {
          if (!subAppMap[appInfo.name] && appInfo.domGetter) {
            subAppMap[appInfo.name] = new SubAppObserver({
              subAppRootSelector: appInfo.domGetter
            });
          }
          subAppMap[appInfo.name].subAppBeforeLoad(appInfo.entry);
        },
        afterLoad(appInfo, appInstance) {
          if (appInstance) {
            appInstance.appPerformance = subAppMap[appInfo.name];
          }
        },
        beforeMount(appInfo) {
          subAppMap[appInfo.name].subAppBeforeMount(appInfo.entry);
        },
        beforeUnmount(appInfo) {
          subAppMap[appInfo.name].subAppUnmount(appInfo.entry);
        }
      };
    };
  }

  // ../core/src/plugins/logger.ts
  function GarfishLogger() {
    return function() {
      return {
        name: "garfish-logger",
        version: "1.17.5",
        beforeLoad(appInfo, ...args) {
          coreLog(`${appInfo.name} beforeLoad`, [appInfo, ...args]);
        },
        afterLoad(appInfo, appInstance, ...args) {
          if (appInstance) {
            coreLog(`${appInfo.name} id: ${appInstance.appId} afterLoad`, [
              appInfo,
              ...args
            ]);
          }
        },
        beforeMount(appInfo, appInstance, ...args) {
          coreLog(`${appInfo.name} id: ${appInstance.appId} beforeMount`, [
            appInfo,
            ...args
          ]);
        },
        afterMount(appInfo, appInstance, ...args) {
          coreLog(`${appInfo.name} id: ${appInstance.appId} afterMount`, [
            appInfo,
            ...args
          ]);
        },
        beforeUnmount(appInfo, appInstance, ...args) {
          coreLog(`${appInfo.name} id: ${appInstance.appId} beforeUnmount`, [
            appInfo,
            ...args
          ]);
        },
        afterUnmount(appInfo, appInstance, ...args) {
          coreLog(`${appInfo.name} id: ${appInstance.appId} afterUnmount`, [
            appInfo,
            ...args
          ]);
        }
      };
    };
  }

  // ../core/src/garfish.ts
  var DEFAULT_PROPS = /* @__PURE__ */ new WeakMap();
  var HOOKS_API = {
    SyncHook,
    AsyncHook,
    SyncWaterfallHook,
    AsyncWaterfallHook
  };
  var Garfish = class extends import_eventemitter2.EventEmitter2 {
    constructor(options) {
      super();
      this.running = false;
      this.version = "1.17.5";
      this.flag = __GARFISH_FLAG__;
      this.loader = new Loader();
      this.hooks = globalLifecycle();
      this.channel = new import_eventemitter2.EventEmitter2();
      this.options = createDefaultOptions();
      this.externals = {};
      this.activeApps = [];
      this.plugins = {};
      this.cacheApps = {};
      this.appInfos = {};
      this.loading = {};
      var _a;
      this.setOptions(options);
      DEFAULT_PROPS.set(this, {});
      (_a = this.options.plugins) == null ? void 0 : _a.forEach((plugin) => this.usePlugin(plugin));
      this.usePlugin(GarfishHMRPlugin());
      this.usePlugin(GarfishPerformance());
      this.usePlugin(GarfishPreloadPlugin());
      this.usePlugin(GarfishLogger());
    }
    get props() {
      return this.options && this.options.props || DEFAULT_PROPS.get(this);
    }
    setOptions(options) {
      assert(!this.running, "Garfish is running, can`t set options");
      if (isPlainObject(options)) {
        this.options = deepMergeConfig(this.options, options);
      }
      return this;
    }
    createPluginSystem(callback) {
      const hooks = callback(HOOKS_API);
      return new PluginSystem(hooks);
    }
    usePlugin(plugin, ...args) {
      assert(!this.running, "Cannot register plugin after Garfish is started.");
      assert(typeof plugin === "function", "Plugin must be a function.");
      args.unshift(this);
      const pluginConfig = plugin.apply(null, args);
      assert(pluginConfig.name, "The plugin must have a name.");
      if (!this.plugins[pluginConfig.name]) {
        this.plugins[pluginConfig.name] = pluginConfig;
        this.hooks.usePlugin(pluginConfig);
      } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
        warn("Please do not register the plugin repeatedly.");
      }
      return this;
    }
    run(options = {}) {
      var _a;
      if (this.running) {
        if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          warn("Garfish is already running now, Cannot run Garfish repeatedly.");
        }
        return this;
      }
      this.setOptions(options);
      (_a = options.plugins) == null ? void 0 : _a.forEach((plugin) => this.usePlugin(plugin));
      this.usePlugin(GarfishOptionsLife(this.options, "global-lifecycle"));
      this.hooks.lifecycle.beforeBootstrap.emit(this.options);
      this.registerApp(this.options.apps || []);
      this.running = true;
      this.hooks.lifecycle.bootstrap.emit(this.options);
      return this;
    }
    registerApp(list) {
      const currentAdds = {};
      this.hooks.lifecycle.beforeRegisterApp.emit(list);
      if (!Array.isArray(list))
        list = [list];
      for (const appInfo of list) {
        assert(appInfo.name, "Miss app.name.");
        if (!this.appInfos[appInfo.name]) {
          assert(appInfo.entry, `${appInfo.name} application entry is not url: ${appInfo.entry}`);
          currentAdds[appInfo.name] = appInfo;
          this.appInfos[appInfo.name] = appInfo;
        } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          warn(`The "${appInfo.name}" app is already registered.`);
        }
      }
      this.hooks.lifecycle.registerApp.emit(currentAdds);
      return this;
    }
    setExternal(nameOrExtObj, value) {
      assert(nameOrExtObj, "Invalid parameter.");
      if (typeof nameOrExtObj === "object") {
        for (const key in nameOrExtObj) {
          if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
            this.externals[key] && warn(`The "${key}" will be overwritten in external.`);
          }
          this.externals[key] = nameOrExtObj[key];
        }
      } else {
        this.externals[nameOrExtObj] = value;
      }
      return this;
    }
    loadApp(appName, options) {
      assert(appName, "Miss appName.");
      let appInfo = generateAppOptions(appName, this, options);
      const asyncLoadProcess = async () => {
        const stop = await this.hooks.lifecycle.beforeLoad.emit(appInfo);
        if (stop === false) {
          warn(`Load ${appName} application is terminated by beforeLoad.`);
          return null;
        }
        appInfo = generateAppOptions(appName, this, appInfo);
        assert(appInfo.entry, `Can't load unexpected child app "${appName}", Please provide the entry parameters or registered in advance of the app.`);
        let appInstance = null;
        const cacheApp = this.cacheApps[appName];
        if (appInfo.cache && cacheApp) {
          appInstance = cacheApp;
        } else {
          try {
            const [manager, resources, isHtmlMode] = await processAppResources(this.loader, appInfo);
            appInstance = new App(this, appInfo, manager, resources, isHtmlMode, appInfo.customLoader);
            for (const key in this.plugins) {
              appInstance.hooks.usePlugin(this.plugins[key]);
            }
            if (appInfo.cache) {
              this.cacheApps[appName] = appInstance;
            }
          } catch (e) {
            (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(e);
            this.hooks.lifecycle.errorLoadApp.emit(e, appInfo);
          }
        }
        await this.hooks.lifecycle.afterLoad.emit(appInfo, appInstance);
        return appInstance;
      };
      if (!this.loading[appName]) {
        this.loading[appName] = asyncLoadProcess().finally(() => {
          delete this.loading[appName];
        });
      }
      return this.loading[appName];
    }
  };

  // ../router/src/config.ts
  var __GARFISH_ROUTER_UPDATE_FLAG__ = "__GARFISH_ROUTER_UPDATE_FLAG__";
  var __GARFISH_ROUTER_FLAG__ = "__GARFISH_ROUTER_FLAG__";
  var __GARFISH_BEFORE_ROUTER_EVENT__ = "garfish:before-routing-event";
  var RouterConfig = {
    basename: "/",
    current: {
      fullPath: "/",
      path: "/",
      matched: [],
      query: {},
      state: {},
      href: ""
    },
    apps: [],
    beforeEach: (to, from, next) => next(),
    afterEach: (to, from, next) => next(),
    active: () => Promise.resolve(),
    deactive: () => Promise.resolve(),
    routerChange: () => {
    },
    autoRefreshApp: true,
    listening: true
  };
  function set(field, value) {
    RouterConfig[field] = value;
  }
  function setRouterConfig(options) {
    Object.assign(RouterConfig, options);
  }

  // ../router/src/utils/urlUt.ts
  function parseQuery(query = "") {
    const res = {};
    if (query) {
      query.slice(1).split("&").map((item) => {
        const pairs = item.split("=");
        res[pairs[0]] = pairs;
      });
    }
    return res;
  }
  function getPath(basename = "/", pathname) {
    if (basename === "/" || basename === "") {
      return pathname || location.pathname;
    } else {
      return (pathname || location.pathname).replace(new RegExp(`^/?${basename}`), "");
    }
  }
  function getAppRootPath(appInfo) {
    const path = getPath(appInfo.basename, location.pathname);
    let appRootPath = appInfo.basename === "/" ? "" : appInfo.basename || "";
    if (typeof appInfo.activeWhen === "string") {
      appRootPath += appInfo.activeWhen;
    } else {
      appRootPath += path.split("").reduce((pre, next) => {
        if (typeof appInfo.activeWhen === "function" && !appInfo.activeWhen(pre))
          return pre + next;
        return pre;
      }, "");
    }
    return appRootPath;
  }

  // ../router/src/utils/index.ts
  async function asyncForEach(arr, callback) {
    const length = arr.length;
    let k = 0;
    while (k < length) {
      const kValue = arr[k];
      await callback(kValue, k, arr);
      k++;
    }
  }
  function toMiddleWare(to, from, cb) {
    return new Promise((resolve, reject) => {
      try {
        cb(to, from, resolve);
      } catch (err) {
        reject(err);
      }
    });
  }
  function createEvent(type) {
    let e;
    if (navigator.userAgent.indexOf("MSIE") !== -1 || navigator.appVersion.indexOf("Trident/") > 0) {
      e = document.createEvent("UIEvents");
      e.initUIEvent(type.toLowerCase(), true, false, window, 0);
    } else {
      e = new Event(type.toLowerCase());
    }
    return e;
  }

  // ../router/src/utils/customEvent.ts
  var NativeCustomEvent = typeof global !== "undefined" ? global == null ? void 0 : global.CustomEvent : null;
  function useNative() {
    try {
      const p = new NativeCustomEvent("cat", { detail: { foo: "bar" } });
      return p.type === "cat" && p.detail.foo === "bar";
    } catch (e) {
    }
    return false;
  }
  var CustomEvent;
  if (NativeCustomEvent && useNative()) {
    CustomEvent = NativeCustomEvent;
  } else if (typeof document !== "undefined" && typeof document.createEvent === "function") {
    CustomEvent = function(type, params) {
      params = params || { bubbles: false, cancelable: false, detail: null };
      const evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(type, params.bubbles || false, params.cancelable || false, params.detail || null);
      return evt;
    };
  } else {
    CustomEvent = function(type, params) {
      const e = document.createEventObject();
      e.type = type;
      if (params) {
        e.bubbles = Boolean(params.bubbles);
        e.cancelable = Boolean(params.cancelable);
        e.detail = params.detail;
      } else {
        e.bubbles = false;
        e.cancelable = false;
        e.detail = void 0;
      }
      return e;
    };
  }
  var customEvent_default = CustomEvent;

  // ../router/src/utils/navEvent.ts
  function createPopStateEvent(state, originalMethodName) {
    let evt;
    try {
      evt = new PopStateEvent("popstate", { state });
    } catch (err) {
      evt = document.createEvent("PopStateEvent");
      evt.initPopStateEvent("popstate", false, false, state);
    }
    evt.garfish = true;
    evt.garfishTrigger = originalMethodName;
    return evt;
  }
  var callCapturedEventListeners = (type) => {
    const eventArguments = createPopStateEvent(window.history.state, type);
    window.dispatchEvent(eventArguments);
  };
  var handlerParams = function(path, query, basename) {
    if (!path || typeof path !== "string")
      return "";
    let url = path;
    if (url[0] !== "/")
      url = "/" + url;
    if (Object.prototype.toString.call(query) === "[object Object]") {
      const qs = Object.keys(query).map((key) => `${key}=${query[key]}`).join("&");
      url += qs ? "?" + qs : "";
    }
    if (basename !== "/")
      url = basename + url;
    if (url[0] !== "/")
      url = "/" + url;
    return url;
  };
  var push = ({
    path,
    query,
    basename
  }) => {
    if (!basename)
      basename = RouterConfig.basename || "/";
    let url = null;
    if (validURL(path)) {
      url = /(^https?:)|(^\/\/)/.test(path) ? path : `//${path}`;
    } else {
      url = handlerParams(path, query, basename);
    }
    history.pushState(__spreadValues({ [__GARFISH_ROUTER_UPDATE_FLAG__]: true }, history.state), "", url);
  };
  var replace = ({
    path,
    query,
    basename
  }) => {
    if (!basename)
      basename = RouterConfig.basename || "/";
    let url = null;
    if (validURL(path)) {
      url = /^(https?:)(\/\/)/.test(path) ? path : `//${path}`;
    } else {
      url = handlerParams(path, query, basename);
    }
    history.replaceState(__spreadValues({ [__GARFISH_ROUTER_UPDATE_FLAG__]: true }, history.state), "", url);
  };

  // ../router/src/linkTo.ts
  var hasActive = (activeWhen, path) => {
    if (typeof activeWhen === "string") {
      if (activeWhen[0] !== "/")
        activeWhen = `/${activeWhen}`;
      if (activeWhen === "/" && path === activeWhen)
        return true;
      const activeWhenArr = activeWhen.split("/");
      const pathArr = path.split("/");
      let flag = true;
      activeWhenArr.forEach((pathItem, index) => {
        if (pathItem && pathItem !== pathArr[index]) {
          flag = false;
        }
      });
      return flag;
    } else {
      return activeWhen(path);
    }
  };
  var linkTo = async ({
    toRouterInfo,
    fromRouterInfo,
    eventType
  }) => {
    const {
      current,
      apps,
      deactive,
      active,
      notMatch,
      beforeEach: beforeEach2,
      afterEach: afterEach2,
      autoRefreshApp
    } = RouterConfig;
    const deactiveApps = current.matched.filter((appInfo) => !hasActive(appInfo.activeWhen, getPath(appInfo.basename, location.pathname)));
    const activeApps = apps.filter((appInfo) => {
      return hasActive(appInfo.activeWhen, getPath(appInfo.basename, location.pathname));
    });
    const needToActive = activeApps.filter(({ name }) => {
      return !current.matched.some(({ name: cName }) => name === cName);
    });
    const to = __spreadProps(__spreadValues({}, toRouterInfo), {
      matched: needToActive
    });
    const from = __spreadProps(__spreadValues({}, fromRouterInfo), {
      matched: deactiveApps
    });
    await toMiddleWare(to, from, beforeEach2);
    if (current.matched.length > 0) {
      await asyncForEach(deactiveApps, async (appInfo) => await deactive(appInfo, getPath(appInfo.basename, location.pathname)));
    }
    setRouterConfig({
      current: {
        path: getPath(RouterConfig.basename),
        fullPath: location.pathname,
        href: location.href,
        matched: activeApps,
        state: history.state,
        query: parseQuery(location.search)
      }
    });
    const curState = window.history.state || {};
    if (eventType !== "popstate" && (curState[__GARFISH_ROUTER_UPDATE_FLAG__] || autoRefreshApp)) {
      callCapturedEventListeners(eventType);
    }
    await asyncForEach(needToActive, async (appInfo) => {
      const appRootPath = getAppRootPath(appInfo);
      await active(appInfo, appRootPath);
    });
    if (activeApps.length === 0 && notMatch)
      notMatch(location.pathname);
    await toMiddleWare(to, from, afterEach2);
  };

  // ../router/src/agentRouter.ts
  var normalAgent = () => {
    const addRouterListener = function() {
      window.addEventListener(__GARFISH_BEFORE_ROUTER_EVENT__, function(env) {
        RouterConfig.routerChange && RouterConfig.routerChange(location.pathname);
        linkTo(env.detail);
      });
    };
    if (!window[__GARFISH_ROUTER_FLAG__]) {
      const rewrite = function(type) {
        const hapi = history[type];
        return function() {
          const urlBefore = window.location.pathname + window.location.hash;
          const stateBefore = history == null ? void 0 : history.state;
          const res = hapi.apply(this, arguments);
          const urlAfter = window.location.pathname + window.location.hash;
          const stateAfter = history == null ? void 0 : history.state;
          const e = createEvent(type);
          e.arguments = arguments;
          if (urlBefore !== urlAfter || JSON.stringify(stateBefore) !== JSON.stringify(stateAfter)) {
            window.dispatchEvent(new customEvent_default(__GARFISH_BEFORE_ROUTER_EVENT__, {
              detail: {
                toRouterInfo: {
                  fullPath: urlAfter,
                  href: location.href,
                  query: parseQuery(location.search),
                  path: getPath(RouterConfig.basename, urlAfter),
                  state: stateAfter
                },
                fromRouterInfo: {
                  fullPath: urlBefore,
                  query: RouterConfig.current.query,
                  href: RouterConfig.current.href,
                  path: getPath(RouterConfig.basename, urlBefore),
                  state: stateBefore
                },
                eventType: type
              }
            }));
          }
          return res;
        };
      };
      history.pushState = rewrite("pushState");
      history.replaceState = rewrite("replaceState");
      window.addEventListener("popstate", function(event) {
        if (event && typeof event === "object" && event.garfish)
          return;
        if (history.state && typeof history.state === "object")
          delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];
        window.dispatchEvent(new customEvent_default(__GARFISH_BEFORE_ROUTER_EVENT__, {
          detail: {
            toRouterInfo: {
              fullPath: location.pathname,
              href: location.href,
              query: parseQuery(location.search),
              path: getPath(RouterConfig.basename)
            },
            fromRouterInfo: {
              fullPath: RouterConfig.current.fullPath,
              path: getPath(RouterConfig.basename, RouterConfig.current.path),
              href: RouterConfig.current.href,
              query: RouterConfig.current.query
            },
            eventType: "popstate"
          }
        }));
      }, false);
      window[__GARFISH_ROUTER_FLAG__] = true;
    }
    addRouterListener();
  };
  var initRedirect = () => {
    linkTo({
      toRouterInfo: {
        fullPath: location.pathname,
        href: location.href,
        path: getPath(RouterConfig.basename),
        query: parseQuery(location.search),
        state: history.state
      },
      fromRouterInfo: {
        fullPath: "/",
        href: "",
        path: "/",
        query: {},
        state: {}
      },
      eventType: "pushState"
    });
  };
  var listen = () => {
    normalAgent();
    initRedirect();
  };

  // ../router/src/context.ts
  var beforeEach = (hook) => {
    set("beforeEach", hook);
  };
  var afterEach = (hook) => {
    set("afterEach", hook);
  };
  var routerChange = (hook) => {
    set("routerChange", hook);
  };
  var registerRouter = (Apps) => {
    const unregisterApps = Apps.filter((app) => !RouterConfig.apps.some((item) => app.name === item.name));
    set("apps", RouterConfig.apps.concat(unregisterApps));
  };
  var listenRouterAndReDirect = ({
    apps,
    basename = "/",
    autoRefreshApp,
    active,
    deactive,
    notMatch,
    listening = true
  }) => {
    registerRouter(apps);
    setRouterConfig({
      basename,
      autoRefreshApp,
      active,
      deactive,
      notMatch,
      listening
    });
    listen();
  };
  var Router = {
    push,
    replace,
    beforeEach,
    afterEach,
    registerRouter,
    routerChange,
    listenRouterAndReDirect,
    setRouterConfig,
    routerConfig: RouterConfig
  };
  var context_default = Router;

  // ../router/src/index.ts
  function GarfishRouter(_args) {
    return function(Garfish2) {
      Garfish2.apps = {};
      Garfish2.router = context_default;
      return {
        name: "router",
        version: "1.17.5",
        bootstrap(options) {
          let activeApp = null;
          const unmounts = {};
          const { basename } = options;
          const { autoRefreshApp = true, onNotMatchRouter = () => null } = Garfish2.options;
          async function active(appInfo, rootPath = "/") {
            routerLog(`${appInfo.name} active`, {
              appInfo,
              rootPath,
              listening: RouterConfig.listening
            });
            if (!RouterConfig.listening)
              return;
            const { name, active: active2, cache = true } = appInfo;
            if (active2)
              return active2(appInfo, rootPath);
            appInfo.rootPath = rootPath;
            const currentApp = activeApp = createKey();
            const app = await Garfish2.loadApp(appInfo.name, {
              cache,
              basename: rootPath,
              entry: appInfo.entry,
              domGetter: appInfo.domGetter
            });
            if (app) {
              app.appInfo.basename = rootPath;
              const call = async (app2, isRender) => {
                if (!app2)
                  return;
                const isDes = cache && app2.mounted;
                if (isRender) {
                  return await app2[isDes ? "show" : "mount"]();
                } else {
                  return app2[isDes ? "hide" : "unmount"]();
                }
              };
              Garfish2.apps[name] = app;
              unmounts[name] = () => {
                if (app.mounting) {
                  delete Garfish2.cacheApps[name];
                }
                call(app, false);
              };
              if (currentApp === activeApp) {
                await call(app, true);
              }
            }
          }
          async function deactive(appInfo, rootPath) {
            routerLog(`${appInfo.name} deactive`, {
              appInfo,
              rootPath
            });
            activeApp = null;
            const { name, deactive: deactive2 } = appInfo;
            if (deactive2)
              return deactive2(appInfo, rootPath);
            const unmount = unmounts[name];
            unmount && unmount();
            delete Garfish2.apps[name];
            const needToDeleteApps = context_default.routerConfig.apps.filter((app) => {
              if (appInfo.rootPath === app.basename)
                return true;
            });
            if (needToDeleteApps.length > 0) {
              needToDeleteApps.forEach((app) => {
                delete Garfish2.appInfos[app.name];
                delete Garfish2.cacheApps[app.name];
              });
              context_default.setRouterConfig({
                apps: context_default.routerConfig.apps.filter((app) => {
                  return !needToDeleteApps.some((needDelete) => app.name === needDelete.name);
                })
              });
            }
          }
          const apps = Object.values(Garfish2.appInfos);
          const appList = apps.filter((app) => {
            if (!app.basename)
              app.basename = basename;
            return !!app.activeWhen;
          });
          const listenOptions = {
            basename,
            active,
            deactive,
            autoRefreshApp,
            notMatch: onNotMatchRouter,
            apps: appList,
            listening: true
          };
          routerLog("listenRouterAndReDirect", listenOptions);
          listenRouterAndReDirect(listenOptions);
        },
        registerApp(appInfos) {
          const appList = Object.values(appInfos);
          context_default.registerRouter(appList.filter((app) => !!app.activeWhen));
          if (!Garfish2.running)
            return;
          routerLog("registerApp initRedirect", appInfos);
          initRedirect();
        }
      };
    };
  }

  // ../browser-vm/src/symbolTypes.ts
  var GARFISH_NAMESPACE_PREFIX = "__Garfish__";
  var GARFISH_OPTIMIZE_NAME = "__garfish_optimize__";
  var __proxyNode__ = Symbol.for("garfish.proxyNode");
  var __domWrapper__ = Symbol.for("garfish.domWrapper");
  var __windowBind__ = Symbol.for("garfish.windowBind");
  var __sandboxMap__ = Symbol.for("garfish.sandboxMap");
  var __documentBind__ = Symbol.for("garfish.documentBind");
  var __garfishGlobal__ = Symbol.for("garfish.globalObject");
  var __elementSandboxTag__ = Symbol.for("garfish.elementSandboxTag");

  // ../browser-vm/src/utils.ts
  var esGlobalMethods = "eval,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Array,ArrayBuffer,BigInt,BigInt64Array,BigUint64Array,Boolean,DataView,Date,Error,EvalError,FinalizationRegistry,Float32Array,Float64Array,Function,Int8Array,Int16Array,Int32Array,Map,Number,Object,Promise,Proxy,RangeError,ReferenceError,RegExp,Set,SharedArrayBuffer,String,Symbol,SyntaxError,TypeError,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,URIError,WeakMap,WeakRef,WeakSet,Atomics,JSON,Math,Reflect,".split(",");
  var nativeCodeMethods = "hasOwnProperty,".split(",");
  var isEsGlobalMethods = makeMap(esGlobalMethods);
  var isNativeCodeMethods = makeMap(nativeCodeMethods);
  var optimizeMethods = [...esGlobalMethods].filter((v) => v !== "eval");
  var sandboxList = /* @__PURE__ */ new Map();
  if (!window[__sandboxMap__]) {
    window[__sandboxMap__] = sandboxList;
  } else {
    sandboxList = window[__sandboxMap__];
  }
  var sandboxMap = {
    sandboxMap: sandboxList,
    get(element) {
      if (!element)
        return;
      const sandboxId = element[__elementSandboxTag__];
      if (typeof sandboxId !== "number")
        return;
      return this.sandboxMap.get(sandboxId);
    },
    setElementTag(element, sandbox) {
      if (!element)
        return;
      element[__elementSandboxTag__] = sandbox.id;
    },
    set(sandbox) {
      if (this.sandboxMap.get(sandbox.id))
        return;
      this.sandboxMap.set(sandbox.id, sandbox);
    },
    del(sandbox) {
      this.sandboxMap.delete(sandbox.id);
    }
  };
  function handlerParams2(args) {
    args = Array.isArray(args) ? args : Array.from(args);
    return args.map((v) => {
      return v && v[__proxyNode__] ? v[__proxyNode__] : v;
    });
  }
  function rootElm(sandbox) {
    const container = sandbox && sandbox.options.el;
    return container && container();
  }
  function createFakeObject(target, filter, isWritable) {
    const fakeObject = {};
    const propertyMap = {};
    const storageBox = /* @__PURE__ */ Object.create(null);
    const propertyNames = Object.getOwnPropertyNames(target);
    const def2 = (p) => {
      const descriptor = Object.getOwnPropertyDescriptor(target, p);
      if (descriptor == null ? void 0 : descriptor.configurable) {
        const hasGetter = hasOwn(descriptor, "get");
        const hasSetter = hasOwn(descriptor, "set");
        const canWritable = typeof isWritable === "function" && isWritable(p);
        if (hasGetter) {
          descriptor.get = () => hasOwn(storageBox, p) ? storageBox[p] : target[p];
        }
        if (hasSetter) {
          descriptor.set = (val) => {
            storageBox[p] = val;
            return true;
          };
        }
        if (canWritable) {
          if (descriptor.writable === false) {
            descriptor.writable = true;
          } else if (hasSetter) {
            descriptor.set = (val) => {
              storageBox[p] = val;
              return true;
            };
          }
        }
        Object.defineProperty(fakeObject, p, Object.freeze(descriptor));
      }
    };
    propertyNames.forEach((p) => {
      propertyMap[p] = true;
      typeof filter === "function" ? !filter(p) && def2(p) : def2(p);
    });
    for (const prop in target) {
      !propertyMap[prop] && def2(prop);
    }
    return fakeObject;
  }
  var setting = true;
  function microTaskHtmlProxyDocument(proxyDocument) {
    const html = document.children[0];
    if (html && html.parentNode !== proxyDocument) {
      Object.defineProperty(html, "parentNode", {
        value: proxyDocument,
        configurable: true
      });
      if (setting) {
        setting = false;
        nextTick(() => {
          setting = true;
          Object.defineProperty(html, "parentNode", {
            value: document,
            configurable: true
          });
        });
      }
    }
  }
  function isStyledComponentsLike(element) {
    return element instanceof HTMLStyleElement && !element.textContent;
  }
  var LockQueue = class {
    constructor() {
      this.id = 0;
      this.lockQueue = [];
      this.currentId = 0;
    }
    genId() {
      const lockId = this.id;
      let promiseResolve = () => {
      };
      const waiting = new Promise((resolve) => {
        promiseResolve = resolve;
        this.currentId++;
      });
      const lockItem = {
        id: lockId,
        waiting,
        resolve: () => {
          promiseResolve();
        }
      };
      this.lockQueue.push(lockItem);
      this.id += 1;
      return lockId;
    }
    getId() {
      return this.id;
    }
    async wait(id2) {
      const { lockQueue } = this;
      const firstLock = lockQueue[0];
      const lockItem = lockQueue.find((item) => item.id === id2);
      const lockIndex = lockQueue.findIndex((item) => item.id === id2);
      if (firstLock.id === id2) {
        lockItem == null ? void 0 : lockItem.resolve();
        return;
      }
      if (lockItem) {
        await Promise.all(lockQueue.slice(0, lockIndex).map((item) => item.waiting));
        const lastLock = lockQueue[lockQueue.length - 1];
        if (lastLock.id === id2) {
          this.clear();
        }
      }
    }
    release(id2) {
      const { lockQueue } = this;
      const lockItem = lockQueue.find((item) => item.id === id2);
      lockItem == null ? void 0 : lockItem.resolve();
    }
    clear() {
      this.lockQueue = [];
    }
  };

  // ../browser-vm/src/proxyInterceptor/shared.ts
  function isDataDescriptor(desc) {
    if (desc === void 0)
      return false;
    return "value" in desc || "writable" in desc;
  }
  function isAccessorDescriptor(desc) {
    if (desc === void 0)
      return false;
    return "get" in desc || "set" in desc;
  }
  function verifyGetterDescriptor(target, p, newValue) {
    const desc = Object.getOwnPropertyDescriptor(target, p);
    if (desc !== void 0 && desc.configurable === false) {
      if (isDataDescriptor(desc) && desc.writable === false) {
        if (!Object.is(newValue, desc.value)) {
          if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
            warn(`property "${String(p)}" is non-configurable and non-writable.`);
          }
          return 1;
        }
      } else if (isAccessorDescriptor(desc) && desc.get === void 0) {
        return 2;
      }
    }
    return 0;
  }
  function verifySetter(proxyTarget, target, p, val, receiver) {
    const verifyResult = verifySetterDescriptor(proxyTarget ? proxyTarget : receiver || target, p, val);
    let result;
    if (verifyResult > 0) {
      if (verifyResult === 1 || verifyResult === 2)
        result = false;
      if (verifyResult === 3)
        result = true;
    }
    return result;
  }
  function verifySetterDescriptor(target, p, newValue) {
    const desc = Object.getOwnPropertyDescriptor(target, p);
    if (desc !== void 0 && desc.configurable === false) {
      if (isDataDescriptor(desc) && desc.writable === false) {
        if (!Object.is(newValue, desc.value)) {
          if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
            warn(`property "${String(p)}" is non-configurable and non-writable.`);
          }
          return 1;
        } else {
          return 3;
        }
      } else if (isAccessorDescriptor(desc) && desc.set === void 0) {
        return 2;
      }
    }
    return 0;
  }
  function safeToString(thing) {
    try {
      return thing.toString();
    } catch (e) {
      return "[toString failed]";
    }
  }
  function isConstructor(fn) {
    const fp = fn.prototype;
    const hasConstructor = fp && fp.constructor === fn && Object.getOwnPropertyNames(fp).length > 1;
    const functionStr = !hasConstructor && safeToString(fn);
    return hasConstructor || /^function\s+[A-Z]/.test(functionStr) || /^class\b/.test(functionStr);
  }
  var buildInProps = makeMap([
    "length",
    "caller",
    "callee",
    "arguments",
    "prototype",
    Symbol.hasInstance
  ]);
  function transferProps(o, n) {
    for (const key of Reflect.ownKeys(o)) {
      if (buildInProps(key))
        continue;
      const desc = Object.getOwnPropertyDescriptor(n, key);
      if (desc && desc.writable) {
        n[key] = o[key];
      }
    }
  }
  function bind(fn, context) {
    const fNOP = function() {
    };
    function bound() {
      const args = handlerParams2(arguments);
      if (this instanceof bound) {
        const obj = new fn(...args);
        Object.setPrototypeOf(obj, bound.prototype);
        return obj;
      } else {
        return fn.apply(context, args);
      }
    }
    bound.$native = fn;
    transferProps(fn, bound);
    if (fn.prototype) {
      fNOP.prototype = fn.prototype;
    }
    bound.prototype = new fNOP();
    if (Symbol.hasInstance) {
      Object.defineProperty(bound, Symbol.hasInstance, {
        configurable: true,
        value(instance) {
          const op = fn.prototype;
          return isObject(op) || typeof op === "function" ? instance instanceof fn : false;
        }
      });
    }
    return bound;
  }

  // ../browser-vm/src/modules/history.ts
  var passedKey = makeMap(["scrollRestoration"]);
  function historyModule() {
    const proto = Object.getPrototypeOf(window.history) || History.prototype;
    const fakeHistory = Object.create(proto);
    const proxyHistory = new Proxy(fakeHistory, {
      get(target, p) {
        const value = hasOwn(target, p) ? target[p] : window.history[p];
        return typeof value === "function" ? value.bind(window.history) : value;
      },
      set(target, p, value, receiver) {
        const isPassKey = typeof p === "string" && passedKey(p);
        const verifySetterResult = verifySetter(isPassKey ? history : null, target, p, value, receiver);
        if (verifySetterResult !== void 0) {
          return verifySetterResult;
        } else {
          return isPassKey ? Reflect.set(history, p, value) : Reflect.set(target, p, value, receiver);
        }
      },
      getPrototypeOf() {
        return fakeHistory;
      }
    });
    const fakeHistoryCtor = function History2() {
      throw new TypeError("Illegal constructor");
    };
    fakeHistoryCtor.prototype = fakeHistory;
    fakeHistoryCtor.prototype.constructor = fakeHistoryCtor;
    return {
      override: {
        history: proxyHistory,
        History: fakeHistoryCtor
      }
    };
  }

  // ../browser-vm/src/modules/network.ts
  function networkModule(sandbox) {
    const baseUrl = sandbox.options.baseUrl;
    const wsSet = /* @__PURE__ */ new Set();
    const xhrSet = /* @__PURE__ */ new Set();
    const fetchSet = /* @__PURE__ */ new Set();
    const needFix = (url) => sandbox.options.fixBaseUrl && baseUrl && typeof url === "string" && !isAbsolute(url);
    class fakeXMLHttpRequest extends XMLHttpRequest {
      constructor() {
        super();
        if (!sandbox.options.disableCollect) {
          xhrSet.add(this);
        }
      }
      open() {
        if (arguments[2] === false) {
          xhrSet.delete(this);
        }
        if (needFix(arguments[1])) {
          arguments[1] = baseUrl ? transformUrl(baseUrl, arguments[1]) : arguments[1];
        }
        const url = arguments[1];
        if (sandbox.options.addSourceList) {
          sandbox.options.addSourceList({
            tagName: "xmlhttprequest",
            url
          });
        }
        return super.open.apply(this, arguments);
      }
      abort() {
        xhrSet.delete(this);
        return super.abort.apply(this, arguments);
      }
    }
    class fakeWebSocket extends WebSocket {
      constructor(url, protocols) {
        if (needFix(url) && baseUrl) {
          const baseWsUrl = toWsProtocol(baseUrl);
          url = transformUrl(baseWsUrl, arguments[1]);
        }
        super(url, protocols);
        if (!sandbox.options.disableCollect) {
          wsSet.add(this);
        }
      }
      close() {
        wsSet.delete(this);
        return super.close.apply(this, arguments);
      }
    }
    const fakeFetch = (input, options = {}) => {
      if (needFix(input) && baseUrl) {
        input = transformUrl(baseUrl, input);
      }
      if (sandbox.options.addSourceList) {
        sandbox.options.addSourceList({
          tagName: "fetch",
          url: input
        });
      }
      let controller;
      if (!hasOwn(options, "signal") && window.AbortController) {
        controller = new window.AbortController();
        if (!sandbox.options.disableCollect) {
          fetchSet.add(controller);
        }
        options.signal = controller.signal;
      }
      const result = window.fetch(input, options);
      return controller && isPromise(result) ? result.finally(() => fetchSet.delete(controller)) : result;
    };
    return {
      override: {
        WebSocket: fakeWebSocket,
        XMLHttpRequest: fakeXMLHttpRequest,
        fetch: fakeFetch
      },
      recover() {
        wsSet.forEach((ws) => {
          if (typeof ws.close === "function")
            ws.close();
        });
        xhrSet.forEach((xhr) => {
          if (typeof xhr.abort === "function")
            xhr.abort();
        });
        fetchSet.forEach((ctor) => {
          if (typeof ctor.abort === "function")
            ctor.abort();
        });
        wsSet.clear();
        xhrSet.clear();
        fetchSet.clear();
      }
    };
  }

  // ../browser-vm/src/proxyInterceptor/document.ts
  var passedKey2 = makeMap(["title", "cookie", "onselectstart", "ondragstart"]);
  var queryFunctions = makeMap([
    "querySelector",
    "querySelectorAll",
    "getElementById",
    "getElementsByTagName",
    "getElementsByTagNameNS",
    "getElementsByClassName"
  ]);
  function createGetter(sandbox) {
    return (target, p, receiver) => {
      if (p === "activeElement") {
        return Reflect.get(document, p);
      }
      const rootNode = rootElm(sandbox);
      const strictIsolation = sandbox.options.strictIsolation;
      const value = hasOwn(target, p) ? Reflect.get(target, p, receiver) : Reflect.get(document, p);
      const hooksRes = sandbox.hooks.lifecycle.documentGetter.emit({
        value,
        rootNode,
        propName: p,
        proxyDocument: target,
        customValue: null
      });
      if (hooksRes.customValue) {
        return hooksRes.customValue;
      }
      const setSandboxRef = (el) => {
        if (isObject(el)) {
          sandboxMap.setElementTag(el, sandbox);
          if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
            el.__SANDBOX__ = true;
          }
        }
        return el;
      };
      if (rootNode) {
        if (p === "createElement") {
          return function(tagName, options) {
            const el = value.call(document, tagName, options);
            return setSandboxRef(el);
          };
        }
        if (p === "createElementNS") {
          return function(...args) {
            const el = value.call(document, ...args);
            return setSandboxRef(el);
          };
        } else if (p === "createTextNode") {
          return function(data) {
            const el = value.call(document, data);
            return setSandboxRef(el);
          };
        } else if (p === "head") {
          return findTarget(rootNode, ["head", `div[${__MockHead__}]`]) || value;
        }
        if (strictIsolation) {
          if (p === "body") {
            return findTarget(rootNode, ["body", `div[${__MockBody__}]`]);
          } else if (queryFunctions(p)) {
            return p === "getElementById" ? (id2) => rootNode.querySelector(`#${id2}`) : rootNode[p].bind(rootNode);
          }
        }
      }
      if (typeof value === "function") {
        let newValue = hasOwn(value, __documentBind__) ? value[__documentBind__] : null;
        if (!newValue)
          newValue = bind(value, document);
        const verifyResult = verifyGetterDescriptor(target, p, newValue);
        if (verifyResult > 0) {
          if (verifyResult === 1)
            return value;
          if (verifyResult === 2)
            return void 0;
        }
        value[__documentBind__] = newValue;
        return newValue;
      }
      return value;
    };
  }
  var safariProxyDocumentDealHandler = safari13Deal();
  function createSetter(sandbox) {
    return (target, p, value, receiver) => {
      const rootNode = rootElm(sandbox);
      const verifyResult = verifySetterDescriptor(typeof p === "string" && passedKey2(p) ? document : receiver || target, p, value);
      if (verifyResult > 0) {
        if (verifyResult === 1 || verifyResult === 2)
          return false;
        if (verifyResult === 3)
          return true;
      }
      if (p === "onselectstart" || p === "ondragstart") {
        if (rootNode) {
          return Reflect.set(rootNode, p, value);
        } else {
          return Reflect.set(document, p, value);
        }
      }
      if (typeof p === "string" && passedKey2(p)) {
        return Reflect.set(document, p, value);
      } else {
        safariProxyDocumentDealHandler.triggerSet();
        return Reflect.set(target, p, value, receiver);
      }
    };
  }
  function createDefineProperty() {
    return (target, p, descriptor) => {
      safariProxyDocumentDealHandler.handleDescriptor(descriptor);
      return passedKey2(p) ? Reflect.defineProperty(document, p, descriptor) : Reflect.defineProperty(target, p, descriptor);
    };
  }
  function createHas() {
    return (target, p) => {
      if (p === "activeElement")
        return Reflect.has(document, p);
      return hasOwn(target, p) || Reflect.has(document, p);
    };
  }

  // ../browser-vm/src/modules/document.ts
  var documentModule = (sandbox) => {
    let proxyDocument = Object.create(document);
    const getter = createGetter(sandbox);
    const fakeDocument = createFakeObject(document);
    const fakeDocumentProto = new Proxy(fakeDocument, {
      get: (...args) => {
        microTaskHtmlProxyDocument(proxyDocument);
        return getter(...args);
      },
      has: createHas()
    });
    proxyDocument = new Proxy(Object.create(fakeDocumentProto, {
      currentScript: {
        value: null,
        writable: true
      },
      [__proxyNode__]: {
        writable: false,
        configurable: false,
        value: document
      }
    }), {
      set: createSetter(sandbox),
      defineProperty: createDefineProperty(),
      getPrototypeOf() {
        return HTMLDocument.prototype || Document.prototype;
      }
    });
    return {
      override: {
        document: proxyDocument
      }
    };
  };

  // ../browser-vm/src/modules/uiEvent.ts
  var MouseEventPatch = class extends MouseEvent {
    constructor(typeArg, mouseEventInit) {
      if (mouseEventInit && getType(mouseEventInit.view) === "window") {
        mouseEventInit.view = window;
      }
      super(typeArg, mouseEventInit);
    }
  };
  function UiEventOverride() {
    return {
      override: {
        MouseEvent: MouseEventPatch
      }
    };
  }

  // ../browser-vm/src/modules/storage.ts
  var CusStorage = class {
    constructor(namespace, rawStorage) {
      this.rawStorage = rawStorage;
      this.namespace = namespace;
      this.prefix = `${GARFISH_NAMESPACE_PREFIX}${namespace}__`;
    }
    get length() {
      return this.getKeys().length;
    }
    getKeys() {
      return Object.keys(this.rawStorage).filter((key) => key.startsWith(this.prefix));
    }
    key(n) {
      const key = this.getKeys()[n];
      return key ? key.substring(this.prefix.length) : null;
    }
    getItem(keyName) {
      return this.rawStorage.getItem(`${this.prefix + keyName}`);
    }
    setItem(keyName, keyValue) {
      this.rawStorage.setItem(`${this.prefix + keyName}`, keyValue);
    }
    removeItem(keyName) {
      this.rawStorage.removeItem(`${this.prefix + keyName}`);
    }
    clear() {
      this.getKeys().forEach((key) => {
        this.rawStorage.removeItem(key);
      });
    }
  };
  function localStorageModule(sandbox) {
    const namespace = sandbox.options.namespace;
    return {
      override: {
        localStorage: new CusStorage(namespace, localStorage),
        sessionStorage: new CusStorage(namespace, sessionStorage)
      }
    };
  }

  // ../browser-vm/src/modules/eventListener.ts
  function listenerModule(_sandbox) {
    const listeners = /* @__PURE__ */ new Map();
    const rawAddEventListener2 = window.addEventListener;
    const rawRemoveEventListener2 = window.removeEventListener;
    function addListener(type, listener, options) {
      const curListeners = listeners.get(type) || [];
      if (!_sandbox.options.disableCollect) {
        listeners.set(type, [...curListeners, listener]);
      }
      rawAddEventListener2.call(this, type, listener, options);
    }
    function removeListener(type, listener, options) {
      const curListeners = listeners.get(type) || [];
      const idx = curListeners.indexOf(listener);
      if (idx !== -1) {
        curListeners.splice(idx, 1);
      }
      if (!_sandbox.options.disableCollect) {
        listeners.set(type, [...curListeners]);
      }
      rawRemoveEventListener2.call(this, type, listener, options);
    }
    const recover = () => {
      listeners.forEach((listener, key) => {
        listener.forEach((fn) => {
          rawRemoveEventListener2.call(window, key, fn);
        });
      });
      listeners.clear();
    };
    return {
      recover,
      override: {
        addEventListener: addListener.bind(window),
        removeEventListener: removeListener.bind(window)
      },
      created(global2) {
        const fakeDocument = global2 == null ? void 0 : global2.document;
        if (fakeDocument) {
          fakeDocument.addEventListener = addListener.bind(document);
          fakeDocument.removeEventListener = removeListener.bind(document);
        }
      }
    };
  }

  // ../browser-vm/src/modules/mutationObserver.ts
  function observerModule(_sandbox) {
    const observerSet = /* @__PURE__ */ new Set();
    class ProxyMutationObserver extends MutationObserver {
      constructor(cb) {
        super(cb);
        if (!_sandbox.options.disableCollect) {
          observerSet.add(this);
        }
      }
    }
    const recover = () => {
      observerSet.forEach((observer) => {
        if (typeof observer.disconnect === "function")
          observer.disconnect();
      });
      observerSet.clear();
    };
    return {
      recover,
      override: {
        MutationObserver: ProxyMutationObserver
      }
    };
  }

  // ../browser-vm/src/modules/timer.ts
  var rawSetTimeout = window.setTimeout;
  var rawClearTimeout = window.clearTimeout;
  var rawSetInterval = window.setInterval;
  var rawClearInterval = window.clearInterval;
  var timeoutModule = (sandbox) => {
    const timeout = /* @__PURE__ */ new Set();
    const setTimeout2 = (handler, ms, ...args) => {
      const timeoutId = rawSetTimeout(handler, ms, ...args);
      if (!sandbox.options.disableCollect) {
        timeout.add(timeoutId);
      }
      return timeoutId;
    };
    const clearTimeout2 = (timeoutId) => {
      timeout.delete(timeoutId);
      rawClearTimeout(timeoutId);
    };
    const recover = () => {
      timeout.forEach((timeoutId) => {
        rawClearTimeout(timeoutId);
      });
    };
    return {
      recover,
      override: {
        setTimeout: setTimeout2,
        clearTimeout: clearTimeout2
      }
    };
  };
  var intervalModule = (sandbox) => {
    const timeout = /* @__PURE__ */ new Set();
    const setInterval = (callback, ms, ...args) => {
      const intervalId = rawSetInterval(callback, ms, ...args);
      if (!sandbox.options.disableCollect) {
        timeout.add(intervalId);
      }
      return intervalId;
    };
    const clearInterval = (intervalId) => {
      timeout.delete(intervalId);
      rawClearInterval(intervalId);
    };
    const recover = () => {
      timeout.forEach((intervalId) => {
        rawClearInterval(intervalId);
      });
    };
    return {
      recover,
      override: {
        setInterval,
        clearInterval,
        setImmediate: (fn) => setTimeout(fn, 0)
      }
    };
  };

  // ../browser-vm/src/dynamicNode/processParams.ts
  function injectHandlerParams() {
    if (window.MutationObserver) {
      const rawObserver = window.MutationObserver.prototype.observe;
      MutationObserver.prototype.observe = function() {
        return rawObserver.apply(this, handlerParams2(arguments));
      };
    }
    const desc = Object.getOwnPropertyDescriptor(window.Document.prototype, "activeElement");
    const rawActiveEl = desc && desc.get;
    if (rawActiveEl) {
      Object.defineProperty(window.Document.prototype, "activeElement", {
        get(...args) {
          return rawActiveEl.apply(handlerParams2([this])[0], handlerParams2(args));
        }
      });
    }
  }

  // ../browser-vm/src/dynamicNode/processor.ts
  var isInsertMethod = makeMap(["insertBefore", "insertAdjacentElement"]);
  var rawElementMethods = /* @__PURE__ */ Object.create(null);
  var _DynamicNodeProcessor = class {
    constructor(el, sandbox, methodName) {
      this.nativeAppend = rawElementMethods["appendChild"];
      this.nativeRemove = rawElementMethods["removeChild"];
      this.el = el;
      this.sandbox = sandbox;
      this.methodName = methodName;
      this.rootElement = rootElm(sandbox) || document;
      this.DOMApis = new DOMApis(sandbox.global.document);
      this.tagName = el.tagName ? el.tagName.toLowerCase() : "";
    }
    is(tag) {
      return this.tagName === tag;
    }
    fixResourceNodeUrl(el) {
      const baseUrl = this.sandbox.options.baseUrl;
      if (baseUrl) {
        const src = el.getAttribute("src");
        const href = el.getAttribute("href");
        if (this.sandbox.options.fixStaticResourceBaseUrl) {
          src && (el.src = transformUrl(baseUrl, src));
          href && (el.href = transformUrl(baseUrl, href));
        }
        const url = el.src || el.href;
        if (url && this.sandbox.options.addSourceList) {
          this.sandbox.options.addSourceList({
            tagName: el.tagName,
            url
          });
        }
      }
    }
    dispatchEvent(type, errInfo) {
      Promise.resolve().then(() => {
        var _a;
        const isError = type === "error";
        let event;
        if (isError && errInfo) {
          event = new ErrorEvent(type, __spreadProps(__spreadValues({}, errInfo), {
            message: (_a = errInfo.error) == null ? void 0 : _a.message
          }));
        } else {
          event = new Event(type);
        }
        event.__byGarfish__ = true;
        Object.defineProperty(event, "target", { value: this.el });
        this.el.dispatchEvent(event);
        isError && window.dispatchEvent(event);
      });
    }
    addDynamicLinkNode(callback) {
      const { href, type } = this.el;
      if (!type || isCssType({ src: href, type })) {
        if (href) {
          const { baseUrl, namespace, styleScopeId } = this.sandbox.options;
          const fetchUrl = baseUrl ? transformUrl(baseUrl, href) : href;
          const lockId = _DynamicNodeProcessor.linkLock.genId();
          this.sandbox.loader.load({
            scope: namespace,
            url: fetchUrl,
            defaultContentType: type
          }).then(async ({ resourceManager: styleManager }) => {
            await _DynamicNodeProcessor.linkLock.wait(lockId);
            if (styleManager) {
              styleManager.correctPath();
              if (styleScopeId) {
                styleManager.setScope({
                  appName: namespace,
                  rootElId: styleScopeId()
                });
              }
              callback(styleManager.renderAsStyleElement());
            } else {
              warn(`Invalid resource type "${type}", "${href}" can't generate styleManager`);
            }
            this.dispatchEvent("load");
            _DynamicNodeProcessor.linkLock.release(lockId);
          }).catch((e) => {
            _DynamicNodeProcessor.linkLock.release(lockId);
            (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(e);
            this.dispatchEvent("error", {
              error: e,
              filename: fetchUrl
            });
          });
        }
      } else {
        if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
          warn(`Invalid resource type "${type}", "${href}"`);
        }
      }
      const linkCommentNode = this.DOMApis.createLinkCommentNode(href);
      this.el[__REMOVE_NODE__] = () => this.DOMApis.removeElement(linkCommentNode);
      return linkCommentNode;
    }
    addDynamicScriptNode() {
      const { src, type, crossOrigin } = this.el;
      const isModule2 = type === "module";
      const code = this.el.textContent || this.el.text || "";
      if (!type || isJsType({ src, type })) {
        const { baseUrl, namespace } = this.sandbox.options;
        if (src) {
          const fetchUrl = baseUrl ? transformUrl(baseUrl, src) : src;
          this.sandbox.loader.load({
            scope: namespace,
            url: fetchUrl,
            crossOrigin,
            defaultContentType: type
          }).then((manager) => {
            if (manager.resourceManager) {
              const {
                resourceManager: { url, scriptCode }
              } = manager;
              this.sandbox.execScript(scriptCode, {}, url, {
                isModule: isModule2,
                defer: false,
                async: false,
                noEntry: true,
                originScript: this.el
              });
            } else {
              warn(`Invalid resource type "${type}", "${src}" can't generate scriptManager`);
            }
            this.dispatchEvent("load");
          }, (e) => {
            (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn(e);
            this.dispatchEvent("error", {
              error: e,
              filename: fetchUrl
            });
          });
        } else if (code) {
          this.sandbox.execScript(code, {}, baseUrl, {
            noEntry: true,
            originScript: this.el
          });
        }
        const scriptCommentNode = this.DOMApis.createScriptCommentNode({
          src,
          code
        });
        this.el[__REMOVE_NODE__] = () => this.DOMApis.removeElement(scriptCommentNode);
        return scriptCommentNode;
      }
      return this.el;
    }
    monitorChangesOfLinkNode() {
      if (this.el.modifyFlag)
        return;
      const mutator = new MutationObserver((mutations) => {
        var _a;
        if (this.el.modifyFlag)
          return;
        for (const { type, attributeName } of mutations) {
          if (type === "attributes") {
            if (attributeName === "rel" || attributeName === "stylesheet") {
              if (this.el.modifyFlag)
                return;
              if (this.el.rel === "stylesheet" && this.el.href) {
                this.el.disabled = this.el.modifyFlag = true;
                const commentNode = this.addDynamicLinkNode((styleNode) => {
                  var _a2;
                  (_a2 = commentNode.parentNode) == null ? void 0 : _a2.replaceChild(styleNode, commentNode);
                });
                (_a = this.el.parentNode) == null ? void 0 : _a.replaceChild(commentNode, this.el);
              }
            }
          }
        }
      });
      mutator.observe(this.el, { attributes: true });
    }
    monitorChangesOfStyle() {
      const { baseUrl, namespace, styleScopeId } = this.sandbox.options;
      const rootElId = styleScopeId == null ? void 0 : styleScopeId();
      const modifyStyleCode = (styleCode) => {
        if (styleCode) {
          const manager = new this.sandbox.loader.StyleManager(styleCode);
          manager.correctPath(baseUrl);
          if (rootElId) {
            manager.setScope({
              rootElId,
              appName: namespace
            });
          }
          styleCode = manager.transformCode(styleCode);
        }
        return styleCode;
      };
      const mutator = new MutationObserver((mutations) => {
        var _a;
        for (const { type, addedNodes } of mutations) {
          if (type === "childList") {
            if ((_a = addedNodes[0]) == null ? void 0 : _a.textContent) {
              addedNodes[0].textContent = modifyStyleCode(addedNodes[0].textContent);
            }
          }
        }
      });
      mutator.observe(this.el, { childList: true });
      let fakeSheet = null;
      Reflect.defineProperty(this.el, "sheet", {
        get: () => {
          if (!fakeSheet) {
            fakeSheet = this.createFakeSheet(modifyStyleCode);
          }
          return fakeSheet;
        },
        configurable: true
      });
    }
    findParentNodeInApp(parentNode, defaultInsert) {
      if (parentNode === document.body) {
        return findTarget(this.rootElement, [
          "body",
          `div[${__MockBody__}]`
        ]);
      } else if (parentNode === document.head) {
        return findTarget(this.rootElement, [
          "head",
          `div[${__MockHead__}]`
        ]);
      }
      if (this.rootElement.contains(parentNode) || !document.contains(parentNode)) {
        return parentNode;
      }
      if (defaultInsert === "head") {
        return findTarget(this.rootElement, [
          "head",
          `div[${__MockHead__}]`
        ]);
      } else if (defaultInsert === "body") {
        return findTarget(this.rootElement, [
          "body",
          `div[${__MockBody__}]`
        ]);
      }
      return parentNode;
    }
    append(context, args, originProcess) {
      var _a, _b;
      let convertedNode;
      let parentNode = context;
      const { baseUrl, namespace, styleScopeId } = this.sandbox.options;
      if (sourceListTags.includes(this.tagName)) {
        this.fixResourceNodeUrl(this.el);
      }
      if (this.is("script") && ((_a = this.el) == null ? void 0 : _a.getAttribute("type")) !== "application/json") {
        parentNode = this.findParentNodeInApp(context, "body");
        convertedNode = this.addDynamicScriptNode();
      } else if (this.is("style")) {
        parentNode = this.findParentNodeInApp(context, "head");
        const manager = new this.sandbox.loader.StyleManager(this.el.textContent);
        manager.correctPath(baseUrl);
        if (styleScopeId) {
          manager.setScope({
            appName: namespace,
            rootElId: styleScopeId()
          });
        }
        this.el.textContent = manager.transformCode(manager.styleCode);
        convertedNode = this.el;
        this.sandbox.dynamicStyleSheetElementSet.add(this.el);
        this.monitorChangesOfStyle();
      } else if (this.is("link")) {
        parentNode = this.findParentNodeInApp(context, "head");
        if (this.el.rel === "stylesheet" && this.el.href) {
          convertedNode = this.addDynamicLinkNode((styleNode) => {
            this.nativeAppend.call(parentNode, styleNode);
          });
        } else {
          convertedNode = this.el;
          this.monitorChangesOfLinkNode();
        }
      }
      if (!this.rootElement.contains(parentNode) && document.contains(parentNode)) {
        if (parentNode !== this.rootElement) {
          this.sandbox.deferClearEffects.add(() => {
            this.DOMApis.removeElement(this.el);
            return this.el;
          });
        }
      }
      if (this.el && this.el.querySelectorAll) {
        const needFixDom = this.el.querySelectorAll("iframe,img,video,link,script,audio,style");
        if (needFixDom.length > 0) {
          needFixDom.forEach((dom) => {
            safeWrapper(() => this.fixResourceNodeUrl(dom));
          });
        }
      }
      if (this.is("iframe") && typeof this.el.onload === "function") {
        const { el, sandbox } = this;
        const originOnload = el.onload;
        el.onload = function() {
          safeWrapper(() => def(el.contentWindow, "parent", sandbox.global));
          return originOnload.apply(this, arguments);
        };
      }
      if (convertedNode) {
        if (isInsertMethod(this.methodName) && this.rootElement.contains(context) && ((_b = args[1]) == null ? void 0 : _b.parentNode) === context) {
          return originProcess();
        }
        this.sandbox.hooks.lifecycle.appendNode.emit(parentNode, this.el, convertedNode, this.tagName);
        return this.nativeAppend.call(parentNode, convertedNode);
      }
      return originProcess();
    }
    removeChild(context, originProcess) {
      if (typeof this.el[__REMOVE_NODE__] === "function") {
        this.el[__REMOVE_NODE__]();
        return this.el;
      }
      if (this.is("style") || this.is("link") || this.is("script")) {
        const parentNode = this.findParentNodeInApp(context, this.is("script") ? "body" : "head");
        if (this.el.parentNode === parentNode) {
          if (this.sandbox.dynamicStyleSheetElementSet.has(this.el)) {
            this.sandbox.dynamicStyleSheetElementSet.delete(this.el);
          }
          return this.nativeRemove.call(parentNode, this.el);
        }
      }
      return originProcess();
    }
    getRealSheet() {
      return Reflect.get(HTMLStyleElement.prototype, "sheet", this.el);
    }
    createFakeSheet(styleTransformer) {
      const processor = this;
      const rulesData = [];
      this.sandbox.styledComponentCSSRulesMap.set(this.el, rulesData);
      const fakeSheet = {
        get cssRules() {
          var _a;
          const realSheet = processor.getRealSheet();
          return (_a = realSheet == null ? void 0 : realSheet.cssRules) != null ? _a : [];
        },
        insertRule(rule, index) {
          const realSheet = processor.getRealSheet();
          const transformed = styleTransformer(rule);
          if (realSheet) {
            realSheet.insertRule(transformed, index);
          }
          rulesData.splice(index || 0, 0, transformed);
          return index || 0;
        },
        deleteRule(index) {
          const realSheet = processor.getRealSheet();
          if (realSheet) {
            realSheet.deleteRule(index);
          }
          rulesData.splice(index, 1);
        }
      };
      return fakeSheet;
    }
  };
  var DynamicNodeProcessor = _DynamicNodeProcessor;
  DynamicNodeProcessor.linkLock = new LockQueue();

  // ../browser-vm/src/dynamicNode/index.ts
  var mountElementMethods = [
    "append",
    "appendChild",
    "insertBefore",
    "insertAdjacentElement"
  ];
  var removeChildElementMethods = ["removeChild"];
  var ignoreElementTimingTags = makeMap([
    "STYLE",
    "SCRIPTS",
    "LINK",
    "META",
    "TITLE"
  ]);
  function injector(current, methodName) {
    return function() {
      var _a;
      const el = methodName === "insertAdjacentElement" ? arguments[1] : arguments[0];
      const sandbox = sandboxMap.get(el);
      const originProcess = () => current.apply(this, arguments);
      safeWrapper(() => {
        if (ignoreElementTimingTags(el.tagName))
          return;
        if ((el == null ? void 0 : el.setAttribute) && typeof (el == null ? void 0 : el.setAttribute) === "function" && !(el == null ? void 0 : el.getAttribute("elementtiming")) && sandbox && sandbox.options.disableElementtiming !== true) {
          el == null ? void 0 : el.setAttribute("elementtiming", sandbox ? `${sandbox.options.namespace}-element-timing` : "element-timing");
        }
      });
      if (sandbox) {
        if (el && ((_a = this == null ? void 0 : this.tagName) == null ? void 0 : _a.toLowerCase()) === "style") {
          const manager = new sandbox.loader.StyleManager(el.textContent);
          const { baseUrl, namespace, styleScopeId } = sandbox.options;
          manager.correctPath(baseUrl);
          manager.setScope({
            appName: namespace,
            rootElId: styleScopeId()
          });
          el.textContent = manager.transformCode(manager.styleCode);
          return originProcess();
        } else {
          const processor = new DynamicNodeProcessor(el, sandbox, methodName);
          return processor.append(this, arguments, originProcess);
        }
      } else {
        return originProcess();
      }
    };
  }
  function injectorRemoveChild(current, methodName) {
    return function() {
      const el = arguments[0];
      const sandbox = el && sandboxMap.get(el);
      const originProcess = () => {
        return current.apply(this, arguments);
      };
      if (sandbox) {
        const processor = new DynamicNodeProcessor(el, sandbox, methodName);
        return processor.removeChild(this, originProcess);
      }
      return originProcess();
    };
  }
  function handleOwnerDocument() {
    Object.defineProperty(window.Element.prototype, "ownerDocument", {
      get() {
        const sandbox = this && sandboxMap.get(this);
        const realValue = Reflect.get(window.Node.prototype, "ownerDocument", this);
        return sandbox ? sandbox.global.document : realValue;
      },
      set() {
        (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn('"ownerDocument" is a read-only attribute.');
      }
    });
  }
  function makeElInjector(sandboxConfig) {
    if (makeElInjector.hasInject)
      return;
    makeElInjector.hasInject = true;
    if (typeof window.Element === "function") {
      if (sandboxConfig.fixBaseUrl || sandboxConfig.fixOwnerDocument)
        safeWrapper(() => handleOwnerDocument());
      const rewrite = (methods, builder) => {
        for (const name of methods) {
          const fn = window.Element.prototype[name];
          const symbolProxyName = Symbol.for(name + "_proxy");
          const proxyFlag = window.Element.prototype[symbolProxyName];
          if (typeof fn !== "function" || fn[__domWrapper__] || proxyFlag) {
            continue;
          }
          rawElementMethods[name] = fn;
          const wrapper = builder(fn, name);
          wrapper[__domWrapper__] = true;
          window.Element.prototype[name] = wrapper;
          window.Element.prototype[symbolProxyName] = true;
        }
      };
      rewrite(mountElementMethods, injector);
      rewrite(removeChildElementMethods, injectorRemoveChild);
    }
    injectHandlerParams();
  }
  function rebuildCSSRules(dynamicStyleSheetElementSet, styledComponentCSSRulesMap) {
    dynamicStyleSheetElementSet.forEach((styleElement) => {
      const rules = styledComponentCSSRulesMap.get(styleElement);
      if (rules && (isStyledComponentsLike(styleElement) || rules.length)) {
        const realSheet = Reflect.get(HTMLStyleElement.prototype, "sheet", styleElement);
        if (realSheet) {
          for (let i = 0; i < rules.length; i++) {
            const cssRule = rules[i];
            realSheet.insertRule(cssRule, i);
          }
        }
      }
    });
  }

  // ../browser-vm/src/lifecycle.ts
  function sandboxLifecycle() {
    return new PluginSystem({
      closed: new SyncHook(),
      stared: new SyncHook(),
      appendNode: new SyncHook(),
      documentGetter: new SyncWaterfallHook("documentGetter"),
      beforeClearEffect: new SyncHook(),
      afterClearEffect: new SyncHook(),
      beforeInvoke: new SyncHook(),
      afterInvoke: new SyncHook(),
      invokeError: new SyncHook()
    });
  }

  // ../browser-vm/src/proxyInterceptor/global.ts
  function createGetter2(sandbox) {
    return (target, p, receiver) => {
      if (p === Symbol.unscopables)
        return void 0;
      let value;
      const { overrideList } = sandbox.replaceGlobalVariables;
      if (sandbox.isProtectVariable(p)) {
        return Reflect.get(window, p);
      } else if (sandbox.isInsulationVariable(p)) {
        value = Reflect.get(target, p, receiver);
      } else {
        value = hasOwn(target, p) ? Reflect.get(target, p, receiver) : Reflect.get(window, p);
      }
      if (typeof value === "function") {
        if (isEsGlobalMethods(p) || isNativeCodeMethods(p) || hasOwn(overrideList, p) || isConstructor(value) || sandbox.isExternalGlobalVariable.has(p)) {
          return value;
        }
      } else {
        return value;
      }
      const newValue = hasOwn(value, __windowBind__) ? value[__windowBind__] : bind(value, window);
      const verifyResult = verifyGetterDescriptor(target, p, newValue);
      if (verifyResult > 0) {
        if (verifyResult === 1)
          return value;
        if (verifyResult === 2)
          return void 0;
      }
      value[__windowBind__] = newValue;
      return newValue;
    };
  }
  var safariProxyWindowDealHandler = safari13Deal();
  function createSetter2(sandbox) {
    return (target, p, value, receiver) => {
      const verifyResult = verifySetterDescriptor(sandbox.isProtectVariable(p) ? window : receiver ? receiver : target, p, value);
      if (verifyResult > 0) {
        if (verifyResult === 1 || verifyResult === 2)
          return false;
        if (verifyResult === 3)
          return true;
      }
      if (sandbox.isProtectVariable(p)) {
        return Reflect.set(window, p, value);
      } else {
        safariProxyWindowDealHandler.triggerSet();
        const success = Reflect.set(target, p, value, receiver);
        if (success) {
          if (sandbox.initComplete) {
            sandbox.isExternalGlobalVariable.add(p);
          }
          if (sandbox.global) {
            const methods = sandbox.global[`${GARFISH_OPTIMIZE_NAME}Methods`];
            if (Array.isArray(methods)) {
              if (methods.includes(p)) {
                const updateStack = sandbox.global[`${GARFISH_OPTIMIZE_NAME}UpdateStack`];
                updateStack.forEach((fn) => fn(p, value));
              }
            }
          }
        }
        return success;
      }
    };
  }
  function createDefineProperty2(sandbox) {
    return (target, p, descriptor) => {
      safariProxyWindowDealHandler.handleDescriptor(descriptor);
      if (sandbox.isProtectVariable(p)) {
        return Reflect.defineProperty(window, p, descriptor);
      } else {
        const success = Reflect.defineProperty(target, p, descriptor);
        if (sandbox.initComplete && success) {
          sandbox.isExternalGlobalVariable.add(p);
        }
        return success;
      }
    };
  }
  function createDeleteProperty(sandbox) {
    return (target, p) => {
      if (hasOwn(target, p)) {
        delete target[p];
        if (sandbox.initComplete && sandbox.isExternalGlobalVariable.has(p)) {
          sandbox.isExternalGlobalVariable.delete(p);
        }
      } else if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
        if (hasOwn(window, p) && sandbox.isProtectVariable(p)) {
          warn(`The "${String(p)}" is global protect variable."`);
        }
      }
      return true;
    };
  }
  function createHas2(sandbox) {
    return (_target, p) => {
      if (sandbox.isProtectVariable(p))
        return false;
      if (sandbox.envVariable === p)
        return false;
      return true;
    };
  }

  // ../browser-vm/src/sandbox.ts
  var id = 0;
  var defaultModules = [
    networkModule,
    timeoutModule,
    intervalModule,
    historyModule,
    documentModule,
    listenerModule,
    observerModule,
    UiEventOverride,
    localStorageModule
  ];
  var isModule = (module) => {
    return isObject(module) ? module[__garfishGlobal__] !== void 0 : false;
  };
  var addProxyWindowType = (module, parentModule) => {
    if (!isModule(module)) {
      module[__garfishGlobal__] = parentModule;
    }
    return module;
  };
  var Sandbox = class {
    constructor(options) {
      this.id = id++;
      this.type = "vm";
      this.closed = true;
      this.initComplete = false;
      this.version = "1.17.5";
      this.hooks = sandboxLifecycle();
      this.deferClearEffects = /* @__PURE__ */ new Set();
      this.isExternalGlobalVariable = /* @__PURE__ */ new Set();
      this.dynamicStyleSheetElementSet = /* @__PURE__ */ new Set();
      this.styledComponentCSSRulesMap = /* @__PURE__ */ new WeakMap();
      this.optimizeCode = "";
      this.envVariable = "__GARFISH_SANDBOX_ENV_VAR__";
      const defaultOptions = {
        baseUrl: "",
        namespace: "",
        modules: [],
        fixBaseUrl: false,
        fixStaticResourceBaseUrl: true,
        disableWith: false,
        strictIsolation: false,
        disableCollect: false,
        el: () => null,
        styleScopeId: () => "",
        protectVariable: () => [],
        insulationVariable: () => []
      };
      this.options = isPlainObject(options) ? deepMerge(defaultOptions, options) : defaultOptions;
      const { loaderOptions, protectVariable, insulationVariable } = this.options;
      this.loader = new Loader(loaderOptions);
      this.isProtectVariable = makeMap((protectVariable == null ? void 0 : protectVariable()) || []);
      this.isInsulationVariable = makeMap((insulationVariable == null ? void 0 : insulationVariable()) || []);
      this.replaceGlobalVariables = {
        createdList: [],
        prepareList: [],
        recoverList: [],
        overrideList: {}
      };
      makeElInjector(this.options);
      this.start();
      sandboxMap.set(this);
    }
    start() {
      this.closed = false;
      this.replaceGlobalVariables = this.getModuleData();
      const { createdList, overrideList } = this.replaceGlobalVariables;
      this.global = this.createProxyWindow(Object.keys(overrideList));
      if (overrideList && this.global) {
        for (const key in overrideList) {
          this.global[key] = overrideList[key];
        }
      }
      if (createdList) {
        createdList.forEach((fn) => fn && fn(this.global));
      }
      if (!this.options.disableWith) {
        this.optimizeCode = this.optimizeGlobalMethod();
      }
      this.initComplete = true;
      this.hooks.lifecycle.stared.emit(this.global);
    }
    close() {
      if (this.closed)
        return;
      this.clearEffects();
      this.closed = true;
      this.global = void 0;
      this.optimizeCode = "";
      this.initComplete = false;
      this.deferClearEffects.clear();
      this.isExternalGlobalVariable.clear();
      this.dynamicStyleSheetElementSet.clear();
      this.replaceGlobalVariables.createdList = [];
      this.replaceGlobalVariables.prepareList = [];
      this.replaceGlobalVariables.recoverList = [];
      this.replaceGlobalVariables.overrideList = [];
      this.hooks.lifecycle.closed.emit();
    }
    reset() {
      this.close();
      this.start();
    }
    createProxyWindow(moduleKeys = []) {
      const fakeWindow = createFakeObject(window, this.isInsulationVariable, makeMap(moduleKeys));
      const baseHandlers = {
        get: createGetter2(this),
        set: createSetter2(this),
        defineProperty: createDefineProperty2(this),
        deleteProperty: createDeleteProperty(this),
        getPrototypeOf() {
          return Object.getPrototypeOf(window);
        }
      };
      const parentHandlers = __spreadProps(__spreadValues({}, baseHandlers), {
        has: createHas2(this),
        getPrototypeOf() {
          return Object.getPrototypeOf(window);
        }
      });
      const proxy = new Proxy(fakeWindow, parentHandlers);
      const subProxy = new Proxy(fakeWindow, baseHandlers);
      proxy.self = subProxy;
      proxy.window = subProxy;
      proxy.globalThis = subProxy;
      proxy.__debug_sandbox__ = this;
      safeWrapper(() => {
        proxy.top = window.top === window ? subProxy : window.top;
        proxy.parent = window.parent === window ? subProxy : window.parent;
      });
      addProxyWindowType(proxy, window);
      return proxy;
    }
    getModuleData() {
      var _a;
      const recoverList = [];
      const createdList = [];
      const prepareList = [];
      const overrideList = {};
      const allModules = defaultModules.concat((_a = this.options.modules) != null ? _a : []);
      for (const module of allModules) {
        if (typeof module === "function") {
          const { recover, override, created, prepare } = module(this) || {};
          if (recover)
            recoverList.push(recover);
          if (created)
            createdList.push(created);
          if (prepare)
            prepareList.push(prepare);
          if (override) {
            for (const key in override) {
              if ((typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && overrideList[key]) {
                warn(`"${key}" global variables are overwritten.`);
              }
              overrideList[key] = override[key];
            }
          }
        }
      }
      return { recoverList, createdList, overrideList, prepareList };
    }
    clearEffects() {
      this.hooks.lifecycle.beforeClearEffect.emit();
      this.replaceGlobalVariables.recoverList.forEach((fn) => fn && fn());
      this.deferClearEffects.forEach((fn) => fn && fn());
      this.hooks.lifecycle.afterClearEffect.emit();
    }
    optimizeGlobalMethod(tempEnvKeys = []) {
      let code = "";
      const methods = optimizeMethods.filter((p) => {
        return p && !this.isProtectVariable(p) && !tempEnvKeys.includes(p) && hasOwn(this.global, p);
      });
      if (methods.length > 0) {
        code = methods.reduce((prevCode, name) => {
          return `${prevCode} let ${name} = window.${name};`;
        }, code);
        if (this.global) {
          this.global[`${GARFISH_OPTIMIZE_NAME}Methods`] = methods;
          this.global[`${GARFISH_OPTIMIZE_NAME}UpdateStack`] = [];
        }
        code += `window.${GARFISH_OPTIMIZE_NAME}UpdateStack.push(function(k,v){eval(k+"=v")});`;
      }
      if (tempEnvKeys.length > 0) {
        code = tempEnvKeys.reduce((prevCode, name) => {
          return `${prevCode} let ${name} = ${this.envVariable}.${name};`;
        }, code);
      }
      return code;
    }
    createExecParams(codeRef, env) {
      const { disableWith } = this.options;
      const { prepareList, overrideList } = this.replaceGlobalVariables;
      if (prepareList) {
        prepareList.forEach((fn) => fn && fn());
      }
      const params = __spreadValues({
        window: this.global
      }, overrideList);
      if (disableWith) {
        Object.assign(params, env);
      } else {
        const envKeys = Object.keys(env);
        const optimizeCode = envKeys.length > 0 ? this.optimizeGlobalMethod(envKeys) : this.optimizeCode;
        codeRef.code = `with(window) {;${optimizeCode + codeRef.code}
}`;
        params[this.envVariable] = env;
      }
      return params;
    }
    processExecError(e, url, env, options) {
      this.hooks.lifecycle.invokeError.emit(e, url, env, options);
      if (this.global && typeof this.global.onerror === "function") {
        const source = url || this.options.baseUrl;
        const message = e instanceof Error ? e.message : String(e);
        safeWrapper(() => {
          var _a, _b;
          (_b = (_a = this.global) == null ? void 0 : _a.onerror) == null ? void 0 : _b.call(this.global, message, source, null, null, e);
        });
      }
      throw e;
    }
    execScript(code, env = {}, url = "", options) {
      var _a;
      const codeRef = { code };
      const { async, defer } = options || {};
      this.hooks.lifecycle.beforeInvoke.emit(codeRef, url, env, options);
      const revertCurrentScript = setDocCurrentScript((_a = this.global) == null ? void 0 : _a.document, codeRef.code, false, url, async, defer, options == null ? void 0 : options.originScript);
      try {
        const params = this.createExecParams(codeRef, env);
        codeRef.code += `
${url ? `//# sourceURL=${url}
` : ""}`;
        evalWithEnv(codeRef.code, params, this.global);
      } catch (e) {
        this.processExecError(e, url, env, options);
      } finally {
        Promise.resolve().then(revertCurrentScript);
      }
      this.hooks.lifecycle.afterInvoke.emit(codeRef, url, env, options);
    }
    static getNativeWindow() {
      let module = window;
      while (isModule(module)) {
        module = module[__garfishGlobal__];
      }
      return module;
    }
    static canSupport() {
      let support = true;
      if (!window.Proxy || !Array.prototype.includes || !String.prototype.includes) {
        support = false;
      }
      if (support) {
        try {
          new Function("let a = 666;");
        } catch (e) {
          support = false;
        }
      }
      if (!support) {
        warn('The current environment does not support "vm sandbox",Please use the "snapshot sandbox" instead.');
      }
      return support;
    }
  };

  // ../browser-vm/src/pluginify.ts
  var specialExternalVariables = [
    "onerror",
    "webpackjsonp",
    "__REACT_ERROR_OVERLAY_GLOBAL_HOOK__",
    (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) ? "webpackHotUpdate" : ""
  ];
  function compatibleOldModule(modules) {
    if (!Array.isArray(modules)) {
      (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) && warn('"vm sandbox" modules should be an array');
      const list = [];
      for (const key in modules) {
        list.push(modules[key]);
      }
      modules = list;
    }
    return modules;
  }
  function rewriteAppAndSandbox(Garfish2, app, sandbox) {
    var _a;
    const originExecScript = sandbox.execScript;
    sandbox.loader = Garfish2.loader;
    sandbox.execScript = (code, env, url, options) => {
      const evalHooksArgs = [app.appInfo, code, env, url, options];
      app.hooks.lifecycle.beforeEval.emit(...evalHooksArgs);
      try {
        const res = originExecScript.call(sandbox, code, __spreadValues(__spreadValues({}, env), app.getExecScriptEnv(options == null ? void 0 : options.noEntry)), url, options);
        app.hooks.lifecycle.afterEval.emit(...evalHooksArgs);
        return res;
      } catch (err) {
        app.hooks.lifecycle.errorExecCode.emit(err, ...evalHooksArgs);
        throw err;
      }
    };
    app.vmSandbox = sandbox;
    app.global = sandbox.global;
    app.strictIsolation = (_a = sandbox.options.strictIsolation) != null ? _a : false;
    app.runCode = function() {
      return originExecScript.apply(sandbox, arguments);
    };
    if (app.entryManager.DOMApis && sandbox.global) {
      app.entryManager.DOMApis.document = sandbox.global.document;
    }
  }
  function createOptions(Garfish2) {
    const canSupport = Sandbox.canSupport();
    const options = {
      name: "browser-vm",
      version: "1.17.5",
      afterLoad(appInfo, appInstance) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!canSupport || !appInstance || (appInstance == null ? void 0 : appInstance.vmSandbox) || appInfo.sandbox === false || appInfo.sandbox && appInfo.sandbox.open === false || appInfo.sandbox && appInfo.sandbox.snapshot) {
          if (appInstance == null ? void 0 : appInstance.vmSandbox) {
            appInstance.global = appInstance.vmSandbox.global;
          }
          return;
        }
        rewriteAppAndSandbox(Garfish2, appInstance, new Sandbox({
          namespace: appInfo.name,
          addSourceList: appInstance.addSourceList.bind(appInstance),
          baseUrl: appInstance.entryManager.url,
          modules: compatibleOldModule(((_a = appInfo.sandbox) == null ? void 0 : _a.modules) || []),
          fixBaseUrl: Boolean((_b = appInfo.sandbox) == null ? void 0 : _b.fixBaseUrl),
          fixStaticResourceBaseUrl: Boolean((_c = appInfo.sandbox) == null ? void 0 : _c.fixStaticResourceBaseUrl),
          fixOwnerDocument: Boolean((_d = appInfo.sandbox) == null ? void 0 : _d.fixOwnerDocument),
          disableWith: Boolean((_e = appInfo.sandbox) == null ? void 0 : _e.disableWith),
          disableElementtiming: Boolean((_f = appInfo.sandbox) == null ? void 0 : _f.disableElementtiming),
          strictIsolation: Boolean((_g = appInfo.sandbox) == null ? void 0 : _g.strictIsolation),
          disableCollect: appInfo.cache === void 0 ? true : Boolean(appInfo.cache),
          el: () => appInstance.htmlNode,
          styleScopeId: () => appInstance.appContainer.id,
          protectVariable: () => appInfo.protectVariable || [],
          insulationVariable: () => {
            return [
              ...specialExternalVariables,
              ...appInfo.insulationVariable || []
            ].filter(Boolean);
          }
        }));
      },
      afterUnmount(appInfo, appInstance, isCacheMode) {
        if (appInstance.vmSandbox && !isCacheMode) {
          appInstance.vmSandbox.reset();
        }
      },
      afterMount(appInfo, appInstance) {
        if (appInstance.vmSandbox) {
          rebuildCSSRules(appInstance.vmSandbox.dynamicStyleSheetElementSet, appInstance.vmSandbox.styledComponentCSSRulesMap);
          appInstance.vmSandbox.execScript(`
          if (typeof window.onload === 'function') {
            window.onload.call(window);
          }
        `);
        }
      }
    };
    return options;
  }
  function GarfishBrowserVm() {
    return function(Garfish2) {
      Garfish2.getGlobalObject = function() {
        return Sandbox.getNativeWindow();
      };
      Garfish2.setGlobalValue = function(key, value) {
        return this.getGlobalObject()[key] = value;
      };
      Garfish2.clearEscapeEffect = function(key, value) {
        const global2 = this.getGlobalObject();
        if (key in global2) {
          global2[key] = value;
        }
      };
      return createOptions(Garfish2);
    };
  }

  // ../browser-snapshot/src/patchers/event.ts
  var rawAddEventListener;
  var rawRemoveEventListener;
  var PatchEvent = class {
    constructor() {
      this.listenerMap = /* @__PURE__ */ new Map();
    }
    activate() {
      this.listenerMap.forEach((listeners, type) => [...listeners].forEach((listener) => window.addEventListener(type, listener)));
      if (!rawAddEventListener || !rawRemoveEventListener) {
        rawAddEventListener = window.addEventListener;
        rawRemoveEventListener = window.removeEventListener;
      }
      window.addEventListener = (type, listener, options) => {
        const listeners = this.listenerMap.get(type) || [];
        this.listenerMap.set(type, [...listeners, listener]);
        return rawAddEventListener.call(window, type, listener, options);
      };
      window.removeEventListener = (type, listener, options) => {
        const storedTypeListeners = this.listenerMap.get(type);
        if (storedTypeListeners && storedTypeListeners.length && storedTypeListeners.indexOf(listener) !== -1) {
          storedTypeListeners.splice(storedTypeListeners.indexOf(listener), 1);
        }
        return rawRemoveEventListener.call(window, type, listener, options);
      };
    }
    deactivate() {
      this.listenerMap.forEach((listeners, type) => [...listeners].forEach((listener) => window.removeEventListener(type, listener)));
      window.removeEventListener = rawRemoveEventListener;
      window.addEventListener = rawAddEventListener;
    }
  };

  // ../browser-snapshot/src/patchers/interceptor.ts
  function isStyledComponentsLike2(element) {
    var _a;
    return element instanceof HTMLStyleElement && !element.textContent && ((_a = element.sheet) == null ? void 0 : _a.cssRules.length);
  }
  var Snapshot = class {
    constructor(arrDoms) {
      this.arrDoms = arrDoms;
      this.arrDoms = arrDoms;
    }
    static take(target = document.head) {
      let list;
      if (target.childNodes) {
        list = Array.prototype.slice.call(target.childNodes);
      } else {
        list = Array.prototype.slice.call(target);
      }
      return new Snapshot(list);
    }
    diff(s) {
      if (!s) {
        return {
          created: new Snapshot([]),
          removed: new Snapshot([])
        };
      }
      return {
        created: new Snapshot(this.arrDoms.filter((d) => s.arrDoms.indexOf(d) === -1)),
        removed: new Snapshot(s.arrDoms.filter((d) => this.arrDoms.indexOf(d) === -1))
      };
    }
  };
  var Interceptor = class {
    constructor(dom = document.head) {
      this.dom = dom;
      this.dom = dom;
      this.dynamicStyleSheetElementSet = /* @__PURE__ */ new Set();
      this.styledComponentCSSRulesMap = /* @__PURE__ */ new WeakMap();
    }
    add(createdOrSnapshot, removed) {
      let created;
      if (!removed) {
        const diff = Snapshot.take(this.dom).diff(createdOrSnapshot);
        created = diff.created;
        removed = diff.removed;
      } else {
        created = createdOrSnapshot;
      }
      created.arrDoms.reduce((prev, val) => {
        var _a, _b;
        prev.appendChild(val);
        if (val instanceof HTMLStyleElement) {
          const cssRules = this.styledComponentCSSRulesMap.get(val);
          if (cssRules && cssRules.length) {
            for (let i = 0; i < cssRules.length; i++) {
              const cssRule = cssRules[i];
              (_b = val.sheet) == null ? void 0 : _b.insertRule(cssRule.cssText, (_a = val.sheet) == null ? void 0 : _a.cssRules.length);
            }
          }
        }
        return prev;
      }, this.dom);
      removed.arrDoms.reduce((prev, val) => {
        prev.removeChild(val);
        return prev;
      }, this.dom);
    }
    remove(createdOrSnapshot, removed) {
      let created;
      if (!removed) {
        const diff = Snapshot.take(this.dom).diff(createdOrSnapshot);
        created = diff.created;
        removed = diff.removed;
      } else {
        created = createdOrSnapshot;
      }
      created.arrDoms.reduce((prev, val) => {
        var _a;
        if (val instanceof HTMLStyleElement && isStyledComponentsLike2(val) && ((_a = val == null ? void 0 : val.sheet) == null ? void 0 : _a.cssRules)) {
          this.styledComponentCSSRulesMap.set(val, val.sheet.cssRules);
        }
        prev.removeChild(val);
        return prev;
      }, this.dom);
      removed.arrDoms.reduce((prev, val) => {
        prev.appendChild(val);
        return prev;
      }, this.dom);
    }
  };

  // ../browser-snapshot/src/patchers/style.ts
  var PatchStyle = class {
    constructor() {
      this.headInterceptor = new Interceptor(document.head);
    }
    activate() {
      this.domSnapshotBefore = Snapshot.take();
      if (this.domSnapshotMutated)
        this.headInterceptor.add(this.domSnapshotMutated.created, this.domSnapshotMutated.removed);
    }
    deactivate() {
      const domSnapshot = Snapshot.take();
      this.domSnapshotMutated = domSnapshot.diff(this.domSnapshotBefore);
      if (!this.domSnapshotMutated)
        return;
      this.headInterceptor.remove(this.domSnapshotMutated.created, this.domSnapshotMutated.removed);
    }
    formateCtx(arrDoms) {
      const effectMap = {
        style: [],
        script: [],
        other: []
      };
      arrDoms.forEach((dom) => {
        let type = "other";
        if (/css/.test(dom.type))
          type = "style";
        if (/javascript/.test(dom.type))
          type = "script";
        effectMap[type].push({
          src: dom.src,
          outerHTML: dom.outerHTML,
          content: dom.innerText
        });
      });
      return effectMap;
    }
  };

  // ../browser-snapshot/src/patchers/history.ts
  var rawPushState;
  var rawReplaceState;
  var PatchHistory = class {
    activate() {
      if (!rawPushState || !rawReplaceState) {
        rawPushState = window.history.pushState;
        rawReplaceState = window.history.replaceState;
      }
    }
    deactivate() {
      window.history.pushState = rawPushState;
      window.history.replaceState = rawReplaceState;
    }
  };

  // ../browser-snapshot/src/patchers/interval.ts
  var rawInterval = window.setInterval;
  var rawClearInterval2 = window.clearInterval;
  var PatchInterval = class {
    constructor() {
      this.intervals = [];
    }
    activate() {
      window.setInterval = (handler, timeout, ...args) => {
        const intervalId = rawInterval(handler, timeout, ...args);
        this.intervals = [...this.intervals, intervalId];
        return intervalId;
      };
      window.clearInterval = (intervalId) => {
        this.intervals = this.intervals.filter((id2) => id2 !== intervalId);
        return rawClearInterval2(intervalId);
      };
    }
    deactivate(_clearEffects) {
      if (_clearEffects) {
        this.intervals.forEach((id2) => window.clearInterval(id2));
      }
      window.setInterval = rawInterval;
      window.clearInterval = rawClearInterval2;
    }
  };

  // ../browser-snapshot/src/patchers/variable.ts
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function hasOwn2(obj, key) {
    return hasOwnProperty2.call(obj, key);
  }
  var PatchGlobalVal = class {
    constructor(targetToProtect = typeof window !== "undefined" ? window : globalThis, protectVariable = []) {
      this.targetToProtect = targetToProtect;
      this.protectVariable = protectVariable;
      this.snapshotOriginal = /* @__PURE__ */ new Map();
      this.snapshotMutated = /* @__PURE__ */ new Map();
      this.whiteList = [
        "location",
        "addEventListener",
        "removeEventListener",
        "webpackJsonp"
      ];
      this.targetToProtect = targetToProtect;
      this.protectVariable = protectVariable;
      this.whiteList = [...this.whiteList, ...protectVariable];
    }
    safeIterator(fn) {
      for (const i in this.targetToProtect) {
        if (this.whiteList.indexOf(i) !== -1) {
          continue;
        }
        const prop = Object.getOwnPropertyDescriptor(this.targetToProtect, i);
        if (!prop || !prop.writable) {
          continue;
        }
        if (hasOwn2(this.targetToProtect, i)) {
          fn(i);
        }
      }
    }
    activate() {
      this.safeIterator((i) => {
        this.snapshotOriginal.set(i, this.targetToProtect[i]);
      });
      this.snapshotMutated.forEach((val, mutateKey) => {
        this.targetToProtect[mutateKey] = this.snapshotMutated.get(mutateKey);
      });
    }
    deactivate() {
      const deleteMap = {};
      const updateMap = {};
      const addMap = {};
      this.safeIterator((normalKey) => {
        if (this.snapshotOriginal.get(normalKey) !== this.targetToProtect[normalKey]) {
          this.snapshotMutated.set(normalKey, this.targetToProtect[normalKey]);
          this.targetToProtect[normalKey] = this.snapshotOriginal.get(normalKey);
          if (this.targetToProtect[normalKey] === void 0) {
            addMap[normalKey] = this.snapshotMutated.get(normalKey);
          } else {
            updateMap[normalKey] = this.snapshotMutated.get(normalKey);
          }
        }
        this.snapshotOriginal.delete(normalKey);
      });
      this.snapshotOriginal.forEach((val, deleteKey) => {
        this.snapshotMutated.set(deleteKey, this.targetToProtect[deleteKey]);
        this.targetToProtect[deleteKey] = this.snapshotOriginal.get(deleteKey);
        deleteMap[deleteKey] = this.targetToProtect[deleteKey];
      });
    }
  };

  // ../browser-snapshot/src/patchers/webpackjsonp.ts
  var PatchWebpackJsonp = class {
    activate() {
      this.preWebpackJsonp = window.webpackJsonp;
      window.webpackJsonp = this.currentWebpackJsonp;
    }
    deactivate() {
      this.currentWebpackJsonp = window.webpackJsonp;
      window.webpackJsonp = this.preWebpackJsonp;
    }
  };

  // ../browser-snapshot/src/sandbox.ts
  var Sandbox2 = class {
    constructor(name, protectVariable = [], targetToProtect = typeof window !== "undefined" ? window : globalThis, isInBrowser = typeof window === "undefined" ? false : true) {
      this.name = name;
      this.protectVariable = protectVariable;
      this.targetToProtect = targetToProtect;
      this.isInBrowser = isInBrowser;
      this.type = "snapshot";
      this.isRunning = false;
      this.patchList = [];
      this.name = name;
      this.isInBrowser = isInBrowser;
      this.patchList.push(new PatchGlobalVal(targetToProtect, protectVariable));
      if (this.isInBrowser) {
        this.patchList = [
          ...this.patchList,
          new PatchStyle(),
          new PatchEvent(),
          new PatchHistory(),
          new PatchInterval(),
          new PatchWebpackJsonp()
        ];
      }
    }
    activate() {
      if (this.isRunning)
        return;
      this.patchList.forEach((patch) => {
        patch.activate();
      });
      this.isRunning = true;
    }
    deactivate(clearEffects = true) {
      if (!this.isRunning)
        return;
      [...this.patchList].reverse().forEach((patch) => {
        patch.deactivate(clearEffects);
      });
      this.isRunning = false;
    }
  };

  // ../browser-snapshot/src/index.ts
  function GarfishBrowserSnapshot(op) {
    return function(Garfish2) {
      const options = {
        openBrowser: false,
        version: "1.17.5",
        name: "browser-snapshot",
        afterLoad(appInfo, appInstance) {
          var _a;
          const config = op || { open: true };
          const sandboxConfig = appInfo.sandbox || ((_a = Garfish2 == null ? void 0 : Garfish2.options) == null ? void 0 : _a.sandbox);
          if (sandboxConfig === false || sandboxConfig.open === false || (sandboxConfig == null ? void 0 : sandboxConfig.snapshot) === false) {
            config.open = false;
          }
          if (sandboxConfig) {
            config.protectVariable = [
              ...(Garfish2 == null ? void 0 : Garfish2.options.protectVariable) || [],
              ...appInfo.protectVariable || []
            ];
          }
          options.openBrowser = !!config.open;
          if (!config.open)
            return;
          if (appInstance) {
            if (appInstance.snapshotSandbox)
              return;
            const sandbox = new Sandbox2(appInfo.name, config.protectVariable);
            appInstance.snapshotSandbox = sandbox;
          }
        },
        beforeMount(appInfo, appInstance) {
          if (!appInstance.snapshotSandbox)
            return;
          appInstance.snapshotSandbox.activate();
        },
        afterUnmount(appInfo, appInstance) {
          if (!appInstance.snapshotSandbox)
            return;
          appInstance.snapshotSandbox.deactivate();
        }
      };
      return options;
    };
  }

  // src/instance.ts
  function createContext() {
    let fresh = false;
    if (inBrowser() && window["__GARFISH__"] && window["Garfish"]) {
      return window["Garfish"];
    }
    const GarfishInstance2 = new Garfish({
      plugins: [GarfishRouter(), GarfishBrowserVm(), GarfishBrowserSnapshot()]
    });
    const set2 = (namespace, val = GarfishInstance2) => {
      if (hasOwn(window, namespace)) {
        if (!(window[namespace] && window[namespace].flag === __GARFISH_FLAG__)) {
          const next = () => {
            fresh = true;
            if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
              warn(`"Window.${namespace}" will be overwritten by "garfish".`);
            }
          };
          const desc = Object.getOwnPropertyDescriptor(window, namespace);
          if (desc) {
            if (desc.configurable) {
              def(window, namespace, val);
              next();
            } else if (desc.writable) {
              window[namespace] = val;
              next();
            }
          }
        }
      } else {
        fresh = true;
        def(window, namespace, val);
      }
    };
    if (inBrowser()) {
      set2("Garfish");
      def(window, "__GARFISH__", true);
    }
    if (fresh) {
      if (typeof process !== "undefined" && process.env && process.env.NODE_ENV ? process.env.NODE_ENV !== "production" : false) {
        if (window["Garfish"].version !== "1.17.5") {
          warn('The "garfish version" used by the main and sub-applications is inconsistent.');
        }
      }
    }
    return GarfishInstance2;
  }
  var GarfishInstance = createContext();

  // src/customElement.ts
  function generateCustomerElement(htmlTag, options) {
    class MicroApp extends HTMLElement {
      constructor() {
        super();
        this.appInfo = {
          name: "",
          entry: "",
          basename: ""
        };
        this.options = {
          delay: 200
        };
        this.state = this._observerAppState({
          isLoading: false,
          error: null,
          promise: null,
          loaded: null,
          pastDelay: false
        });
        this.options = options;
      }
      _observerAppState(state) {
        return new Proxy(state, {
          set: (target, p, value, receiver) => {
            const getPlaceHolderAndAppend = () => {
              if (this.placeholder && this.contains(this.placeholder)) {
                this.removeChild(this.placeholder);
              }
              const placeholder = this.options.loading && this.options.loading({
                isLoading: this.state.isLoading,
                error: this.state.error,
                pastDelay: this.state.pastDelay
              });
              placeholder && this.appendChild(placeholder);
              return placeholder;
            };
            const res = Reflect.set(target, p, value, receiver);
            if (p === "error" && value) {
              const placeholder = getPlaceHolderAndAppend();
              if (placeholder)
                this.placeholder = placeholder;
            } else if (p === "pastDelay" && value === true) {
              const placeholder = getPlaceHolderAndAppend();
              if (placeholder)
                this.placeholder = placeholder;
            } else if (p === "isLoading" && value === true) {
              const placeholder = getPlaceHolderAndAppend();
              if (placeholder)
                this.placeholder = placeholder;
            } else if (p === "isLoading" && value === false) {
              if (!this.state.error && this.contains(this.placeholder)) {
                this.removeChild(this.placeholder);
              }
            }
            return res;
          }
        });
      }
      _loadApp() {
        if (this.state.isLoading)
          return;
        this.state.isLoading = true;
        if (typeof this.options.delay === "number") {
          if (this.options.delay === 0) {
            this.state.pastDelay = true;
          } else {
            this._delay = setTimeout(() => {
              this.state.pastDelay = true;
            }, this.options.delay);
          }
        }
        this.state.promise = GarfishInstance.loadApp(this.appInfo.name, {
          entry: this.appInfo.entry,
          domGetter: () => this,
          basename: this.appInfo.basename,
          sandbox: {
            snapshot: false,
            strictIsolation: this.hasAttribute("shadow") || false
          }
        });
      }
      _clearTimeouts() {
        clearTimeout(this._delay);
      }
      async connectedCallback() {
        this.appInfo = {
          name: this.getAttribute("name") || "",
          entry: this.getAttribute("entry") || "",
          basename: this.getAttribute("basename") || "/"
        };
        try {
          this._loadApp();
          this.state.loaded = await this.state.promise;
          if (this.state.loaded.mounted) {
            this.state.loaded.show();
          } else {
            await this.state.loaded.mount();
          }
        } catch (error2) {
          this.state.error = error2;
        } finally {
          this.state.isLoading = false;
        }
      }
      disconnectedCallback() {
        this._clearTimeouts();
        if (this.state.loaded) {
          this.state.loaded.hide();
        }
      }
      async adoptedCallback() {
      }
      attributeChangedCallback(name, oldValue, newValue) {
        console.log("Custom square element attributes changed.", name, oldValue, newValue);
      }
    }
    if (!customElements.get(htmlTag)) {
      GarfishInstance.run(options.config || {});
      customElements.define(htmlTag, MicroApp);
    }
  }
  function createLoadableWebComponent(htmlTag, options) {
    if (typeof htmlTag !== "string") {
      throw new Error("garfish requires a `htmlTag` name");
    }
    if (!options.loading) {
      throw new Error("garfish requires a `loading` component");
    }
    const opts = Object.assign({
      loading: false,
      delay: 200,
      timeout: null
    }, options);
    return generateCustomerElement(htmlTag, opts);
  }
  function defineCustomElements(htmlTag, options) {
    return createLoadableWebComponent(htmlTag, options);
  }
})();
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
